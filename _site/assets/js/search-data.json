{"0": {
    "doc": "03-2022-Ohm",
    "title": "yAcademy Ohm review",
    "content": "Review Resources: Requirements Doc Support Doc . Residents: . | NibblerExpress | Sjkelleyjr | Engn33r | . ",
    "url": "/reports/03-2022-Ohm/#yacademy-ohm-review",
    "relUrl": "/reports/03-2022-Ohm/#yacademy-ohm-review"
  },"1": {
    "doc": "03-2022-Ohm",
    "title": "Table of Contents",
    "content": ". | Review Summary | Scope | Code Evaluation Matrix | Findings Explanation | High Findings . | 1. staking.unstake() should set rebasing bool to true (engn33r) . | Proof of concept | Impact | Recommendation | Remediation Status | . | 2. Sandwich attack risk in YieldStreamer.sol (engn33r) . | Proof of concept | Impact | Recommendation | Remediation Status | . | . | Medium Findings . | 1. Denial of service in upkeep “for” loop in YieldStreamer.sol (sjkelleyjr) . | Proof of concept | Impact | Recommendation | Remediation Status | . | . | Low Findings . | 1. donatedTo and depositsTo only return the first of N possible donation or deposit mappings (sjkelleyjr) . | Proof of concept | Impact | Recommendation | Remediation Status | . | 2. _redeemAll() does not delete recipientLookup (sjkelleyjr) . | Proof of concept | Impact | Recommendation | Remediation Status | . | . | Gas Savings Findings . | 1. Declare function external for gas savings (sjkelleyjr) . | Proof of concept | Impact | Recommendation | Remediation Status | . | 2. Use == for gas savings (sjkelleyjr) . | Proof of concept | Impact | Recommendation | Remediation Status | . | 3. Simplify math for gas savings (engn33r) . | Proof of concept | Impact | Recommendation | Remediation Status | . | 4. Use msg.sender for gas savings (engn33r) . | Proof of concept | Impact | Recommendation | Remediation Status | . | 5. Remove functions to save gas on deployment (engn33r) . | Proof of concept | Impact | Recommendation | Remediation Status | . | 6. Gas savings using unchecked (engn33r) . | Proof of concept | Impact | Recommendation | Remediation Status | . | 7. Gas savings with memory variable (engn33r) . | Proof of concept | Impact | Recommendation | Remediation Status | . | 8. redeemAll repeatedly computes index - 1 (NibblerExpress) . | Proof of Concept | Impact | Recommendation | Remediation Status | . | . | Informational Findings . | 1. Miscellaneous Improvement Ideas (engn33r) . | Proof of concept | Impact | Recommendation | Remediation Status | . | 2. updateUserMinDaiThreshold assumes Dai is used as the streamToken (sjkelleyjr) . | Proof of concept | Impact | Recommendation | Remediation Status | . | 3. Missing calls in scripts/deployAll.js (engn33r) . | Proof of concept | Impact | Recommendation | Remediation Status | . | . | Final remarks . | sjkelleyjr | engn33r | NibblerExpress | . | About yAcademy | Appendix and FAQ | . ",
    "url": "/reports/03-2022-Ohm/#table-of-contents",
    "relUrl": "/reports/03-2022-Ohm/#table-of-contents"
  },"2": {
    "doc": "03-2022-Ohm",
    "title": "Review Summary",
    "content": "Tyche/OlympusGive . The purpose of Tyche/OlympusGive is to empower Ohm/sOHM/gOHM holders to use their OHM yield in different ways. This family of contracts aims to allow users to donate their yield to multiple users. The YieldStreamer contract allows sOHM or gOHM deposits, and the yield can be withdrawn in the form of a stream token (Dai is the default). In contract, the YieldDirector contract permits gOHM deposits and the gOHM rebases can be donated. The main branch of the OlympusDAO Repo was reviewed over 9 days, 3 of which were used to create an intial overview of the contract. The code review was performed between March 20 and March 28, 2022. The code was reviewed by 3 residents for a total of 43 hours (Sjkelleyjr: 17 hours, Engn33r: 16 hours, and NibblerExpress: 10 hours) man hours. The repository was under active development during the review, but the review was limited to one specific commit. ",
    "url": "/reports/03-2022-Ohm/#review-summary",
    "relUrl": "/reports/03-2022-Ohm/#review-summary"
  },"3": {
    "doc": "03-2022-Ohm",
    "title": "Scope",
    "content": "Code Repo Commit . The review was limited to the three following contracts: . | YieldSplitter.sol | YieldDirector.sol | YieldStreamer.sol | . The focal point of the review was the following code modifications: . | https://github.com/OlympusDAO/olympus-contracts/pull/208 | https://github.com/OlympusDAO/olympus-contracts/pull/186 | https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/types/YieldSplitter.sol | . The commit reviewed was f92425ff278b93cfc2a580299924417182da432a . After the findings were presented to the Ohm team, a review of mitigations was performed during April 5-9 based on the first three commit ot PR 288: https://github.com/OlympusDAO/olympus-contracts/pull/288 . The review was a time-limited review to provide rapid feedback on potential vulnerabilities. The review was not a full audit. The review did not explore all potential attack vectors or areas of vulnerability and may not have identified all potential issues. yAcademy and the residents make no warranties regarding the security of the code and do not warrant that the code is free from defects. yAcademy and the residents do not represent nor imply to third parties that the code has been audited nor that the code is free from defects. Olympus and third parties should use the code at their own risk. ",
    "url": "/reports/03-2022-Ohm/#scope",
    "relUrl": "/reports/03-2022-Ohm/#scope"
  },"4": {
    "doc": "03-2022-Ohm",
    "title": "Code Evaluation Matrix",
    "content": "| Category | Mark | Description | . | Access Control | Good | Modifiers such as onlyGovernor and isInvalidDeposit control conditional logic branches, while elsewhere if statements check whether the msg.sender is the depositor or recipient. Access controls are applied where needed. | . | Mathematics | Good | Solidity 0.8.10 is used, which provides overflow and underflow protect. No unchecked code exists and no low-level bitwise operations are performed. | . | Complexity | Good | No assembly is used and the code is clearly written and organized. | . | Libraries | Good | The libraries used are from trustworthy sources. No external libraries from outside the project repository are imported. | . | Decentralization | Average | The onlyGovernor modifier implies some level of centralization, although a multisig is expected to mitigate this. | . | Code stability | Average | Changes were reviewed at a specific commit, additional code development occurred, but the scope was not expanded after the review was started. However, development was ongoing when the review was performed so the code was not frozen, which means deployed code may vary from what was reviewed. | . | Documentation | Average | Documentation for the project exists and the code had natspec comments for nearly all functions. However, no documentation existed in the official Olympus DAO GitBook documentation and some NatSpec documentation could be made clearer with standardized terminology across contracts. | . | Monitoring | Average | Events were added to most important functions that modified state variables, but not the yield withdraw or variable update functions in YieldStreamer. | . | Testing and verification | Low | The findings indicate that the test coverage could be improved to better handle edge cases. Improved unit tests could enhance consistency and better check the value of all state variables after operations are performed. | . ",
    "url": "/reports/03-2022-Ohm/#code-evaluation-matrix",
    "relUrl": "/reports/03-2022-Ohm/#code-evaluation-matrix"
  },"5": {
    "doc": "03-2022-Ohm",
    "title": "Findings Explanation",
    "content": "Findings are broken down into sections by their respective impact: . | Critical, High, Medium, Low impact . | These are findings that range from attacks that may cause loss of funds, impact control/ownership of the contracts, or cause any unintended consequences/actions that are outside the scope of the requirements | . | Gas savings . | Findings that can improve the gas efficiency of the contracts | . | Informational . | Findings including recommendations and best practices | . | . ",
    "url": "/reports/03-2022-Ohm/#findings-explanation",
    "relUrl": "/reports/03-2022-Ohm/#findings-explanation"
  },"6": {
    "doc": "03-2022-Ohm",
    "title": "High Findings",
    "content": "1. staking.unstake() should set rebasing bool to true (engn33r) . The YieldStreamer contract passes an incorrect parameter to staking.unstake(). Proof of concept . The steps that the YieldStreamer functions take to withdraw yield to stream tokens occur in this order . | Calculate yield in gOHM | Unwrap gOHM to sOHM | Unstake sOHM to OHM | Convert OHM to stream token | . The problem is in step 3. The rebasing bool is set to false, which will cause the staking contract to take gOHM from msg.sender instead of taking sOHM as the YieldStreamer contract requires. The logic for the rebasing boolean in the staking contract is . if (_rebasing) { sOHM.safeTransferFrom(msg.sender, address(this), _amount); amount_ = amount_.add(bounty); } else { gOHM.burn(msg.sender, _amount); // amount was given in gOHM terms amount_ = gOHM.balanceFrom(amount_).add(bounty); // convert amount to OHM terms &amp; add bounty } . In order to convert sOHM to OHM in the staking.unstake() function, which is required in step 3 of the steps outlined above, the rebasing parameter must be set to true. Otherwise gOHM will be converted instead. https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/Staking.sol#L181 . Currently the rebasing boolean value is set to false in two locations https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L246 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L322 . Impact . High, currently gOHM will be subtracted from the YieldStreamer contract twice while sOHM will sit in YieldStreamer unused. Recommendation . Change the rebasing input parameter to true, not false . staking.unstake(address(this), totalOhmToSwap, false, true); . Remediation Status . The functions relying on staking.unstake() have been changed so that this is no longer an issue. Notably, the complex withdrawYieldInStreamTokens() function has been removed. A new observation was that comments still exist in YieldStreamer.sol that reference withdrawYieldInStreamTokens even though the function has been removed. Only one instance of the staking.unstake() function call remains, in the upkeep() function, where the token conversion process has been simplified so that the original issue is no longer valid. 2. Sandwich attack risk in YieldStreamer.sol (engn33r) . YieldStreamer.sol needs to swap Ohm for the streaming token. To do this, the swapExactTokensForTokens function from Sushiswap is used. The swapExactTokensForTokens requires a amountOutMin value be set to reduce slippage and prevent sandwich attacks. In the YieldStreamer.sol contract, the amountOutMin value that is set is equivalent to not setting a minimum amountOutMin. This make the swap sandwichable. Even if a private relay like flashbots is used to mitigate the sandwich attack risk, an uncle bandit attack is still a risk to this operation. Proof of concept . This code is how the swap is performed in YieldStreamer.sol in two locations: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L248-L255 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L324-L331 . uint256[] memory calculatedAmounts = sushiRouter.getAmountsOut(totalOhmToSwap, sushiRouterPath); uint256[] memory amounts = sushiRouter.swapExactTokensForTokens( totalOhmToSwap, (calculatedAmounts[1] * (1000000 - maxSwapSlippagePercent)) / 1000000, sushiRouterPath, msg.sender, block.timestamp ); . The amountOutMin value is the output of getAmountsOut(totalOhmToSwap, sushiRouterPath) minus some slippage percent maxSwapSlippagePercent. Examining the code of the swapExactTokensForTokens() function, we can see how amountOutMin is used. There is a check to confirm the result of the exchange is greater than the amountOutMin https://github.com/sushiswap/sushiswap/blob/56cedd0e06a6cf665083b3a662f9f77b80303ebe/contracts/uniswapv2/UniswapV2Router02.sol#L233 . amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] &gt;= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'); . But because the swapExactTokensForTokens() function is using the exact same getAmountsOut() function that was used in YieldStreamer.sol to calculate amountOutMin and is calculated in the same transaction, the result is that the two getAmountsOut() output values will always be equal. So the amountOutMin set in YieldStreamer.sol serves no purpose because it can never yield a result where the amountOutMin value reverts the swap, because amountOutMin is getAmountsOut() minus some slippage, which will always be less than or equal to getAmountsOut(). The current calculation to provide an amountOutMin value is a waste of gas. Even in a scenario where a private relay is used, miners cannot guarantee that a block will not become an uncle block. If the block is uncled, the mempool data becomes public and an uncle bandit attack is possible. Impact . High, sandwich attack is expected if the liquidity pool has low liquidity relative to a flash loan or whale . Recommendation . A comment in the PR discussing the sandwich attack risk indicates that a private relay may be necessary https://github.com/OlympusDAO/olympus-contracts/pull/186#discussion_r789334631 . If no private relay is used, an external oracle should be used instead of relying on the DEX liquidity pool spot price. Chainlink has several OHM price feeds. https://shouldiusespotpriceasmyoracle.com/ . An additional improvement for the withdrawYieldInStreamTokens() function is to add a user-specified minAmountOut input parameter. Because a check exists in withdrawYieldInStreamTokens() requiring recipientInfo[id_].recipientAddress == msg.sender, the function caller is the intended recipient and therefore can be trusted to set a slippage value of their choice. To make this even easier for a user, a view function can be created that calculates this input amount to pass as the minAmountOut input parameter. This improvement would not work for upkeep() because it can be called by anyone and the caller cannot be trusted to set a safe slippage value. Remediation Status . This issue has not been remediated at the time of report completion. An additional concern was added about the possibility of swaps that happen earlier in the activeDepositIds array receiving better swap rates than those later in the array. ",
    "url": "/reports/03-2022-Ohm/#high-findings",
    "relUrl": "/reports/03-2022-Ohm/#high-findings"
  },"7": {
    "doc": "03-2022-Ohm",
    "title": "Medium Findings",
    "content": "1. Denial of service in upkeep “for” loop in YieldStreamer.sol (sjkelleyjr) . If upkeep() is not run frequently enough, or if the upkeep eligibility of many depositors synchronize, the two for loops in the upkeep() function may run out of gas, preventing anyone from running this function until (or if) Ethereum mainnet gas limits are increased. There is no backup function in YieldStreamer.sol that allows for upkeep to be run on individual positions, which would provide a solution if it is not possible to upkeep all eligible positions. This function can be attacked by a user who wants to perform a denial of service. A user can create many deposits with a paymentInterval of 1 second. All of these payments will be upkeep eligible, increasing the amount of gas that the upkeep caller must spend. This attack can bring the gas usage of upkeep() over the current 30,000,000 mainnet gas limit. The upkeep function is a critical piece of YieldStreamer.sol, and if it is unavailable the contract will cease to be useful, requiring individuals to withdraw their assets and the Ohm team to redeploy an upgraded contract without this weakness. Proof of concept . Based on the current gas limit of 30 million, a malicious user Mallory could cause this denial of service with a few thousand deposits . | Mallory calls deposit() in YieldStreamer.sol a few thousand times with small deposits that are equal to or greater than the value of minimumTokenThreshold. This causes the length of activeDepositIds to increase. When making these deposits, Mallory sets the paymentInterval to a very short amount of time and the userMinimumAmountThreshold to a very small value. | Mallory, or any user, will call upkeep() at a later time. Because _isUpkeepEligible(currentId) will return true for all of Mallory’s deposits, which number in the thousands, the upkeep() function will revert when it runs out of gas. The upkeep() function will be unusable, meaning users will not receive their stream tokens on schedule. All users will need to withdraw their deposits to receive the stream tokens. | . Impact . Medium, contract out of gas causing denial of service . Recommendation . Add a function to upkeep individual deposits instead of only maintaining a single function to upkeep all deposits. Remediation Status . This issue has not been remediated at the time of report completion. One recommendation for the upkeep() denial of service was to add a function to upkeep individual deposits, but if the redeemYieldOnBehalfOf() function is intended to serve this purpose, it needs to add the line currentrecipientInfo.lastUpkeepTimestamp = uint128(block.timestamp); so that this deposit is not looped through on the next upkeep() call. ",
    "url": "/reports/03-2022-Ohm/#medium-findings",
    "relUrl": "/reports/03-2022-Ohm/#medium-findings"
  },"8": {
    "doc": "03-2022-Ohm",
    "title": "Low Findings",
    "content": "1. donatedTo and depositsTo only return the first of N possible donation or deposit mappings (sjkelleyjr) . There can be multiple depositInfo mappings for a given donor or multiple recipientLookup mappings for a given donor to recipient. Proof of concept . https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldDirector.sol#L195 . https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldDirector.sol#L256 . Impact . Low, the view functions may return incorrect values. Recommendation . Return a sum of the total mappings as is done in the other view functions, or ensure the same mapping between donor and recipient can only be created one time when deposit is called. Remediation Status . This finding was successfully resolved using the provided recommendation. 2. _redeemAll() does not delete recipientLookup (sjkelleyjr) . In YieldDirector.sol, the two mappings recipientIds and recipientLookup allow for recipient -&gt; depositId and depositId -&gt; recipient lookups respectively. The two mappings must be modified at the same time and in the same way to maintain relevance. For example, in the _redeem() function, when the principalAmount of a deposit is zero, the function calls receiptIds.pop(); and delete recipientLookup[depositId_] to remove this depositId from the mappings. But in the related _redeemAll() function, there is no deletion of the recipientLookup[depositId_] value. This can result in the recipientLookup mapping storing unnecessary data. This is mostly a gas savings issue, but the extra data in the array may lead to an edge case logic error, though none was identified. Proof of concept . In the _redeem() function, receiptIds.pop(); and delete recipientLookup[depositId_] are called https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L429-L455 . But in the similar _redeemAll() function, there is no delete recipientLookup[depositId_]; call. https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L460-L488 . Impact . Low, the recipientLookup mapping will still contain depositId -&gt; recipient mappings even if this is zero principal, but no direct security vulnerability from this data was found. Recommendation . Modify the line of code that calls receiptIds.pop(); in _redeemAll() to the following: . delete recipientLookup[receiptIds[index - 1]]; receiptIds.pop(); . Remediation Status . This finding was successfully resolved using the provided recommendation. ",
    "url": "/reports/03-2022-Ohm/#low-findings",
    "relUrl": "/reports/03-2022-Ohm/#low-findings"
  },"9": {
    "doc": "03-2022-Ohm",
    "title": "Gas Savings Findings",
    "content": "1. Declare function external for gas savings (sjkelleyjr) . The totalRedeemableBalance function of YieldDirector.sol should be declared external, not public, for gas savings. Proof of concept . https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L315 . Impact . Gas savings . Recommendation . Declare totalRedeemableBalance as an external function, not a public function . Remediation Status . This finding was successfully resolved using the provided recommendation. 2. Use == for gas savings (sjkelleyjr) . The three modifiers of YieldDirector.sol use a check for amount &lt;= 0, but the check can be changed to amount == 0 for gas savings. There’s another related gas optimization. the if/else statement in the _withdraw() function of YieldDirector.sol can replace ≥ with &lt; if the if/else clauses are switched around. The same gas optimization can be used in the if/else statement of the withdrawPrincipal() function in YieldStreamer.sol. Proof of concept . &lt;= is used instead of == in three modifiers https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L71-L81 . &gt;= can be simplified to &lt; by flipping the if/else clauses in two locations https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L415 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L163 . An example of flipping the if/else clauses is shown. Here is the original code: . if (amount_ &gt;= _toAgnostic(depositInfo[depositId_].principalAmount)) { amountWithdrawn = _withdrawAllPrincipal(depositId_, msg.sender); } else { _withdrawPrincipal(depositId_, amount_, msg.sender); amountWithdrawn = amount_; } . And here is the modified code with a minor gas savings. This specific gas savings may be negated if the _withdrawAllPrincipal clause is used most of the time: . if (amount_ &lt; _toAgnostic(depositInfo[depositId_].principalAmount)) { _withdrawPrincipal(depositId_, amount_, msg.sender); amountWithdrawn = amount_; } else { amountWithdrawn = _withdrawAllPrincipal(depositId_, msg.sender); } . Impact . Gas savings . Recommendation . Use ==, &lt;, or &gt; instead of ≤ or ≥ whenever possible for gas savings . Remediation Status . This finding was successfully resolved using the provided recommendation. 3. Simplify math for gas savings (engn33r) . Line 128 and 129 of YieldSplitter.sol reads . amountRedeemed = _getOutstandingYield(userDeposit.principalAmount, userDeposit.agnosticAmount); userDeposit.agnosticAmount = _toAgnostic(userDeposit.principalAmount); . Instead of calling _toAgnostic(), this can be simplified to save gas with . amountRedeemed = _getOutstandingYield(userDeposit.principalAmount, userDeposit.agnosticAmount); userDeposit.agnosticAmount = userDeposit.agnosticAmount - amountRedeemed; . Proof of concept . https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L129 . Impact . Gas savings . Recommendation . Simplify math for gas savings . Remediation Status . This finding was successfully resolved using the provided recommendation. 4. Use msg.sender for gas savings (engn33r) . NOTE: engn33r is unsure whether this is a gas savings, but Paul thinks it is: https://github.com/OlympusDAO/olympus-contracts/pull/186#discussion_r816492541 . The emit call in the _increaseDeposit() function of YieldDirector.sol should use msg.sender instead of depositInfo[depositId_].depositor. _addToDeposit() is called in _increaseDeposit(), and _addToDeposit() performs a check to confirm depositInfo[id_].depositor == msg.sender. This is already done in the _withdraw() function of YieldDirector.sol. Proof of concept . https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L404 . Impact . Gas savings . Recommendation . Use msg.sender for gas savings . Remediation Status . This finding was successfully resolved using the provided recommendation. 5. Remove functions to save gas on deployment (engn33r) . The _toAgnostic() and _fromAgnostic() functions of YieldSplitter.sol duplicate the balanceFrom() and balanceTo() of gOHM.sol. Since the gOHM address is known to YieldStreamer.sol and YieldDirector.sol, the _toAgnostic() and _fromAgnostic() functions could be remove to reuse the gOHM functions. This is already done in withdrawPrincipal() of YieldStreamer.sol https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L163 Compare to the equivalent line in YieldDirector.sol https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L415 . A similar function named getPrincipalInGOHM() in YieldStreamer.sol acts as a wrapper for gOHM.balanceTo(). It is unclear whether this function is necessary of if it can be removed. If it is necessary, it may be useful to add a complementary function getAgnosticInSOHM(). Less new code = lower complexity + deployment gas savings . Proof of concept . balanceTo and balanceFrom in gOHM.sol convert between sOHM and gOHM using the current index exchange rate https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/governance/gOHM.sol#L111-L127 . The YieldSplitter.sol functions _fromAgnostic and _toAgnostic duplicate this functionality https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L170-L186 . Impact . Gas savings . Recommendation . Use existing functions instead of duplicating them . Remediation Status . This finding was acknowledged but not resolved, because there may be cases where the _toAgnostic() and _fromAgnostic() functions are useful in contracts that do not import the gOHM.sol contract. Gas findings are optional and do not pose a security concern. 6. Gas savings using unchecked (engn33r) . We know agnosticAmount &gt;= _toAgnostic(principal) because agnosticAmount includes some yield from rebasing. This assumption can allow some math to use the “unchecked” clause for gas savings. One such place is _getOutstandingYield of YieldSplitter.sol. Proof of concept . https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L167 . Impact . Gas savings . Recommendation . Use unchecked where there is no overflow or underflow risk . Remediation Status . This finding was successfully resolved using the provided recommendation. It was suggested that comments explaining why each unchecked cannot overflow or undeflow may be useful documentation. 7. Gas savings with memory variable (engn33r) . Instead of looking up a state variable twice, a gas savings can be achieved by creating a local copy. This optimization was found in two locations. Proof of concept . The _closeDeposit() function in YieldSplitter.sol uses the value “depositInfo[id_].depositor” twice https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L144 . The _redeemAll() in YieldDirector.sol function uses the value “depositInfo[receiptIds[index - 1]].depositor” twice https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L460 . Impact . Gas savings . Recommendation . Store the value in a local memory variable to save gas on storage loads. Here is an example: . address depositorAddressToClose = depositInfo[id_].depositor; if (depositorAddressToClose != depositorAddress) revert YieldSplitter_NotYourDeposit(); . Remediation Status . This finding was successfully resolved using the provided recommendation. 8. redeemAll repeatedly computes index - 1 (NibblerExpress) . index - 1 is computed six times in the redeemAll function. Gas could be saved by computing it once and storing in memory. Proof of Concept . See lines 471-480 of Yield Director: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L471 . Impact . Gas savings . Recommendation . One option is to compute and store index - 1 and use that value rather than recomputing index - 1 repeatedly. The alternate option would be to start the loop at length - 1 and check that index &gt;= 0. Remediation Status . This finding was successfully resolved using the provided recommendation. ",
    "url": "/reports/03-2022-Ohm/#gas-savings-findings",
    "relUrl": "/reports/03-2022-Ohm/#gas-savings-findings"
  },"10": {
    "doc": "03-2022-Ohm",
    "title": "Informational Findings",
    "content": "1. Miscellaneous Improvement Ideas (engn33r) . There is significant overlap between YieldDirector.sol and YieldStreamer.sol, but similar functions are implemented differently. Standardizing as much as possible would be ideal for the long term management of the code. Seperately, constant variables should be used in place of magic numbers to prevent typos. The magic number 1e6 is found in multiple places in YieldStreamer.sol and should be replaced with a constant. Proof of concept . Examples of overlap between YieldDirector.sol and YieldStreamer.sol include: . | YieldDirector.sol has modifiers isInvalidDeposit, isInvalidUpdate, and isInvalidWithdrawal, but YieldStreamer.sol only checks the boolean value depositDisabled, withdrawDisabled, or upkeepDisabled. YieldStreamer.sol may benefit from the same modifiers used in YieldDirector.sol. | Functions like desposit() and addToDeposit() perform almost identical actions but have different names for input parameters and different natspec comments. These could be standardized better across the two contracts. | . Examples of magic numbers that should be converted to constant variables are found in several places: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L436 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L445 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L251 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L318 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L327 . Impact . Informational . Recommendation . | Reuse code as much as possible between YieldDirector.sol and YieldStreamer.sol to reduce overall complexity | Replace magic numbers with constant variables to prevent typos in numeric calculations | . Remediation Status . This finding was successfully resolved using the provided recommendation. 2. updateUserMinDaiThreshold assumes Dai is used as the streamToken (sjkelleyjr) . Proof of concept . https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldStreamer.sol#L280 . Impact . None, readability improvement. Recommendation . Rename the function to updateUserMinStreamTokenThreshold. Remediation Status . This finding was successfully resolved using the provided recommendation. 3. Missing calls in scripts/deployAll.js (engn33r) . The deployAll.js script currently fails because the timelock is disabled, which leads to the calls to olympusTreasury.queueTimelock() failing. The deployAll.js script is missing calls to deploy YieldStreamer.sol and YieldSplitter.sol. Proof of concept . Start ganache and run npx hardhat run --network localhost scripts/deployAll.js . Observe the error message stating revert Timelock is disabled, use enable. To fix, add the line await olympusTreasury.initialize(); before the calls to olympusTreasury.queueTimelock() and observe the above hardhat work. Impact . Informational . Recommendation . Update the deployAll.js script . Remediation Status . This finding was not resolved at the time of report completion, but does not pose any security concerns. ",
    "url": "/reports/03-2022-Ohm/#informational-findings",
    "relUrl": "/reports/03-2022-Ohm/#informational-findings"
  },"11": {
    "doc": "03-2022-Ohm",
    "title": "Final remarks",
    "content": "sjkelleyjr . In general the code doesn’t appear to contain any critical vulnerabilities that would result in the loss of user funds. My primary concern is around the high gas usage of the upkeep function and the easy with which a nefarious user could DDOS this function. engn33r . Overall the code looks quite solid. I was expecting to see a mixup between gOHM and sOHM conversion somewhere, but the math appears to be handled properly. The gas usage of the upkeep function, where one user pays for the gas of many user’s deposits, could be problematic because the user calling upkeep cannot control these other deposits. Additionally, there is one comment that streamToken may include tokens other than Dai. The code currently may not handle all edge cases for deflationary or fee-on-transfer stream tokens, which could lead to problems if they are allowed as streamTokens. NibblerExpress . I spent a bunch of my time running through the deposit and withdraw logic looking for attacks and manipulations, but I did not find much there. The code appeared to be well written with the vulnerabilities tending to show up in the interactions with other Olympus/Ohm contracts or external contracts. A more methodical approach to testing with a focus on ensuring that all states are correct after external interactions would be helpful. ",
    "url": "/reports/03-2022-Ohm/#final-remarks",
    "relUrl": "/reports/03-2022-Ohm/#final-remarks"
  },"12": {
    "doc": "03-2022-Ohm",
    "title": "About yAcademy",
    "content": "yAcademy is an ecosystem initiative started by Yearn Finance and its ecosystem partners to bootstrap sustainable and collaborative blockchain security reviews and to nurture aspiring security talent. yAcademy includes a fellowship program and a residents program. In the fellowship program, fellows perform a series of periodic security reviews and presentations during the program. Residents are past fellows who continue to gain experience by performing security reviews of contracts submitted to yAcademy for review (such as this contract). ",
    "url": "/reports/03-2022-Ohm/#about-yacademy",
    "relUrl": "/reports/03-2022-Ohm/#about-yacademy"
  },"13": {
    "doc": "03-2022-Ohm",
    "title": "Appendix and FAQ",
    "content": " ",
    "url": "/reports/03-2022-Ohm/#appendix-and-faq",
    "relUrl": "/reports/03-2022-Ohm/#appendix-and-faq"
  },"14": {
    "doc": "03-2022-Ohm",
    "title": "03-2022-Ohm",
    "content": " ",
    "url": "/reports/03-2022-Ohm/",
    "relUrl": "/reports/03-2022-Ohm/"
  },"15": {
    "doc": "04-2022-Ohm-Bond",
    "title": "yAcademy Olympus Bond review",
    "content": "Review Resources: Support Doc Olympus bond pricing mechanics Olympus bond simulator . Residents: . | Engn33r | . ",
    "url": "/reports/04-2022-Ohm-Bond/#yacademy-olympus-bond-review",
    "relUrl": "/reports/04-2022-Ohm-Bond/#yacademy-olympus-bond-review"
  },"16": {
    "doc": "04-2022-Ohm-Bond",
    "title": "Table of Contents",
    "content": ". | Review Summary | Scope | Code Evaluation Matrix | Findings Explanation | High Findings | Medium Findings . | 1. Medium - Callback customization allows arbitrary contract execution (engn33r) . | Proof of Concept | Impact | Recommendation | Developer Response | . | 2. Medium - Missing logical protections in setIntervals() (engn33r) . | Proof of Concept | Impact | Recommendation | Developer Response | . | 3. Medium - BCV decrease design does not give market owner optimal price (engn33r) . | Proof of Concept | Impact | Recommendation | Developer Response | . | 4. Medium - totalDebt value overwritten (engn33r) . | Proof of Concept | Impact | Recommendation | Developer Response | . | . | Low Findings . | 1. Low - Values grow quickly near end of market (engn33r) . | Proof of Concept | Impact | Recommendation | Developer Response | . | 2. Low - Inaccurate assumption about scaleAdjustment (engn33r) . | Proof of Concept | Impact | Recommendation | Developer Response | . | 3. Low - Anyone can trigger a market closure (engn33r) . | Proof of Concept | Impact | Recommendation | Developer Response | . | 4. Low - Missing zero case checks (engn33r) . | Proof of Concept | Impact | Recommendation | Developer Response | . | 5. Low - Incompatible with fee-on-transfer tokens (engn33r) . | Proof of Concept | Impact | Recommendation | Developer Response | . | . | Gas Savings Findings . | 1. Gas - Use != 0 for gas savings (engn33r) . | Proof of Concept | Impact | Recommendation | . | 2. Gas - Unnecessary zero initialization (engn33r) . | Proof of Concept | Impact | Recommendation | . | 3. Gas - Use prefix in loops (engn33r) . | Proof of concept | Impact | Recommendation | . | 4. Gas - Cache array length before loop (engn33r) . | Proof of Concept | Impact | Recommendation | . | 5. Gas - Bitshift is cheaper for powers of two (engn33r) . | Proof of Concept | Impact | Recommendation | . | 6. Gas - Remove unused functions from imported libraries (engn33r) . | Proof of Concept | Impact | Recommendation | . | 7. Gas - Remove unused variable (engn33r) . | Proof of Concept | Impact | Recommendation | . | 8. Gas - Cache variable for reuse (engn33r) . | Proof of Concept | Impact | Recommendation | . | 9. Gas - Tidy up _handlePayout logic (engn33r) . | Proof of Concept | Impact | Recommendation | . | 10. Gas - Redundant return variable (engn33r) . | Proof of Concept | Impact | Recommendation | . | 11. Gas - Use unchecked when no risk of overflow or underflow (engn33r) . | Proof of Concept | Impact | Recommendation | . | 12. Gas - Move variable assignment to avoid overwrite (engn33r) . | Proof of Concept | Impact | Recommendation | . | 13. Gas - Using simple comparison (engn33r) . | Proof of concept | Impact | Recommendation | . | . | Informational Findings . | 1. Informational - Bond purchase size does not impact price (engn33r) . | Proof of Concept | Impact | Recommendation | . | 2. Informational - Frontrunning changes price (engn33r) . | Proof of Concept | Impact | Recommendation | . | 3. Informational - Unclear if default tuning parameters are optimal (engn33r) . | Proof of Concept | Impact | Recommendation | . | 4. Informational - Add a check to limit debtBuffer to 100% (engn33r) . | Proof of Concept | Impact | Recommendation | . | 5. Informational - Function format inconsistency (engn33r) . | Proof of Concept | Impact | Recommendation | . | 6. Informational - Variable name nitpick (engn33r) . | Proof of Concept | Impact | Recommendation | . | 7. Informational - TransferHelper.sol not from solmate (engn33r) . | Proof of Concept | Impact | Recommendation | . | 8. Informational - CloneERC20.sol missing EIP-2612 code (engn33r) . | Proof of Concept | Impact | Recommendation | . | 9. Informational - Incorrect comment (engn33r) . | Proof of Concept | Impact | Recommendation | . | 10. Informational - Confusing variable naming (engn33r) . | Proof of Concept | Impact | Recommendation | . | 11. Informational - Expired markets are never “closed” (engn33r) . | Proof of Concept | Impact | Recommendation | . | 12. Informational - Legitimate tokens disallowed (engn33r) . | Proof of Concept | Impact | Recommendation | . | 13. Informational - Tokens with non-string metadata disallowed (engn33r) . | Proof of Concept | Impact | Recommendation | . | 14. Informational - vesting and expiry sometimes used interchangeably (engn33r) . | Proof of Concept | Impact | Recommendation | . | 15. Informational - market price functions consistency (engn33r) . | Proof of Concept | Impact | Recommendation | . | 16. Informational - Use variable instead of magic numbers (engn33r) . | Proof of Concept | Impact | Recommendation | . | . | Final remarks . | engn33r | . | About yAcademy | Appendix and FAQ | . ",
    "url": "/reports/04-2022-Ohm-Bond/#table-of-contents",
    "relUrl": "/reports/04-2022-Ohm-Bond/#table-of-contents"
  },"17": {
    "doc": "04-2022-Ohm-Bond",
    "title": "Review Summary",
    "content": "Olympus Bond . The purpose of Olympus Bond is to provide a permissionless system for creating Olympus-style bond markets for any token pair. No maintenance or whitelisting will be necessary to create a new market for a base-quote token pair. The Olympus-style bonding mechanism provides numerous benefits to projects compared to standard token emissions. The Olympus Bond code includes several changes compared to the existing Olympus Pro bond system. The most notable difference is the permissionless nature of the Bond system and extensibility that will allow the contract architecture to adapt as necessary over time. Some of the core pricing mechanics of Olympus Bond are borrowed from existing Olympus contracts such as BondDepository.sol. The main branch of the Olympus Bonds Repo was reviewed over 18 days, 3 of which were used to create an initial overview of the contract. The code review was performed between April 19 and May 7, 2022. The code was reviewed by 1 resident for a total of 43 man hours (Engn33r: 43 hours). The review was limited to one specific commit. ",
    "url": "/reports/04-2022-Ohm-Bond/#review-summary",
    "relUrl": "/reports/04-2022-Ohm-Bond/#review-summary"
  },"18": {
    "doc": "04-2022-Ohm-Bond",
    "title": "Scope",
    "content": "Code Repo Commit . The commit reviewed was 1550298fe9618e861201787cd7fc2648566cf6af of the OlympusDAO bonds repository. The review covered the entire repository at this specific commit but focused on the contract code in the /src directory. After the findings were presented to the Olympus Bond team, fixes were made and included in a separate audit-changes branch, with the latest commit hash of 146e2ef6a49d5ea43be32e95aed29609d6bd2290. Comments on the fixes were provided by the development team, but a new security review was not performed on the revised code (e.g., to determine examine the mitigations or determine whether new vulnerabilities were introduced by the mitigations). The review is a code review to identify potential vulnerabilities in the code. The reviewers did not investigate security practices or operational security and assumed that privileged accounts could be trusted. The reviewers did not evaluate the security of the code relative to a standard or specification. The review may not have identified all potential attack vectors or areas of vulnerability. yAcademy and the residents make no warranties regarding the security of the code and do not warrant that the code is free from defects. yAcademy and the residents do not represent nor imply to third party users that the code has been audited nor that the code is free from defects. By deploying or using the code, Olympus DAO and and users agree to use the code at their own risk. ",
    "url": "/reports/04-2022-Ohm-Bond/#scope",
    "relUrl": "/reports/04-2022-Ohm-Bond/#scope"
  },"19": {
    "doc": "04-2022-Ohm-Bond",
    "title": "Code Evaluation Matrix",
    "content": "| Category | Mark | Description | . | Access Control | Average | While modifiers were applied to functions that needed them, this was one part of the codebase that was incomplete. The access control modifiers are planned to be changed before production and the specific modifiers used during the review were placeholders for where the updated modifiers will go. | . | Mathematics | Average | Solidity 0.8.10 is used, which provides overflow and underflow protection. The few locations with unchecked code were not at risk of overflows or underflows. | . | Complexity | Average | No assembly was used (excluding imported libraries) and the code architecture is well designed. The code is clearly written with well-chosen variable names and good NatSpec documentation is found throughout. The most complex part of the code is the pricing mechanics, which are fully internal to Bond (no oracles or TWAPs), but which includes many variables that all feed into a final price calculation. | . | Libraries | Average | The libraries used are from trustworthy sources. While the solmate libraries use lower level solidity features for gas savings, they are widely used and considered a safe option. | . | Decentralization | Average | Because the access controls will be changed before production, it is hard to judge what roles have what levels of access. However, the Ohm Bond system is designed in a way to allow anyone to create a market and manage it as the market owner, providing significant decentralization. | . | Code stability | Good | The code was frozen when the review started and was close to production ready, with the exception of the access control modifiers. The scope that was set at the start of the code review did not change after the review started. | . | Documentation | Good | Documentation for the project exists and the code had NatSpec comments for nearly all functions. The documentation was spread between a PDF document and a blog post, so centralizing this information into a single source would be a good step before production, but there is already a good amount of documentation available. | . | Monitoring | Average | Events are emitted in the important functions that modify state variables. It is unclear if additional monitoring of market health or anomalous market behavior will exist because the simulator demonstrates some minor quirks in the pricing mechanics in some cases. | . | Testing and verification | Average | Calculating the exact test coverage with the foundry framework is still a work in progress at the time this review was performed. The GitHub repo has continuous integration (CI) that runs forge test and linting. The test coverage looks quite good and the existence of a price simulator shows effort has been put into testing the core mechanics of the protocol. | . ",
    "url": "/reports/04-2022-Ohm-Bond/#code-evaluation-matrix",
    "relUrl": "/reports/04-2022-Ohm-Bond/#code-evaluation-matrix"
  },"20": {
    "doc": "04-2022-Ohm-Bond",
    "title": "Findings Explanation",
    "content": "Findings are broken down into sections by their respective impact: . | Critical, High, Medium, Low impact . | These are findings that range from attacks that may cause loss of funds, impact control/ownership of the contracts, or cause any unintended consequences/actions that are outside the scope of the requirements | . | Gas savings . | Findings that can improve the gas efficiency of the contracts | . | Informational . | Findings including recommendations and best practices | . | . ",
    "url": "/reports/04-2022-Ohm-Bond/#findings-explanation",
    "relUrl": "/reports/04-2022-Ohm-Bond/#findings-explanation"
  },"21": {
    "doc": "04-2022-Ohm-Bond",
    "title": "High Findings",
    "content": "None. ",
    "url": "/reports/04-2022-Ohm-Bond/#high-findings",
    "relUrl": "/reports/04-2022-Ohm-Bond/#high-findings"
  },"22": {
    "doc": "04-2022-Ohm-Bond",
    "title": "Medium Findings",
    "content": "1. Medium - Callback customization allows arbitrary contract execution (engn33r) . The description of the callback function in the Bond documentation is “Callbacks allow issuers (market creators) to apply custom logic on receipt and payout of tokens.” Allowing users to create their own markets with custom logic is a security problem waiting to happen. This can lead to users executing arbitrary contracts that are labeled with the Olympus Bond brands, leading to any number of non-ideal situations. Proof of Concept . A malicious Olympus Bond market could be created with the following: . | A market is created by Mallory by calling createMarket() in BondFixedTermCDA.sol or BondFixedExpCDA.sol, which in turn calls _createMarket() in BondBaseCDA.sol. This market can be customized so that it a) uses a common bond/quote pair (say ETH/OHM) that duplicates other high volume markets b) sets a custom callbackAddr is set to a contract that the market creator controls c) has the highest maxPayout value of this market type (necessary for step 2). Observe that the callbackAddr contract can store any code, and does not need to borrow from the BondBaseCallback.sol abstract contract at all. | Innocent user Bob calls findMarketFor() in BondAggregator.sol which is a function that Returns the market ID with the highest current baseToken payout for depositing quoteToken from the NatSpec documentation. Because of step 1c), the custom market created by Mallory is identified as the best market | Innocent user Bob is happy with the advertised rate returned by findMarketFor() in BondAggregator.sol and proceeds to call purchase() in BondBaseTeller.sol to buy from Mallory’s market, intending to purchase some ETH/OHM bonds. | When purchase() in BondBaseTeller.sol is called and a non-zero callback address exists, _handleTransfers() will call the callback contract’s callback() function using the line IBondCallback(callbackAddr).callback(id_, amount, totalPaid);. Mallory can place any code in this function, such as an approval to withdraw directly from Bob’s wallet (which would require Bob to perform a 2nd ETH/OHM bond purchase in order to exploit). | . A market creator can even use a benign callback contract to gain exposure and marketshare before switching out the callback contract for a malicious contract using this CREATE2 initialization trick or another contract upgrade mechanism. This could lead to what is considered a “trusted” market doing things such as: . | Temporarily (or permanently) reverting orders from specific buyers (blacklisting) | Temporarily (or permanently) allowing only specific buyers access to the market (whitelisting) | Using the callback to exploit some vulnerability in the Ohm Bond system. If the market owner is also the owner of an ERC20 token that is used in an Ohm Bond market, the owner may be able to manipulate the token supply in the callback in ways that harm buyers. | . The denial of service impact of this vector could be especially problematic if another protocol plugs in to the Olympus Bond system and require high uptime. If this other protocol uses findMarketFor() to choose the market with the best price, a duplicate market with a blacklisting callback could temporarily achieved this best price to interrupt the other protocol’s functionality. This may lead to attacks in protocols using Olympus Bond depending on the integration implementation. Impact . Medium, arbitrary code execution can have unexpected consequences. Recommendation . The issue is a combination of two unusual design choices: . | Multiple markets with the same bond pair can exist. AMMs like Uniswap don’t allow for multiple markets for the same token pair | Custom callbacks can be created for each market. This is similar to how ERC721, ERC777, and ERC1155 tokens can have callbacks, but these callbacks are often the source of reentrancy issues. | . Changing either of these two design choices could resolve this issue. Ideally all the logic and code itself for all of the Olympus Bonds system should be managed and written by Olympus rather than trusting market owners to write safe and benign callbacks. It should be clearly documented that any protocol plugging in to the Olympus Bond system should use a specific marketId and not use findMarketFor() to find the market with the best price in order to avoid interfacing with a malicious callback. Developer Response . Two versions of Auctioneer will be created. V1 will not allow use of a callback (set callbackAddr to address(0) in createMarket) and avoid the issue. V2 will allow providing a callback and be used internally (probably going to gate access to creating markets on it). The Tellers will still have the functionality to support both callback and non-callback enabled auctioneers. Mitigation introduced to audit-changes branch. 2. Medium - Missing logical protections in setIntervals() (engn33r) . The setIntervals() function provides a dangerous tool for manipulating markets. The default interval values provide reasonable safeguards against edge case conditions, but this function allows the market owner to remove those safeguards. The tuning parameters serve the purpose described in this detailed blogpost. When a tune will result in the BCV decreasing, it is applied incrementally over the Tuning Interval. This protects the protocol from a rapid drop in price that could create opportunities for bots to arbitrage at the expense of other users. By allowing these tuning values to be modified by the market owner, the same rapid price drops that should be protected against can be caused at will by the market owner in the event arbitrage opportunities exist. There is additional danger because multiple markets can hold the same asset pair, meaning a brand new market with a common asset pair may immediately receive user interactions if it has the best price determined by findMarketFor() in BondAggregator.sol. Although the minAmountOut_ value should protect against large amounts of slippage, large volume orders with 1-2% slippage can still create arbitrage opportunities. Proof of Concept . The setIntervals() function is found in BondBaseCDA.sol https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L261-L272 . Beyond the risks caused by arbitrary interval changes, whether by a market owner purposefully manipulating a market or a clueless market owner accidentally choosing bad interval values, there are multiple pieces of logic that exist elsewhere to control the interval variables, but these logical checks are absent from setIntervals(). The first missing piece of logic is that there are two assumptions when the debtDecayInterval value is set in _createMarket() . | debtDecayInterval &gt;= params_.depositInterval * 5 | debtDecayInterval &gt;= minDebtDecayInterval | . These two checks are not applied in setIntervals() where a new debtDecayInterval value can be set by the market owner. This allows a user to bypass the checks in place during market creation. A market with a very short debt decay interval could quickly drop to zero. A second piece of logic missing is described in the NatSpec comment for the function, tuneInterval should be greater than tuneAdjustmentDelay. There is no logic checking that tuneInterval &gt; tuneAdjustmentDelay. A third piece of logic found in _createMarket() but absent from setIntervals() is setting totalDebt (or targetDebt) to capacity.mulDiv(uint256(debtDecayInterval), uint256(secondsToConclusion));. Because debtDecayInterval may change, the totalDebt (or targetDebt) will also change if the original calculation still is valid. Impact . Medium, the market may be intentionally manipulated in unexpected ways because prior assumptions can be broken by the market owner. Recommendation . Because the NatSpec comment for this function states Changing the intervals could cause markets to behave in unexpected way, deleting this function would be the easiest solution if it is unclear whether the pros outweigh the cons for modifying intervals while a market exists. If the function is to remain, additional logic needs to be added to handle potentially invalid user inputs because the market owner may not be aware of all interval requirements in advance. Developer Response . While I agree that they can manipulate the market, the impact is limited to hurting the market owner’s own bonds. Rationale users will only buy at a discount and the market owner isn’t able to hurt anyone but themselves. I do agree with updating the function to check that tuneInterval &gt; tuneAdjustmentDelay, debtDecayInterval is within its expected bounds, and ensuring targetDebt is scaled correctly with the new debtDecayInterval. totalDebt does not need updating here. Mitigation introduced to audit-changes branch. 3. Medium - BCV decrease design does not give market owner optimal price (engn33r) . The bond price is determined by price = BCV * totalDebt. If either BCV or totalDebt drops quickly, the bond price can drop quickly. This will result in high ROI for the buyer, potentially at the cost of the seller losing value. In theory, the system should recognize when there is a low bond price and buying pressure and correct the price upwards. In actuality, the BCV does necessarily react this way and can continue decreasing, lowering the price further, when there is buying pressure. The evidence of these sudden changes is seen in the Ohm Bond simulator. Proof of Concept . First, let’s illustrate the issue with some pictures taken from the simulator. The totalDebt is seen to change linearly, with straight lines, because its increase is limited by maxPayout. The slopes for totalDebt are relatively smooth and regular, which means totalDebt should not suddenly decrease faster than the linear slope it normally has. However, BCV does not change in a similar linear fashion. When there has been no purchase in some time period, BCV can drop suddenly by, say, 10%. This means that BCV is more of a factor in determining sudden price changes. Observe the sudden changes in BCV from the simulator and how the BCV slope during these changes can be steeper than the totalDebt slope. The simulator shows evidence that the sudden BCV drop can correlate with a high ROI for the bond buyer, as the blue line peaking over 30% around time interval 215 shows. This is the same time interval that the BCV value plummets by around 10%. The important question is whether this price plummet is an artifact of the simulator or a problem with the Olympus price mechanics, and the answer requires close examination of the code of BondBaseCDA.sol. The BCV value can only decrease in one place, where is where the BCV value (state variable) is set to the BCV View value (function return value) https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L439 . When the BCV value is decreased, it is decreased by the decay value from the _controlDecay() function. The value of decay is either exactly adjustments[id_].change or adjustments[id_].change multiplied by the value secondsSince / adjustments[id_].timeToAdjusted, a ratio which is less than 1. https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L591-L593 . The first case, where decay = adjustments[id_].change occurs when active == false. But when decay &lt; adjustments[id_].change, active == true. When active == true, adjustments[id_].change will decrease by decay. https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L442 . The code continues to decrease the BCV on each purchase as long as adjustments[id_].active == true. This statement is only true when decay &lt; adjustments[id_].change. https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L590 . If secondsSince &gt;= info.timeToAdjusted, then BCV will stop decreasing https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L446 . To summarize the steps so far, we know that . | BCV is decreased by decay | decay = adjustments[id_].change or decay &lt; adjustments[id_].change | BCV will continue decreasing while decay &lt; adjustments[id_].change | The ratio secondsSince / adjustments[id_].timeToAdjusted determines how quickly adjustments[id_].change changes | . The key problem we see in the simulator graphs stems from extreme cases of the last point: the ratio secondsSince / adjustments[id_].timeToAdjusted determines how quickly adjustments[id_].change changes, and therefore how quickly BCV and price changes. Take the scenario where a period of time has passed since the last bond purchase, which is where the simulator shows the ROI increasing rapidly. When the next bond purchase occurs, the totalDebt will increase at some rate, but the BCV will start decreasing at a rate proportional to the time since the last purchase, which can be greater than the rate of totalDebt increase (as we described earlier, BCV can have more “weight” in dropping the price). If the rate of BCV decline is significantly greater than the rate of increase of totalDebt, then bond price can drop and keep dropping while purchases of the bonds are happening. This can happen because once adjustments[id_].active is triggered and the BCV starts decreasing, BCV will only stop decreasing when secondsSince &gt;= info.timeToAdjusted which will cause adjustment[id_].change = 0 in line 446. Ideally BCV should stop decreasing prior to this point if there is sufficient buying pressure. Otherwise the bond market does not properly react to market demand and the final quote tokens received by the market owner may be lower than the target. The screenshot below of the individual simulator data points using the default values in the simulator spreadsheet show how the BCV adjustment value is constant (light blue) while the BCV is decreasing (orange) despite the buying pressure at bond prices with a high ROI (green). This allows the buyer to get a good deal at the market owner’s expense. Although the selected screenshot below is the “extreme” case of the market before closing, the same behavior exists elsewhere when there are period of time without any bond purchases. The BCV will only increase again when adjustment &gt; 0. Impact . Medium, while the market owner could receive less value than expected, the price will remain above the market owner’s chosen minPrice. This issue will be most pronounced in inefficient market conditions which are more likely to occur with low liquidity or low value markets without frequent buying pressure . Recommendation . Because the BCV can swing the price downwards, extreme BCV decreases should be minimized. The BCV should increase when there is buying pressure. One solution would to be reduce the rate of BCV decrease when bond purchases happen instead of allowing BCV to continue decreasing at a linear rate. If purchases happen, the BCV could begin decreasing at a decreasing rate (not a linear rate), which would avoid the price dropping as quickly. This improvement would align the tuning approach to something more like a PID controller, which improves the feedback loop as market signals (AKA bond purchases) are received. This could improve the returns of the market owner. Using a more common approach for tuning can allow for improved stability and potentially better modeling of the system in various markets conditions. The lack of documentation around the existing tuning behavior demonstrates that it may not be designed as robustly as other control loop algorithms. Developer Response . The idea of decreasing the adjustment rate on a new purchase is interesting. We believe we have solved this issue by normalizing capacity to a uniform value throughout the market duration and not dividing it by the increasingly small seconds remaining. Mitigation introduced to audit-changes branch. 4. Medium - totalDebt value overwritten (engn33r) . markets[id_].totalDebt is modified twice in _decayAndGetPrice() of BondBaseCDA.sol. Because markets[id_].totalDebt is directly used in bond price calculation, using the wrong markets[id_].totalDebt value can result in incorrect prices. The second time that markets[id_].totalDebt is modified, a cached value of totalDebt is used, not the updated markets[id_].totalDebt value modified earlier in the same function. The modified value of markets[id_].totalDebt is used in _currentMarketPrice(), which determines whether the second modification of markets[id_].totalDebt will take place, so most likely this second modification should not fully overwrite the first. Proof of Concept . The issue only exists when _decayAndGetPrice() is called, uint256(metadata[id_].lastDecay) &lt;= block.timestamp is true, and marketPrice_ &lt; minPrice is true. The first time markets[id_].totalDebt modification https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L426 . The second markets[id_].totalDebt modification. Observe that this modification references the cached markets[id_].totalDebt stored as market.totalDebt from before the first modification https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L455 . Impact . Medium, markets[id_].totalDebt values will be incorrect in certain edge cases, leading to incorrect bond prices. Recommendation . Edit line 455 from . markets[id_].totalDebt = market.totalDebt.mulDiv(minPrice, marketPrice_); . to read . markets[id_].totalDebt = markets[id_].totalDebt.mulDiv(minPrice, marketPrice_); . Developer Response . Agree with this. The line of code was removed during mitigations to the BCV tuning design in audit-changes branch. ",
    "url": "/reports/04-2022-Ohm-Bond/#medium-findings",
    "relUrl": "/reports/04-2022-Ohm-Bond/#medium-findings"
  },"23": {
    "doc": "04-2022-Ohm-Bond",
    "title": "Low Findings",
    "content": "1. Low - Values grow quickly near end of market (engn33r) . Several variables are calculated by dividing by the remaining time until the market expiry. When the market nears expiry, these values “blow up” and can grow very large. This could cause some gamification or arbitrage opportunities near the end of the market, potentially at the cost of the market owner. The case of targetDebt blowing up is handled by capping the value to maxDebt in the latest repo commit, but no capping of maxPayout is performed a few lines earlier. Proof of Concept . Several values are calculated in _createMarket() by dividing by secondsToConclusion and there is no limit around how long a market lasts when it is created . | tuneIntervalCapacity https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L168-L170 | lastTuneDebt https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L183-L187 | targetDebt https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L204 | maxPayout https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#209 | . targetDebt and maxPayout are later calculated with the same formula in _tune(), but because _tune() can be run very close to the end of market expiry for a market of any duration, this case can be more problematic than the dividing by secondsToConclusion in _createMarket() because it can impact any market, not just markets with a very short duration. https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#518 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#521 . Impact . Low . Recommendation . There is no minimum value for params_.conclusion - block.timestamp, which means very short markets can exist. Creating such a market would likely be harmful to the market owner for the reasons listed above, so adding a minMarketDuration state variable that can only be modified by an admin in the setDefaultIntervals() function would allow the minimum market duration to be controlled. As for the case of the variable blowup in _tune(), targetDebt already has a max cap in place with the latest repo commit but a similar fix should be added to cap the value of maxPayout. Developer Response . Agree with this issue. We’ll implement the recommendations. Mitigation introduced to audit-changes branch. 2. Low - Inaccurate assumption about scaleAdjustment (engn33r) . A comment in _createMarket() of BondBaseCDA states . // scaleAdjustment = (baseDecimals - quoteDecimals) - (basePriceDecimals - quotePriceDecimals) / 2 . but params is a user-provided input parameter and can have any value, so params_.scaleAdjustment does not necessarily equal the formula described in the comment. While _createMarket() is an internal function, it is called directly by the external createMarket() function in BondFixedExpCDA.sol and BondFixedTermCDA.sol. Proof of Concept . The formula for scaleAdjustment is found in two different comments https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L142 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/interfaces/IBondAuctioneer.sol#L36 . The scaleAdjustment value is used in the creation of the new market without a check https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L224 . Impact . Low, the assumption made in the comment is not accurate and may have side-effects, such as making the market unusable due to a revert condition with a very large scaleAdjustment value. Recommendation . First, the comment should make it clear if the subtraction should happen before the division (order of operations). The code should be modified to add a check in the _createMarket() function to confirm the output matches the formula in the comment, such as: . testScaleAdjustment = (baseDecimals - quoteDecimals) - (basePriceDecimals - quotePriceDecimals) / 2; require(testScaleAdjustment == params_.scaleAdjustment); . Developer Response . The official front-end UI will assist users in ensuring this value is correct, but I agree that the comment should be clarified to state that the calculation is what is expected and the market may not function correctly if the wrong value is provided so other front-ends could do this correctly as well. Mitigation introduced to audit-changes branch. 3. Low - Anyone can trigger a market closure (engn33r) . The debtBuffer value is configured by the user to set the market circuit breaker. The market will be closed if the maxDebt level is triggered. Any user can choose to purchase bonds in a way to exceed this trigger, closing the market. While there is no clear value that the user closing the market could extract from Olympus Bonds by closing the market, they may have other motives, such as performing a denial of service on other DeFi protocols that rely on an Ohm Bond market. Proof of Concept . The maxDebt circuit breaker can trigger a market to close in BondBaseCDA.sol https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L381-L382 . There is no way to reopen a closed market, so a new market will need to be created if it was closed. Impact . Low, the user closing the market would not harm other users beyond a temporary denial of service for this market. Recommendation . I cannot think of an easy solution to balance market robustness while protecting owner value, so owners may have to deal with recreating markets if they are closed as a side effect of the system design. Providing a feature for the market owner to reopen a closed market may be one solution, but this could have other unwanted side effects if not designed properly. If a market owner wants to avoid market closure at all costs, the params.debtBuffer has no checks to limit it to a maximum value of 1e5 (100%), so a market owner can choose to set an extremely large maxDebt limit. This approach should be clearly documented if it is the intended solution for market owners that require markets without downtime during the market duration. Developer Response . The POC you describe is working as intended. Because of the way market pricing works, the preferred method for “reopening” a market is to just create a new one. Having a debtBuffer over 100% is allowed. Agree that we should clarify the documentation. Mitigation introduced to audit-changes branch. 4. Low - Missing zero case checks (engn33r) . Several zero checks are missing that could impact protocol assumptions. Proof of Concept . params.depositInterval can be zero, which leads to a maxPayout of zero https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L177 params.capacity can be zero, which leads to tuneIntervalCapacity, targetDebt, maxPayout, and maxDebt of zero. https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L200-L202 params_.debtBuffer can be zero, which leads to maxDebt == targetDebt with no buffer https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L233 The interval variables set in setIntervals() could have zero checks before they are set. https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L261 The default variables set in setDefaultIntervals() could also have zero checks before they are set. https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L288 . Impact . Low, zero cases may be unexpected. Recommendation . Add checks to require non-zero values such as . require(params.depositInterval != 0); require(params.capacity != 0); . Developer Response . Agree with having zero checks for the interval values. Time shouldn’t be zero. Debt buffer also should not be zero because the market will shutdown immediately if a bond is purchased. Per the other issue, we need to set a minimum value for DebtBuffer and document better. As for capacity, if it is zero, the market simply won’t function. Therefore, I don’t think we need a check there. Mitigation introduced to audit-changes branch. 5. Low - Incompatible with fee-on-transfer tokens (engn33r) . Some ERC20 tokens are deflationary or charge a fee-on-transfer. This can result in the token amount in a transfer not equating to the token amount received. The Olympus Bond system does not properly handle such tokens, which could be problematic because any ERC20 can be used to create a market. Proof of Concept . The amount amount_ of quoteToken is transferred in _handleTransfers() https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseTeller.sol#L186 . Later, it is expected that the Teller contract receive exactly amount_ of quoteTokens. Because amount_ = amount + totalFees and the contract assumes it holds amount_, the contract later sends amount to the market owner and sends totalFees to the fee recipients. If these numbers don’t add up, one scenario is that the fee recipients cannot claim their fees because the contract does not hold tokens adding up to the internally stored rewards value for the fee recipients. Impact . Low, fee rewards may not be possible to claim with certain tokens . Recommendation . To prevent the use of fee-on-transfer quote token, the _handleTransfers() function can . | Store the balance of quoteToken held by address(this) | Transfer amount_ of quoteToken from msg.sender | Revert if the balance of quoteToken held by address(this) did not increase by amount_ | . A similar modification will be needed to prevent a fee-on-transfer base token. Other modifications may also be needed, perhaps in the create() function, but preventing the purchase() operation will at least remove a standard user’s ability to interact with a market with a fee-on-transfer token. Further changes will be needed if the goal is to permit the use fee-on-transfer tokens, specifically measuring the token amount held before and after each transfer to track the exact balance changes. Developer Response . Agree with this being an issue. Mitigation introduced to audit-changes branch. ",
    "url": "/reports/04-2022-Ohm-Bond/#low-findings",
    "relUrl": "/reports/04-2022-Ohm-Bond/#low-findings"
  },"24": {
    "doc": "04-2022-Ohm-Bond",
    "title": "Gas Savings Findings",
    "content": "1. Gas - Use != 0 for gas savings (engn33r) . Using &gt; 0 is more gas efficient than using != 0 when comparing a uint to zero. This improvement does not apply to int values, which can store values below zero. Proof of Concept . Two instances of this were found: . | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/lib/FullMath.sol#L35 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/lib/FullMath.sol#L122 | . Impact . Gas savings . Recommendation . Replace &gt; 0 with != 0 to save gas. 2. Gas - Unnecessary zero initialization (engn33r) . Initializing an int or uint to zero is unnecessary, because solidity defaults int/uint variables to a zero value. Removing the initialization to zero can save gas. Proof of Concept . Several instances of this were found: . | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/lib/ERC1155.sol#L90 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/lib/ERC1155.sol#L135 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/lib/ERC1155.sol#L190 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/lib/ERC1155.sol#L225 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondFixedTermTeller.sol#L139 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L153 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L160 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L177 | . Impact . Gas savings . Recommendation . Remove the explicit variable initializations. 3. Gas - Use prefix in loops (engn33r) . Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and can have a big gas impact when the loop executes on a large number of elements. The gas savings comes from the removal of a temporary variable. j++ is equal to 1 but j equals 2, while with ++j both j and ++j equal 2. Proof of concept . There are several instances of this finding: . | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L177 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L180 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L186 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L191 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/OlympusTreasuryCallback.sol#L74 | . Impact . Gas savings . Recommendation . Increment with prefix addition and not postfix in for loops. 4. Gas - Cache array length before loop (engn33r) . The array length is read on each iteration of a for loop. Caching this value before the for loop in a separate uint variable can save gas. Proof of Concept . Multiple for loops can receive this gas optimization: . | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L153 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L160 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L177 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L186 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondFixedTermTeller.sol#L139 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/OlympusTreasuryCallback.sol#L74 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseTeller.sol#L103 | . Impact . Gas savings . Recommendation . Cache the array length in a uint variable before the for loop begins. 5. Gas - Bitshift is cheaper for powers of two (engn33r) . While it is not aesthetically pleasing, using a bitshift of « or » is cheaper than multiplication or division for cases where overflow is not a concern. Proof of Concept . One location could easily benefit from this gas optimization: https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseTeller.sol#L247 . It is possible these lines in FullMath could benefit from this optimization, but further testing would need to confirm there is no risk of overflow issues https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/lib/FullMath.sol#L92-L97 . Impact . Gas savings . Recommendation . Replace multiplication and division for powers of two by bitshifting to save gas. 6. Gas - Remove unused functions from imported libraries (engn33r) . The safeApprove() and safeTransferETH() functions in the TransferHelper.sol library are not used by Olympus Bond. These functions can be removed to save gas on deployment of contracts that import this library. The mulDivRoundingUp() function in FullMath.sol is not used by Olympus Bond and can be removed to save gas on deployment of contracts that import this library. The URI event in ERC1155.sol is unnecessary because a comment states that the uri() function has been removed. Proof of Concept . https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/lib/TransferHelper.sol#L35-L51 . Impact . Gas savings . Recommendation . Remove unused code to save gas. 7. Gas - Remove unused variable (engn33r) . The MAX_UINT256 constant variable is declared in BondBaseCDA but is never used and can be removed. Proof of Concept . https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L92 . Impact . Gas savings . Recommendation . Remove unused variable to save gas. 8. Gas - Cache variable for reuse (engn33r) . The same capacity calculation is performed twice. Calculating once and caching the result can reduce gas use. Similar scenarios where variable caching can save gas exist elsewhere. Proof of Concept . The first capacity calculation https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L184-L186 The second duplicate capacity calculation https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L200-L202 . The first payout + totalFees calculation https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L354 The second duplicate payout + totalFees calculation https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L369 The third duplicate payout + totalFees calculation https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L372-L373 . In deploy() of BondFixedExpTeller.sol, bondTokens[underlying_][expiry_] is used at least two times, or three times when the if statement is entered. Caching this value at the start of the function increases gas efficiency https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondFixedExpTeller.sol#L140 . Impact . Gas savings . Recommendation . Cache calculations for gas efficiency. 9. Gas - Tidy up _handlePayout logic (engn33r) . The logic in _handlePayout() in BondFixedExpTeller.sol and BondFixedTermTeller.sol can be simplified for gas savings. Proof of Concept . The current code in BondFixedExpTeller.sol has two separate if statements . if (vesting_ &gt; uint48(block.timestamp)) { expiry = vesting_; } // else expiry == 0 // If no expiry, then transfer directly. Otherwise, handle bond vesting. if (expiry == 0) { // Transfer payout to user underlying_.safeTransfer(recipient_, payout_); } else { // Fixed-expiration bonds mint ERC-20 tokens bondTokens[underlying_][expiry].mint(recipient_, payout_); } . These can be combined with this simplified code . if (vesting_ &gt; uint48(block.timestamp)) { expiry = vesting_; // Fixed-expiration bonds mint ERC-20 tokens bondTokens[underlying_][expiry].mint(recipient_, payout_); } else { // If no expiry, then transfer directly. Otherwise, handle bond vesting. // Transfer payout to user underlying_.safeTransfer(recipient_, payout_); } . The same improvement can be applied to _handlePayout() in BondFixedTermTeller.sol. Impact . Gas savings . Recommendation . Simplify logic in BondFixedExpTeller.sol and BondFixedTermTeller.sol as shown above. 10. Gas - Redundant return variable (engn33r) . In BondBaseTeller.sol, _uint2str() names a return string variable but doesn’t use it. This return variable declaration can be removed for minor gas savings. Proof of Concept . The function is declare with . function _uint2str(uint256 _i) internal pure returns (string memory _uintAsString) . https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseTeller.sol#L279 . Because _uintAsString is never used, it can be modified to . function _uint2str(uint256 _i) internal pure returns (string memory) . Impact . Gas savings . Recommendation . Remove unused return variable. 11. Gas - Use unchecked when no risk of overflow or underflow (engn33r) . In BondBaseCDA.sol, an unchecked clause can be added. Proof of Concept . No subtraction underflow is possible in this line . uint256 secondsSince = currentTime &gt; lastDecay ? currentTime - lastDecay : 0; . https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L568 . Unchecked can be added to this line for gas savings . unchecked { uint256 secondsSince = currentTime &gt; lastDecay ? currentTime - lastDecay : 0; } . The same optimization can be applied in at least one other place with a ternary operator https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L542-L544 . Impact . Gas savings . Recommendation . Use unchecked when no risk of overflow or underflow exists. 12. Gas - Move variable assignment to avoid overwrite (engn33r) . In BondBaseCDA.sol, a variable may be overwritten. Moving the variable assignment avoids this to save gas. Proof of Concept . adjustments.active is set to false on line 503 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L503 . But if the else clause is entered later, this state variable is overwritten with true https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L538 . Assigning adjustments.active to false should be moved to inside the if clause around line 533 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L533 . Impact . Gas savings . Recommendation . Move the variable assignment to prevent overwriting for gas savings. 13. Gas - Using simple comparison (engn33r) . Using a compound comparison such as ≥ or ≤ uses more gas than a simple comparison check like &gt;, &lt;, or ==. Compound comparison operators can be replaced with simple ones for gas savings. Proof of concept . The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 . if (newControlVariable &gt;= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } . By switching around the if/else clauses, we can replace the compound operator with a simple one . if (newControlVariable &lt; controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } . There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes. Impact . Gas savings . Recommendation . Replace compound comparison operators with simple ones for gas savings. ",
    "url": "/reports/04-2022-Ohm-Bond/#gas-savings-findings",
    "relUrl": "/reports/04-2022-Ohm-Bond/#gas-savings-findings"
  },"25": {
    "doc": "04-2022-Ohm-Bond",
    "title": "Informational Findings",
    "content": "1. Informational - Bond purchase size does not impact price (engn33r) . In a constant product AMM, if a large purchase order is placed, the price will be slightly worse than if a small purchase order was placed. This is not the case with Ohm Bond. While the purchase price cannot go below the minPrice set by the market owner, if the bond price was near the minPrice and a buyer spotted an arbitrage opportunity, they could place a large order of amount maxPayout at this low price without any price impact. This may yield the market owner fewer tokens compared to a pricing model more similar to a constant product AMM, where the price would increase for an order of this size. Proof of Concept . The only pricing-related variable that accounts for the size of the purchase order is metadata[id_].lastDecay, but it is updated after the bond price has been determined and does not impact the current order. https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L473 . Impact . Informational . Recommendation . Whether this is a feature or a bug is up to the developer’s discretion. If it is expected that all market owners would be happy to exchange all their base tokens for quote tokens at minPrice, then this may not be an issue. If the goal is to provide market owners with more quote tokens, then changing the price calculations to vary based on order amount may make sense. 2. Informational - Frontrunning changes price (engn33r) . If an Ohm Bond purchase order exists in the mempool, a frontrunning bot can place an order for the same market and frontrun the original order. In some cases this can alter the price of the bonds in such a way that the original order’s minAmountOut_ is not met, causing the original order to revert. This is not considered a notable security issue because sustaining this type of a denial of service for a significant amount of time is expensive. Additionally, similar edge cases exist with AMMs and other DeFi systems with dynamic prices. Proof of Concept . The _currentMarketPrice() function returns the bond price. It is calculated as controlVariable * totalDebt / scale. https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L558 . Based on this calculation, the price can increase if either 1. the controlVariable increases or 2. if totalDebt increases. Both cases are possible. The controlVariable value can increase if 1. tune interval or capacity trigger tuning and 2. newControlVariable &gt;= controlVariable. An increased controlVariable value will increase the price https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L533 . The totalDebt value increases each time purchaseBond() is called, which increases the price https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L372 . Impact . Informational . Recommendation . Given the default intervals, normally there shouldn’t be a problem. But the setDefaultIntervals() function can modify these defaults, so while this function exists in its current form with no limits on the default values, a very short auction is possible where price swings within a single block may matter more. 3. Informational - Unclear if default tuning parameters are optimal (engn33r) . There are default interval values in several variables, but it is not clear whether the choices for these values came from rigorous simulation to reduce the risk of market owner loss of value or whether these defaults are arbitrary. The price mechanics for the Olympus Bond system are quite complex - it takes a lengthy and detailed blog post to explain how it operates, and that’s using a simulator that doesn’t necessarily account for edge cases in turbulent market conditions. Due to the complexity of the system, it is unlikely that the average market owner will investigate what pricing and tuning parameters are best for their specific market, which requires among other things consideration of asset volatility for the quote and base token. Given that the biggest risk to market owners is buyer arbitrage due to bad tuning parameters, resulting in high ROI for buyers but at the cost of the market owner receiving less value than expected, it is not clear whether the Olympus Bond platform provides good defaults to protect the market owner from this scenario. While it can be argued that it is the market owner’s responsibility to set proper values for their market, and potential loss of value would not impact Olympus DAO directly, giving an extremely complex system to market owners who are unlikely to dive into the intricate details to set good defaults for their own scenario could be problematic. To add to this, the simulator demonstrates instances of high ROI for buyers when the BCV View drops suddenly. It was not clear whether this was an artifact in the simulator or whether this behavior would carry over to the on-chain implementation. Proof of Concept . The Ohm Bond system uses its own internal pricing algorithm, which does not rely on any outside source of price (oracles, TWAPs, etc.). While this removes certain attack vectors, there is a high level of complexity in this algorithm. The complexity is evident in this informative yet lengthy blog post. Screenshots of the simulator demonstrates conditions where the high ROI received by a buyer could come at the cost of the seller (AKA market owner). It is unclear whether the ROI kinks in the simulator graphs, where ROI reaches 30% or more, is a result of the simulator not adequately aligning with the solidity implementation or whether the pricing mechanics with specific default values can lead to unstable conditions and market owner loss of value. Impact . Informational . Recommendation . Good defaults need to be chosen to reduce risk to market owners who do not perform adequate due diligence in setting up their market properly. If a more closed-form equation combining the tuning function with the bond pricing equation could be developed, it would be clearer to understand under what conditions the pricing mechanics may become unstable and result in large changes in valuation. 4. Informational - Add a check to limit debtBuffer to 100% (engn33r) . params_.debtBuffer has no checks to limit it to a maximum value of 1e5 (100%), so a market owner can choose to set an extremely large maxDebt limit. Finding L4 notes that this may be a feature rather than a bug, so a fix may not be needed unless the intent is to cap params_.debtBuffer to 100% (1e5). Proof of Concept . params_.debtBuffer is used once https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L233 . Impact . Informational . Recommendation . Add the line require(params_.debtBuffer &lt;= 1e5); if the intent is to cap this variable, otherwise leave it as is. 5. Informational - Function format inconsistency (engn33r) . The getTeller() and currentCapacity() functions in the BondAggregator.sol contract do not follow the same format as the other external view functions that cache marketsToAuctioneers[id_] as auctioneer first. Choose one format and use it consistently. Proof of Concept . https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L235-L242 . Impact . Informational . Recommendation . Use a consistent format for similar functions in the same contract. 6. Informational - Variable name nitpick (engn33r) . The variable named “nonce” in the liveMarketsBetween() function of BondAggregator.sol does not serve as a cryptographic nonce, which is where the term is normally used, but rather as a counter that is incremented sequentially. Variables should have names that represent their purpose. Proof of Concept . Three functions in BondAggregator.sol have a nonce variable . | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L130-L134 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L158-L163 | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L184-L191 | . Impact . Informational . Recommendation . Use a more descriptive variable name. 7. Informational - TransferHelper.sol not from solmate (engn33r) . The comment in TransferHelper.sol “Taken from Solmate” is confusing because this contract’s functions are from Uniswap. Solmate’s SafeTransferLib.sol contract uses a lot more Yul assembly. Proof of Concept . The comment . | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/lib/TransferHelper.sol#L8 | . Impact . Informational . Recommendation . Change the comment if you wish. 8. Informational - CloneERC20.sol missing EIP-2612 code (engn33r) . The comment in CloneERC20.sol “Modern and gas efficient ERC20 + EIP-2612 implementation” is no longer accurate because the EIP-2612 code has been removed. Proof of Concept . The comment . | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/lib/CloneERC20.sol#L6 | . Impact . Informational . Recommendation . Change the comment if you wish. 9. Informational - Incorrect comment (engn33r) . The comment in BondBaseTeller.sol “extend this base since it is called by purchaseBond” is not fully correct because purchase(), not purchaseBond(), calls _handlePayout(). Proof of Concept . The comment . | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseTeller.sol#L212 | . Impact . Informational . Recommendation . Change purchaseBond to purchase. 10. Informational - Confusing variable naming (engn33r) . Some variable name choices could lead to confusion by future developers. Examples include: . | lastDecay in BondBaseCDA may not equal the block.timestamp, but can be greater than or less the block.timestamp when it gets updated. lastDecay is changed proportionally with the amount of the bond purchase | Because secondsSince is calculated using lastDecay, secondsSince may not equal the time since the last debtDecay happened. | Elsewhere, a variable named secondsSince does use block.timestamp for calculations. | . Proof of Concept . This line is where lastDecay is set. Observe it is not set to block.timestamp but instead is correlated to the size of the payout (AKA bond purchase amount) https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L473 This line in _debtDecay() is where secondsSince is assigned, but lastDecay does not correlate to the last updated timestamp so secondsSince does not equal the number of seconds since the last time the value was updated https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L568 The _controlDecay() function assigns block.timestamp - previous timestamp to a variable named secondsSince (info.lastAdjustment is equal to the previous timestamp because of line 444 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L444) https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L589 . Impact . Informational . Recommendation . Consider storing all magic numbers in constants. 11. Informational - Expired markets are never “closed” (engn33r) . The _close() function performs two actions: . | Set conclusion to block.timestamp | Set capacity to zero | . An expired market does not have its capacity set to zero, it will only have a conclusion time in the past. This discrepancy means that . | There is no point to setting the market capacity to zero in _close() and this line can be removed so all expired and closed markets are in the same state with a conclusion time in the past | There is a reason to set the market capacity to zero and expired markets should have their capacity set to zero, which is not currently done. | . Because the purchase() function will revert after market expiry, the lack of closing an expired market does not appear to be a security issue. Proof of Concept . While expired markets do not have _closed() called on them, this line prevents a purchase from happening if the market is expired https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L331 . Impact . Informational . Recommendation . Following the options above, either 1. remove capacity = 0 in _closed or 2. set capacity to zero from expired markets. 12. Informational - Legitimate tokens disallowed (engn33r) . The bond system’s requirement for 6 &lt;= tokenDecimals &lt;= 18 will disallow some legitimate tokens, such as GUSD (2 decimals) and Yam (24 decimals). https://github.com/d-xo/weird-erc20#low-decimals . Proof of Concept . The decimals requirement is applied in BondBaseCDA.sol . | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L131-L132 | . Impact . Informational . Recommendation . No change necessary if the development team is satisfied with the impact of this choice. 13. Informational - Tokens with non-string metadata disallowed (engn33r) . The _getNameAndSymbol() function requires the metadata to be strings. Non-string metadata will cause this function to revert. The _getNameAndSymbol() function is called in the getTokenNameAndSymbol() view function, which is not necessary critical if it fails. But it is also called in the BondFixedExpTeller.sol deploy() function, which would cause problems when BondFixedExpCDA.sol calls deploy() and prevent the market from being created. https://github.com/d-xo/weird-erc20#non-string-metadata . Proof of Concept . The _getNameAndSymbol() function requires ERC20 metadata to be a string https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseTeller.sol#L231 . Impact . Informational . Recommendation . No change necessary if the development team is satisfied with the impact of this choice. 14. Informational - vesting and expiry sometimes used interchangeably (engn33r) . In BondFixedExpTeller.sol, the bondTokens mapping stores ERC20 bond tokens unique to an underlying and expiry. But the getBondTokenForMarket() function uses the vesting variable instead of the expiry variable. In other places, expiry != vesting. While this does not appear to be return an incorrect value, the interchangeable use of these terms is only sometimes valid, which could lead to confusion. Proof of Concept . The confusion is caused by . | The bondTokens mapping uses “underlying” and “expiry” | “expiry” != “vesting” in some places | bondTokens uses “vesting”, not “expiry”, in one place | Comment references vesting but uses a variable named expiry . | The bondTokens mapping is described as using unique underlying and expiry values https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondFixedExpTeller.sol#L43 . | The _handlePayout() function has vesting and expiry values that are not necessarily equal https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondFixedExpTeller.sol#L66 Similarly, BondAggregator.sol has code that indicates expiry != vesting in some cases https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L219 . | The getBondTokenForMarket() function uses vesting instead of expiry with the bondTokens mapping. This is the only location where vesting is used instead of expiry for this mapping. https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondFixedExpTeller.sol#L165 . | Vesting is mentioned in the comment but a variable named expiry is used https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondFixedTermTeller.sol#L201-L204 | . Impact . Informational . Recommendation . Change the variable names to remain more consistent . 15. Informational - market price functions consistency (engn33r) . There are two functions in BondBaseCDA.sol that handle market price calculations, marketPrice() and _currentMarketPrice(). marketPrice() includes code for handling the case where the calculated price is below the minimum price, but _currentMarketPrice() does not contain such logic inside the function. Instead, _currentMarketPrice() has this logic added outside the function when it is called. Consider moving the minimum price logic inside of _currentMarketPrice() to keep the two similar functions consistent. Proof of Concept . marketPrice() has logic to handle a calculated price less than the minimum price inside the function https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L626 . _currentMarketPrice() requires minimum price logic external to the function after the function is called https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L452-L457 . Impact . Informational . Recommendation . Consider aligning the logic in similar functions. 16. Informational - Use variable instead of magic numbers (engn33r) . The debtBuffer is configurable to 3 decimals (max value of 1e5), but unlike FEE_DECIMALS this value is not stored in a constant. Proof of Concept . The comment . | https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L233 | . Impact . Informational . Recommendation . Consider storing all magic numbers in constants. ",
    "url": "/reports/04-2022-Ohm-Bond/#informational-findings",
    "relUrl": "/reports/04-2022-Ohm-Bond/#informational-findings"
  },"26": {
    "doc": "04-2022-Ohm-Bond",
    "title": "Final remarks",
    "content": "engn33r . The project architecture is well thought out and there is reasonably detailed documentation, even if the documentation isn’t organized into a single place yet. The design even allows for recursive use, where an Olympus Bond token can be used in a new Bond market. There were a couple pieces of the system, namely the market callback function and the setIntervals function, that may add security problems in their current form, so removing these features would be preferred. The ability for duplicate markets may also warrant reconsideration due to the risks it could pose interacting with malicious designed markets. In comparison, AMMs only allow for one pool per token pair. Perhaps the most complex piece of the system is the calculation of bond price and the tuning calculations. The time-limited nature of this review meant that extensive simulation of edge cases to test the robustness of the pricing calculation implementation was not carried out, and the accuracy of the simulator compared to the solidity implementation was not verified. However, some minor details of the pricing mechanics do not seem ideal. These are complex parts of the system and ideally should receive more extensive documentation and modeling explaining why certain choices were made, under what market conditions they hold, and graphs demonstrating the relative stability of the resulting prices under a wide range of variables. Other lingering questions remain, such as conditions when the market duration is not divisible by the tuning interval values, resulting in a shorter final interval. ",
    "url": "/reports/04-2022-Ohm-Bond/#final-remarks",
    "relUrl": "/reports/04-2022-Ohm-Bond/#final-remarks"
  },"27": {
    "doc": "04-2022-Ohm-Bond",
    "title": "About yAcademy",
    "content": "yAcademy is an ecosystem initiative started by Yearn Finance and its ecosystem partners to bootstrap sustainable and collaborative blockchain security reviews and to nurture aspiring security talent. yAcademy includes a fellowship program, a residents program, and a guest auditor program. In the fellowship program, fellows perform a series of periodic security reviews and presentations during the program. Residents are past fellows who continue to gain experience by performing security reviews of contracts submitted to yAcademy for review (such as this contract). Guest auditors are experts with a track record in the security space who temporarily assist with the review efforts. ",
    "url": "/reports/04-2022-Ohm-Bond/#about-yacademy",
    "relUrl": "/reports/04-2022-Ohm-Bond/#about-yacademy"
  },"28": {
    "doc": "04-2022-Ohm-Bond",
    "title": "Appendix and FAQ",
    "content": "Based on conversations with the Olympus Bond team, the access control modifiers (including onlyGovernor, onlyGuardian, onlyPolicy, and onlyVault) are placeholders and will be changed. These modifiers indicate places where access controls will exist, but the specific controls will likely change from the approach in the commit reviewed. Therefore, any contracts that use these modifiers or import the files OlympusAccessControlled.sol or OlympusAuthority.sol is likely to be changed before a production deployment. ",
    "url": "/reports/04-2022-Ohm-Bond/#appendix-and-faq",
    "relUrl": "/reports/04-2022-Ohm-Bond/#appendix-and-faq"
  },"29": {
    "doc": "04-2022-Ohm-Bond",
    "title": "04-2022-Ohm-Bond",
    "content": " ",
    "url": "/reports/04-2022-Ohm-Bond/",
    "relUrl": "/reports/04-2022-Ohm-Bond/"
  },"30": {
    "doc": "04-2022-veYFI",
    "title": "yAcademy veYFI review",
    "content": "Review Resources: None provided beyond the code repository . Residents: . | NibblerExpress | Engn33r | . ",
    "url": "/reports/04-2022-veYFI/#yacademy-veyfi-review",
    "relUrl": "/reports/04-2022-veYFI/#yacademy-veyfi-review"
  },"31": {
    "doc": "04-2022-veYFI",
    "title": "Table of Contents",
    "content": ". | Review Summary | Scope | Code Evaluation Matrix | Findings Explanation | High Findings . | 1. High - Incompatible Vote Delegation (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 2. High - Lock 1e-18 YFI to Get Rewards (NibblerExpress) . | Proof of concept | Impact | Recommendation | Developer Response | . | 3. High - Flash Loan Sybil Attack to Boost Rewards (NibblerExpress) . | Proof of concept | Impact | Recommendation | Developer Response | . | . | Medium Findings . | 1. Medium - Incorrect variables in getRewardFor call (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 2. Medium - Unclear Integration of Vote Delegation Until Value (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 3. Medium - force_withdraw() penalty may inadequately deter gamification and attacks on voting (engn33r, NibblerExpress) . | Proof of concept | Impact | Recommendation | Developer Response | . | . | Low Findings . | 1. Low - Voting delegation is missing edge case checks (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 2. Low - Sawtooth Wave Effect from Computing veYFI Balance and Supply Using Different Time Scales (NibblerExpress) . | Proof of concept | Impact | Recommendation | Developer Response | . | 3. Low - Equal penalty reward distribution not incentive aligned (engn33r, NibblerExpress) . | Proof of concept | Impact | Recommendation | Developer Response | . | 4. Low - No penalty during migration (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | . | Gas Savings Findings . | 1. Gas - Using “unchecked” (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 2. Gas - Using simple comparison (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 3. Gas - Use prefix in loops (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 4. Gas - Payable functions can save gas (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 5. Gas - Use != 0 for gas savings (engn33r) . | Proof of Concept | Impact | Recommendation | Developer Response | . | 6. Gas - Use Solidity errors in 0.8.4+ (engn33r) . | Proof of Concept | Impact | Recommendation | Developer Response | . | 7. Gas - Declare functions external for gas savings (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 8. Gas - Remove Aragon calls for gas savings (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 9. Gas - Inconsistent zero case in VotingEscrow.vy (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 10. Gas - Remove duplicated code (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 11. Gas - SLOAD gas savings (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | . | Informational Findings . | 1. Informational - SafeERC20 functions not used (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 2. Informational - Unspecified Voting Requirements (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 3. Informational - Variable naming inconsistency (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 4. Informational - Missing 0 check in setDuration() (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 5. Informational - Typos (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 6. Informational - Replace magic numbers with constants (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 7. Informational - Code inconsistency (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 8. Informational - Curve safety check removed (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 9. Informational - No migrateLock sample implementation (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 10. Informational - Use -= to keep code concise (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | 11. Informational - Update rewards for other users (engn33r) . | Proof of concept | Impact | Recommendation | Developer Response | . | . | Final remarks . | engn33r | NibblerExpress | . | About yAcademy | Appendix and FAQ | . ",
    "url": "/reports/04-2022-veYFI/#table-of-contents",
    "relUrl": "/reports/04-2022-veYFI/#table-of-contents"
  },"32": {
    "doc": "04-2022-veYFI",
    "title": "Review Summary",
    "content": "veYFI . The purpose of veYFI is to transition the YFI token to the vote escrow (ve) tokenomics model. The Yearn multisig will manage the contracts, which can upgrade and migrate as needed. The GaugeFactory contract creates new Gauge and ExtraReward contracts for each Yearn Vault. The Registry contract maintains a list of active gauges and rewards pools with their corresponding vaults, which enables upgrades to the system. The Gauge contract handles deposits of YFI while the VotingEscrow.vy contract, forked and modified from Curve’s ve tokenomics design, handles deposits of veYFI to enable governance rights. Some differences from Curve’s ve tokenomics include the ability to withdraw locked veYFI with a penalty and the ability for locked veYFI holders to delegate votes. The main branch of the veYFI Repo was reviewed over 20 days, 3 of which were used to create an initial overview of the contract. The code review was performed between March 28 and April 16, 2022. The code was reviewed by 2 residents for a total of 58 man hours (engn33r: 34 hours, and NibblerExpress: 24 hours). The repository was under active development during the review, but the review was limited to one specific commit. ",
    "url": "/reports/04-2022-veYFI/#review-summary",
    "relUrl": "/reports/04-2022-veYFI/#review-summary"
  },"33": {
    "doc": "04-2022-veYFI",
    "title": "Scope",
    "content": "Code Repo Commit . The commit reviewed was 7846291efec36638eae32ac8798544050ca20877. The review covered the entire repository at this specific commit but focused on the contracts directory. After the findings were presented to the veYFI team, fixes were made and included in commit bbecf1e2ceaac9020658d34755ee769b57d54374. Fixes were reviewed to confirm whether they remedied the original finding, but a new security review was not performed on the revised code (e.g. to determine whether new vulnerabilities were introduced by the fixes). Reviewers note that VeYFIRewards.sol was replaced by VeYFIRewards.vy between commits, and the two files appear to have significant differences in the code. The review is a code review to identify potential vulnerabilities in the code. The reviewers did not investigate security practices or operational security and assumed that privileged accounts could be trusted. The reviewers did not evaluate the security of the code relative to a standard or specification. The review may not have identified all potential attack vectors or areas of vulnerability. yAcademy and the residents make no warranties regarding the security of the code and do not warrant that the code is free from defects. yAcademy and the residents do not represent nor imply to third party users that the code has been audited nor that the code is free from defects. By deploying or using the code, Yearn and users agree to use the code at their own risk. ",
    "url": "/reports/04-2022-veYFI/#scope",
    "relUrl": "/reports/04-2022-veYFI/#scope"
  },"34": {
    "doc": "04-2022-veYFI",
    "title": "Code Evaluation Matrix",
    "content": "| Category | Mark | Description | . | Access Control | Good | The onlyOwner modifier was applied on functions that set key protocol state variables in Registry.sol and BaseGauge.sol. Elsewhere, msg.sender is used so that the user can only control their own deposits. Access controls are applied where needed. | . | Mathematics | Average | Solidity 0.8.13 is used, which provides overflow and underflow protect. No unchecked code exists and no low-level bitwise operations are performed. There was no unusually complex math, except perhaps some of the vyper code functions borrowed from Curve which were not modified. | . | Complexity | Low | The inheritance structure, duplicate function names, lack of clear comments, and inclusion of vyper code all together can make the code hard to follow at times. There is a lack of clarity around the off-chain voting process, and no comments in the code or repository issues/PRs clarify how the off-chain voting expected to integrate with on-chain voting variables. | . | Libraries | Good | Only basic Open Zeppelin contracts such as SafeERC20, Ownable, and Math are imported, no other external libraries are used. Fewer and simpler external dependencies is always a plus for security. | . | Decentralization | Average | The onlyOwner modifier indicates there is some centralization risk, but if the owner is a Yearn Finance multisig, the risk is reduced. Contracts such as VotingEscrow.vy support migration, so some form of ownership is required. | . | Code stability | Average | Changes were reviewed at a specific commit and the scope was not expanded after the review was started. However, development was ongoing when the review was performed so the code was not fully frozen, which means deployed code may vary from what was reviewed. | . | Documentation | Low | Comments existed in many places, but were lacking in key areas. As one example, identically named _updateReward functions existed in Gauge.sol, ExtraReward.sol and VeYfiRewards.sol, but no comments existed on either function and no explanation of the differences of these identically-named function existed. It would be best if more thorough comments and documentation was added throughout the code to better explain the purpose of different functions and specific math that is performed. No developer documentation like gitbooks was observed for veYFI at the time of review. | . | Monitoring | Good | Events were added to all important functions that modified state variables. | . | Testing and verification | Average | Brownie test coverage was passing with some warnings at the commit reviewed. Test coverage was above 80% in most contract functions but not all. There was a lack of testing integration with snapshot.org voting contracts and off-chain voting strategies. | . ",
    "url": "/reports/04-2022-veYFI/#code-evaluation-matrix",
    "relUrl": "/reports/04-2022-veYFI/#code-evaluation-matrix"
  },"35": {
    "doc": "04-2022-veYFI",
    "title": "Findings Explanation",
    "content": "Findings are broken down into sections by their respective impact: . | Critical, High, Medium, Low impact . | These are findings that range from attacks that may cause loss of funds, impact control/ownership of the contracts, or cause any unintended consequences/actions that are outside the scope of the requirements | . | Gas savings . | Findings that can improve the gas efficiency of the contracts | . | Informational . | Findings including recommendations and best practices | . | . ",
    "url": "/reports/04-2022-veYFI/#findings-explanation",
    "relUrl": "/reports/04-2022-veYFI/#findings-explanation"
  },"36": {
    "doc": "04-2022-veYFI",
    "title": "High Findings",
    "content": "1. High - Incompatible Vote Delegation (engn33r) . PR #99 moved veYFI to off-chain voting. Discussions with the veYFI team confirmed that the https://snapshot.org/ platform will be used for off-chain voting. The snapshot delegation documentation states the setDelegate() function should be used when a contract is delegating votes. The VoteDelegation.sol contract implements an independent vote delegation system, and there is no call in veYFI to call the setDelegate() or clearDelegate() functions in the snapshot.org delegation contract to be compatible with snapshot.org. This means the veYFI delegation code will have no impact on snapshot.org voting. Proof of concept . The VoteDelegation.sol contract has functions including delegate() and removeDelegation(), but the VoteDelegation.sol contract does not have any interaction with the snapshot DelegateRegistry contract. Because there are no contract calls to snapshot.org contracts, snapshot.org will not register any vote delegation. Impact . High. Vote delegation implementation is not compatible with intended offline voting approach. Recommendation . Overall the change to off-chain voting requires additional changes and integration effort. Some of the steps required to better integrate VoteDelegation.sol with snapshot.org include: . | Creating a veYFI space in snapshot.org, which requires an ENS domain as documented in: https://docs.snapshot.org/spaces/create | Adding calls to snapshot.org’s existing DelegateRegistry contract function calls in several places. An example implementation from Convex is provided in the documentation: https://docs.snapshot.org/guides/delegation#with-a-smart-contract. For starters, DelegateRegistry.setDelegate() should be called in the VoteDelegation.sol _delegate() function and DelegateRegistry.clearDelegate() should be called in the _removeOldDelegation() function. Additional changes may also be needed. | Confirm that unit tests exists that interact with the DelegateRegistry contract on the proper testnet | It is not immediately clear whether the erc20-balance-of snapshot.org voting strategy works with the custom vote delegation design. This should be tested before production. | . I see three different approaches to handle the off-chain voting: . | Remove vote delegation to keep everything like Curve (most simple) | Remove the “until” value in the vote delegation and modify the voting delegation to use the DelegateRegistry from snapshot.org | Implement a custom voting strategy on snapshot.org to handle the delegation and “until” values (most complex) | . Developer Response . The VoteDelegation.sol contract has been removed in PR #137 and it will be replaced by the suggested contract from snapshot.org. 2. High - Lock 1e-18 YFI to Get Rewards (NibblerExpress) . _updateReward() computes a penalty based on the locking ratio of the account. A maximum possible lock of the smallest possible value allows a user to avoid any penalty without locking any amount of value. Proof of concept . def test_gauge_cheat_yfi_lock( yfi, ve_yfi, whale, whale_amount, shark, shark_amount, fish, fish_amount, create_vault, create_gauge, gov ): yfi.approve(ve_yfi, shark_amount, {\"from\": shark}) ve_yfi.create_lock( shark_amount, chain.time() + 4 * 3600 * 24 * 365, {\"from\": shark} ) assert yfi.balanceOf(shark) == 0 yfi.approve(ve_yfi, fish_amount, {\"from\": fish}) ve_yfi.create_lock( fish_amount, chain.time() + 4 * 3600 * 24 * 365, {\"from\": fish} ) assert yfi.balanceOf(fish) == 0 yfi.approve(ve_yfi, 1, {\"from\": whale}) ve_yfi.create_lock( 1, chain.time() + 4 * 3600 * 24 * 365, {\"from\": whale} ) assert yfi.balanceOf(whale) == whale_amount - 1 lp_amount = 10**18 vault = create_vault() tx = create_gauge(vault) gauge = Gauge.at(tx.events[\"GaugeCreated\"][\"gauge\"]) vault.mint(shark, lp_amount/100) vault.approve(gauge, lp_amount, {\"from\": shark}) gauge.deposit({\"from\": shark}) vault.mint(fish, lp_amount/100) vault.approve(gauge, lp_amount, {\"from\": fish}) gauge.deposit({\"from\": fish}) vault.mint(whale, 100*lp_amount) vault.approve(gauge, 100*lp_amount, {\"from\": whale}) gauge.deposit({\"from\": whale}) yfi_to_distribute = 10**16 yfi.mint(gov, yfi_to_distribute) yfi.approve(gauge, yfi_to_distribute, {\"from\": gov}) gauge.queueNewRewards(yfi_to_distribute, {\"from\": gov}) assert pytest.approx(gauge.rewardRate()) == yfi_to_distribute / (7 * 24 * 3600) chain.sleep(3600*24*7) chain.mine() assert gauge.earned(whale) &lt; .39 * yfi_to_distribute gauge.getReward({\"from\": whale}) assert yfi.balanceOf(whale) &lt; .39 * yfi_to_distribute + whale_amount gauge.withdraw({\"from\": whale}) assert vault.balanceOf(whale) == 100*lp_amount . Impact . High. Users are able to get undue rewards with minimal investment. It is not ranked critical because the user cannot flash loan their deposit to drain the contract. The user does need to keep the deposit in for seven days to reap the rewards. Recommendation . One possible solution is to include a veYFI balance requirement when determining the penalty. Developer Response . The veYFI balance penalty has been removed. It’s replaced by a much bigger boost in PR #141. Non-boosted rewards are distributed to veYFI. 3. High - Flash Loan Sybil Attack to Boost Rewards (NibblerExpress) . The boosted balance for rewards is computed as balance * 0.4 + totalSupply * veYFIBalance / veYFITotalSypply * 0.6. (Typo in veYFITotalSupply is copied from comment in L284 of Gauge.sol.) Although depositing in your own account calls updateReward() for your account, you can use another account to flash loan a large amount of vault tokens and deposit them to boost the totalSupply. Once you have boosted totalSupply, you trigger updateReward() for the target account and then withdraw the flash loan deposit. (Note that the inverse is also true. You can either sandwich attack someone else’s update by withdrawing tokens before their update to reduce total supply, or you can withdraw tokens and use getRewardFor() to force an update to someone else’s rewards like discussed here: https://github.com/yearn/veYFI/issues/33.) . Proof of concept . Boosted Balance equation: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L302 . Deposit Update Reward call: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L351 . Total Supply increase: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L362 . Impact . High. The magnitude of the impact depends on how much you can flash loan versus what the total supply is. If you can flash loan 5x the total supply, you can get full rewards with 1/6 the intended veYFIBalance. If you can only flash loan 10% of the total supply, you only get a 9% boost to your veYFIBalance. Recommendation . A possible solution is to compute a time weighted average of totalSupply. Alternatively, governance could set a veYFIBalance multiplier to use instead of using totalSupply/veYFITotalSupply. A third solution is to add require(block.timestamp &gt; lastTimeRewardApplicable()); to the _updateReward() function to prevent a user from performing multiple deposits/withdrawals in the same block. Developer Response . Deposit and withdraw on the same block isn’t possible anymore: https://github.com/yearn/veYFI/blob/bbecf1e2ceaac9020658d34755ee769b57d54374/contracts/Gauge.sol#L443-L446 . It’s possible to game the system with a really large amount of funds but we have added a kick function that readjusts the boost in case someone misbehaves in PR #142. ",
    "url": "/reports/04-2022-veYFI/#high-findings",
    "relUrl": "/reports/04-2022-veYFI/#high-findings"
  },"37": {
    "doc": "04-2022-veYFI",
    "title": "Medium Findings",
    "content": "1. Medium - Incorrect variables in getRewardFor call (engn33r) . The _getReward() function in Gauge.sol uses the wrong account address twice, which counts and distributes rewards incorrectly when account != msg.sender. After the review started, one of these variables was fixed, but not the other. Proof of concept . The _account variable should be used in this line instead of msg.sender https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L512 . IExtraReward(extraRewards[i]).getRewardFor(msg.sender); . The _account variable should be used in this line instead of msg.sender https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L501 . IVotingEscrow(veToken).deposit_for(msg.sender, reward); . Impact . Medium. Incorrect values could be calculated when account != msg.sender in some edge cases. Recommendation . Use this fix from PR #125 for both cases, which was created after the commit at which this code review started at. Developer Response . Fixed . 2. Medium - Unclear Integration of Vote Delegation Until Value (engn33r) . This issue is similar to the high risk voting issue but relates to a difference between Curve voting (where veYFI borrows some ideas from) and the current veYFI implementation. PR #99 moved veYFI to off-chain voting. Discussions with the veYFI team confirmed that the https://snapshot.org/ platform will be used for off-chain voting. Although snapshot.org does support vote delegation, the existing snapshot.org voting delegation does not support the “until” value. This means that if the existing snapshot.org vote delegation strategy is used (which involves adding calls to the setDelegate() and clearDelegate() functions), then delegation will remain in place until it is changed by the veYFI token owner, and can remain valid beyond the until timestamp. Proof of concept . The VoteDelegation.sol contract has functions including delegate() and removeDelegation(), but the VoteDelegation.sol contract does not have any interaction with the snapshot DelegateRegistry contract. Because the actual act of voting is planned to happen off-chain with snapshot.org, snapshot.org needs to recognize what a valid vote or delegation is in the snapshot that it takes for each proposal. Currently there is no option in the snapshot.org delegation approach for an “until” value. Factoring in the “until” value could be implemented in a custom snapshot.org voting strategy, but because no such strategy is mentioned anywhere in the veYFI repository, it is expected that this has not been considered. Impact . Medium. Vote delegation implementation is not compatible with intended offline voting approach. It is not considered high risk because if the snapshot.org vote delegation is integrated (which it currently is not), the basic act of vote delegation should work and a workaround with token holders calling the right function at the right time can be used. Recommendation . The best solution is to create a custom voting strategy, instead of using the erc20-balance-of voting strategy that Curve uses. An easier solution is to remove the “until” value in the vote delegation and use the simplistic erc20-balance-of voting strategy along with the built-in snapshot.org delegation strategy. I see three different approaches to handle the off-chain voting: . | Remove vote delegation to keep everything like Curve (most simple) | Remove the “until” value in the vote delegation and modify the voting delegation to use the DelegateRegistry from snapshot.org | Implement a custom voting strategy on snapshot.org to handle the delegation and “until” values (most complex) | . Developer Response . File has been removed in PR #137. 3. Medium - force_withdraw() penalty may inadequately deter gamification and attacks on voting (engn33r, NibblerExpress) . The penalty ratio equation reads . penalty_ratio: uint256 = min(MULTIPLIER * 3 / 4, MULTIPLIER * time_left / MAXTIME) . Short lock periods receive low withdrawal penalties, which may not be intentional. Because the MAXTIME value is 4 years, when the time_left value is less than 3 years, the penalty ratio for withdrawal will be less than 75%. This means the worst case withdrawal penalty for any lock period under 3 years is less than 75%, even in the event that the user withdraws immediately after locking. This could lead to gamification where users planning to withdraw will lock the veYFI for shorter durations instead of 4 years. The inverse scenario could also cause a problem. Users receive a 100% credit for deposits with a four year lock but only a 75% burn. If there is a scenario where the benefit of a temporary deposit is &gt; 75% of the deposit, a user should do a max lock and then take the burn. For example, if a proposal put forth for a vote could allow a user to drain a contract, it could be profitable for a user to deposit sufficient funds to have &gt; 50% of the voting power and to retrieve 25% of their deposit plus what can be drained from the contract. This attack vector would most likely happen when a user has advanced knowledge that a vote is upcoming (YIP proposals and related discussion are often public). The user could stake YFI for a specific vote (either a governance or gauge vote) where they may disproportionately benefit. This vector may be unique to veYFI compared to other ve protocols because veYFI does not apply protective measures that other protocols use. Curve does not allow for early withdrawal of locked veCRV, which protects against this scenario. Convex allows for vote delegation, similar to veYFI, but adds a 16 week cooldown period before the locked tokens can be used for voting, making this attack vector less likely due to the advanced planning necessary. https://docs.convexfinance.com/convexfinance/general-information/voting-and-gauge-weights/vote-locking . The risk for this vector is increased when combined with finding Low #3, because Low #3 outlines an approach that could enable the user paying the penalty to receive some of their penalty back in rewards. Proof of concept . The penalty_ratio equation https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L570 . Impact . Medium. The penalty calculation could be gameable because incentives are not properly aligned towards long-term locking of veYFI with the existing penalty calculations. Recommendation . Consider modifying the function so that the penalty ratio is a function of the time_left to locked duration, not a function of the ratio of the time_left to 4 years. This could reduce gamification by increasing the penalty cost in this type of attack. The modified code below is a draft and should be thoroughly tested, but it is intended to provide results of: . | If a user hypothetically locks for 4 years and withdraws in their first year, 75% penalty (same as before) | If a user hypothetically locks for 1 year and withdraws immediately, 75% penalty. With the old equation, the penalty was closer to 25% penalty_ratio: uint256 = min(MULTIPLIER * 3 / 4, MULTIPLIER * time_left / (block.timestamp - user_point_history__ts(msg.sender, self.user_point_epoch[msg.sender]))) . | . Require tokens to be locked for a certain time before (and possibly after) allowing voting, similar to Convex. Increasing the ease of withdrawal for locked tokens, even with a penalty, can add unexpected incentives. Developer Response . Won’t fix . ",
    "url": "/reports/04-2022-veYFI/#medium-findings",
    "relUrl": "/reports/04-2022-veYFI/#medium-findings"
  },"38": {
    "doc": "04-2022-veYFI",
    "title": "Low Findings",
    "content": "1. Low - Voting delegation is missing edge case checks (engn33r) . The VoteDelegation.sol contract permits vote delegation. The delegation has an “until” value, which can be set to zero. The until value can be changed so that the new until value is greater than the old one, but the check should also confirm that the new until value is greater than block.timestamp. Otherwise the until value can be modified for a time in the past. This may cause issues in the voting logic depending how the until value is stored and used in the snapshot logic. Proof of concept . The VoteDelegation.sol contract permits an until variable value of zero if the tokens are not locked. Any until variable value that is less than block.timestamp should have no impact on voting or delegation. But if the until value starts at zero, it is possible for the value to be increased to a value less than block.timestamp to reference a time in the recent past, but still have no impact. It is possible that the voting logic, which is not within the scope of these solidity contracts, may not properly consider this edge case. This edge case can be solved by adding a check in all functions that modify the until state variable, including _delegate() and increaseDelegationDuration(), to validate require(until &gt; block.timestamp). An exception could be made for an until value of zero, resulting in a require statement that looks like require(_until &gt; block.timestamp || _until == 0). Another edge case is a situation where the until value is set to a time beyond the lock expiration of the veYFI tokens. There is no check for to confirm until &lt; locked.end. This edge case could also happen if a user delegated votes, then withdrew their tokens to a new account where the tokens were locked and votes delegated again. It is unclear whether the off-chain voting mechanism will handle this edge case, which could allow multiple votes from a single token. Otherwise, consider adding the check require(_until &lt; locked.end). Impact . Low. Risk may be greater depending on the off-chain voting logic. Recommendation . Add logic checks into the VoteDelegation.sol contract to prevent mistakes with the off-chain voting logic that results in unexpected edge cases. Developer Response . The VoteDelegation.sol contract has been removed in PR #137. 2. Low - Sawtooth Wave Effect from Computing veYFI Balance and Supply Using Different Time Scales (NibblerExpress) . The boosted balance for rewards is computed as balance * 0.4 + totalSupply * veYFIBalance / veYFITotalSypply * 0.6. (Typo in veYFITotalSupply is copied from comment in L284 of Gauge.) Most voting escrow functions truncate time stamps down to the most recent week. This includes the function used to compute total supply. The veYFIBalance is not truncated to the nearest week. A user with a max lock will see their balance slowly decline over the course of a week until they can increase the lock again when the next week arrives. Because anyone can update the rewards for a user (e.g., using depositFor or getRewardsFor), an attacker can wait until the very end of a week when veYFIBalance is lowest to update the rewards for other users. Proof of concept . Equation to compute Total Supply: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L756 (t_i is truncated to a value in weeks at L748 and L750.) . Equation to compute Balance: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L677 . _t is set to block.timestamp for balance computation: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L647 . Impact . Low. The decline over the course of a week will be &lt; 0.5%, so users can boost their veYFI balance by 0.5% to avoid any attack. Also, the attack likely won’t be worth the cost of gas. This may be a small annoyance for users depositing amounts close to the cutoff for full rewards. Recommendation . The balance calculation could be truncated to the nearest week like the calculations in Total Supply and other functions. Developer Response . Won’t fix, boost is not snapshotted on deposit and won’t change until next interaction with the pool (withdraw, deposit, claim). 3. Low - Equal penalty reward distribution not incentive aligned (engn33r, NibblerExpress) . When a user withdraws the locked veYFI from VotingEscrow.vy early, the penalty fee is redistributed in the rewards pool for that week. The rewards are distributed evenly to all reward recipients, and are not distributed by the veYFI weights or locking period of each veYFI holder. There is an incentive to actively deposit and withdraw after a penalty fee is received by the veYFI protocol while the rewardPerToken is increased. This can lead to backrunning opportunities when a penalty fee is paid. There is another penalty fee applied in Gauge.sol when _updateReward() is called using the updateReward modifier. This penalty will be non-zero any time that the tokens are not locked for 4 years. If a user was going to pay the Gauge.sol penalty and was looking to extract some of their penalty payment, they can plan ahead to stay under the 120% limit imposed by queueNewRewards() in BaseGauge.sol. This is slightly similar to this Solidly issue, but this veYFI issue only impacts penalty fee payouts, not gauge reward payouts: https://github.com/belbix/solidly/issues/1 . Proof of concept . A discussion for this issue was started by someone from Ribbon Finance (who forked the veYFI code) before the review ended in veYFI Issue 135 and a fix is being developed in PR #136. The issue is centered around how penalty fees paid in VotingEscrow.vy and Gauge.sol are redistributed to users. Impact . Low. The rewards payout from a penalty is not well distributed, but users are incentivized to lock for MAX_TIME and not to withdraw early to avoid penalties. Recommendation . Improve the reward distribution of penalty fees, which is a difficult problem to resolve. Paying out penalty fees slowly over a longer time period instead of adding the funds to the current epoch reward pool would reduce the chances that a large amount of penalty fees could be extracted quickly. Developer Response . The amount of veYFI a user lock is based on the duration of the lock making really short locks close to negligeable. The contract distributing rewards to veYFI has been entirely changed in PR #136. 4. Low - No penalty during migration (engn33r) . The _lockingRatio() function of Gauge.sol returns a ratio based on the amount of time the user has locked their ve tokens. The maximum value for this ratio is PRECISON_FACTOR, which is when a user locks their ve tokens for MAX_TIME. A user can also have a PRECISON_FACTOR locking ratio when the ve token contract is undergoing migration and the contract owner has not call setVe() yet to point to the new ve token contract. A user can take advantage of this edge case. For example, any function with the updateReward modifier will calculate a penalty of zero when a ve token migration is ongoing, regardless of how long a user has locked their tokens. Proof of concept . The _lockingRatio() function returns PRECISON_FACTOR, equivalent to locking for the MAX_TIME value, when the ve token is undergoing migration: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L221 . Instead, it would be better to revert in this case so that the ve token can be finished without any users taking advantage of this edge case. Impact . Low. This is a rare edge case but should be handled properly. Recommendation . Change the behavior of the _lockingRatio() function to revert during migration to allow the owner to call setVe() with the new ve token address. Developer Response . Won’t fix . ",
    "url": "/reports/04-2022-veYFI/#low-findings",
    "relUrl": "/reports/04-2022-veYFI/#low-findings"
  },"39": {
    "doc": "04-2022-veYFI",
    "title": "Gas Savings Findings",
    "content": "1. Gas - Using “unchecked” (engn33r) . In setDuration() of BaseGauge.sol, we know periodFinish &gt; block.timestamp so we can use the “unchecked” clause for gas savings. The same improvement can be used in Gauge.sol. Proof of concept . The relevant code block . if (block.timestamp &lt; periodFinish) { uint256 remaining = periodFinish - block.timestamp; . Applying unchecked for gas savings, this code would look like . if (block.timestamp &lt; periodFinish) { unchecked { uint256 remaining = periodFinish - block.timestamp; } . BaseGauge.sol line that can be unchecked https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L79 . Gauge.sol line that can be unchecked https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L229 . Impact . Gas savings . Recommendation . Use unchecked where there is no overflow or underflow risk . Developer Response . Won’t fix . 2. Gas - Using simple comparison (engn33r) . Using a compound comparison such as ≥ or ≤ uses more gas than a simple comparison check like &gt;, &lt;, or ==. Compound comparison operators can be replaced with simple ones for gas savings. Proof of concept . The _notifyRewardAmount() function in BaseGauge.sol contains https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L170-L177 . if (block.timestamp &gt;= periodFinish) { rewardRate = reward / duration; } else { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rewardRate; reward = reward + leftover; rewardRate = reward / duration; } . By switching around the if/else clauses, we can replace the compound operator with a simple one . if (block.timestamp &lt; periodFinish) { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rewardRate; reward = reward + leftover; rewardRate = reward / duration; } else { rewardRate = reward / duration; } . Impact . Gas savings . Recommendation . Replace compound comparison operators with simple ones for gas savings . Developer Response . Won’t fix . 3. Gas - Use prefix in loops (engn33r) . Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements. The gas savings comes from the removal of a temporary variable. The value of j++ is 1 but the value of j equals 2, which means two distinct values must be stored. In comparison, both j and ++j equal 2 when using ++j. Proof of concept . There are 4 instances of this in Gauge.sol and 1 instance in VoteDelegation.sol . | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L161 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L357 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L386 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L511 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VoteDelegation.sol#L121 | . Impact . Gas savings . Recommendation . Increment with prefix addition and not postfix in for loops. Developer Response . Fixed . 4. Gas - Payable functions can save gas (engn33r) . If there is no risk of a function accidentally receiving ether, such as a function with the onlyOwner modifier, this function can use the payable modifier to save gas. Proof of concept . The following functions have the onlyOwner modifier and can be marked as payable . | setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L49 | addVaultToRewards() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L67 | removeVaultFromRewards() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L94 | setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L30 | setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L110 | setDuration() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L73 | sweep() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L111 | . Impact . Gas savings . Recommendation . Mark functions that have onlyOwner as payable for gas savings. This might not be aesthetically pleasing, but it works. Developer Response . Won’t fix . 5. Gas - Use != 0 for gas savings (engn33r) . Using &gt; 0 is less gas efficient than using != 0 when comparing a uint to zero. This improvement does not apply to int values, which can store values below zero. Proof of Concept . Four instances of this were found . | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L353 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L382 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L497 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L123 | . Impact . Gas savings . Recommendation . Replace &gt; 0 with != 0 to save gas. Developer Response . Fixed . 6. Gas - Use Solidity errors in 0.8.4+ (engn33r) . Using solidity errors is a new and more gas efficient way to revert on failure states . | https://blog.soliditylang.org/2021/04/21/custom-errors/ | https://twitter.com/PatrickAlphaC/status/1505197417884528640 | . Proof of Concept . Require statements are used throughout the contracts and error messages are not used anywhere. Using this new solidity feature can provide gas savings on revert conditions. Impact . Gas savings . Recommendation . Add errors to replace each require() with revert errorName() for greater gas efficiency. Developer Response . Won’t fix . 7. Gas - Declare functions external for gas savings (engn33r) . The boostedBalanceOf function and deposit function of Gauge.sol should be declared external, not public, for gas savings. Proof of concept . There are two public functions that can be external . | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L287 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L317 | . Impact . Gas savings . Recommendation . Declare functions as an external functions for gas savings. Developer Response . Fixed . 8. Gas - Remove Aragon calls for gas savings (engn33r) . The VotingEscrow.vy contract contains some functions that primarily serve as compatibility interfaces when using Aragon. If Aragon compatibility is not needed, these functions can be removed. Proof of concept . The following functions include comments indicating they are fulling or partially used for Aragon compatibility, and may not otherwise be necessary: . | version state variable and _version init parameter https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L155 | controller() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L129-L131 | transfersEnabled() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L129-L131 | balanceOf() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L650 | totalSupply() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L772 | changeController() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L831-L837 | . Impact . Gas savings . Recommendation . Remove unnecessary functionality copied from the original Curve contract for gas savings. This was mentioned to veYFI devs while the review was ongoing and a fix was carried out before the review concluded in PR 131, although the balanceOf() and totalSupply() functions were left unchanged. Developer Response . Fixed . 9. Gas - Inconsistent zero case in VotingEscrow.vy (engn33r) . The VotingEscrow.vy contract has two similar functions, balanceOfAt() and balanceOf(), which have been modified from the original Curve contract. The upoint.bias zero case is handled differently in the two functions. Using the lower gas solution in both would be better. Proof of concept . The balanceOf() function uses this code: . if upoint.bias &lt; 0: upoint.bias = 0 return convert(upoint.bias, uint256) . while the balanceOfAt() function uses this code: . if upoint.bias &gt;= 0: return convert(upoint.bias, uint256) else: return 0 . Impact . Gas savings . Recommendation . Use the balanceOfAt() function’s if/else code in balanceOf() to avoid calling convert() for the zero case. Developer Response . Won’t fix, disputed. I think this is not correct and the gas usage is the same. 10. Gas - Remove duplicated code (engn33r) . The BaseGauge.sol queueNewRewards() function contains duplicated code. This can be simplified to save on deployment and reduce code complexity. There might be slightly more gas spent on function calls where block.timestamp &gt;= periodFinish because unnecessary math for elapsedSinceBeginingOfPeriod and distributedSoFar will be performed in this case, but deployment gas may be important because the BaseGauge.sol contract is inherited in many places. Proof of concept . The logic for the case block.timestamp &gt;= periodFinish and (distributedSoFar * 12) / 10 &lt; _amount is the same, so they can be placed into the same if statement. | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L146-L150 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L156-L162 | . The revised queueNewRewards() function can look like this . function queueNewRewards(uint256 _amount) external override returns (bool) { require(_amount != 0, \"==0\"); SafeERC20.safeTransferFrom( IERC20(rewardToken), msg.sender, address(this), _amount ); emit RewardsQueued(msg.sender, _amount); _amount = _amount + queuedRewards; uint256 elapsedSinceBeginingOfPeriod = block.timestamp - (periodFinish - duration); uint256 distributedSoFar = elapsedSinceBeginingOfPeriod * rewardRate; // we only restart a new week if _amount is 120% of distributedSoFar. if (block.timestamp &gt;= periodFinish || (distributedSoFar * 12) / 10 &lt; _amount) { _notifyRewardAmount(_amount); queuedRewards = 0; } else { queuedRewards = _amount; } return true; } . Impact . Gas savings . Recommendation . Use simplified code from above. Developer Response . Won’t fix. This will save deployement gas but creates and computes two variables that might not be needed. 11. Gas - SLOAD gas savings (engn33r) . The BaseGauge.sol setDuration() function can use a minor gas savings. Proof of concept . Existing code https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L80-L84 . Modified code to use local variable instead of state variable in emit . if (block.timestamp &lt; periodFinish) { uint256 remaining = periodFinish - block.timestamp; uint256 newRate = remaining * rewardRate / newDuration; rewardRate = leftover; } duration = newDuration; emit DurationUpdated(newDuration, newRate); . A similar type of improvement can be made in Registry.sol https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L95-L96 The code can be modified to . address gauge = gauges[_vault]; require(gauge != address(0x0), \"!exist\"); . Impact . Gas savings . Recommendation . Use modified code snippets above. Developer Response . Fixed . ",
    "url": "/reports/04-2022-veYFI/#gas-savings-findings",
    "relUrl": "/reports/04-2022-veYFI/#gas-savings-findings"
  },"40": {
    "doc": "04-2022-veYFI",
    "title": "Informational Findings",
    "content": "1. Informational - SafeERC20 functions not used (engn33r) . The ERC20 approve() function is used several times, but there can be security benefits to using the safeIncreaseAllowance() and safeDecreaseAllowance() functions instead to prevent double spend attacks. This improvement was noted in issue 69 but was not properly applied. Proof of concept . Gauge.sol line 500 =&gt; rewardToken.approve(address(veToken), reward); Gauge.sol line 527 =&gt; IERC20(rewardToken).approve(veYfiRewardPool, toTransfer); VeYfiRewards.sol line 140 =&gt; rewardToken.approve(address(veToken), reward); . Impact . Informational. The return value is not checked so it is possible that an error occurs and the code doesn’t revert when it should. The risk may be elevated if the rewardToken is an arbitrary ERC20 token. Recommendation . Use the safeIncreaseAllowance() and safeDecreaseAllowance() functions if there is a possibility that the ERC20 tokens getting approved may not revert when an approve call fails. Developer Response . Won’t fix . 2. Informational - Unspecified Voting Requirements (engn33r) . Voting on snapshot.org requires a voting strategy to be selected for each proposal, and no voting strategy is chosen for veYFI yet. veYFI is borrowing significantly from Curve and may use the same erc20-balance-of voting strategy, but there are some differences between veYFI and Curve (veYFI supports vote delegation, Curve does not) and some of the veYFI contract code makes assumptions about how the off-chain voting strategy will work. If these contract assumptions do not match how the voting strategy actually works, the off-chain voting process may not align with how the on-chain code intends. Proof of concept . There are built-in voting assumptions in the contract code, mostly borrowed from Convex: . | When a proposal is created, the checkpoint() function in VotingEscrow.vy should be called to properly set the epoch | Voting power should be calculated using the on-chain functions such as get_last_user_slope(), balanceOf(), balanceOfAt(), supplyAt(), totalSupply(), and totalSupplyAt() in VotingEscrow.vy. Note that some of the math in these calculations could be moved to an off-chain voting strategy for gas savings | Voting for a proposal with veYFI is allowed as soon as the veYFI is locked. Because there is potential for gamification in increasing veYFI stake shortly before key votes, protocols like Convex have implemented a minimum locking duration of several weeks before a token holder can vote, which is implemented in their VotingEligibility.sol contract. | . Some open and unanswered questions include: . | Who is allowed to create proposals on snapshot.org? | How are the results of each snapshot vote converted to on-chain rewards? Is this automated? | Will all vaults receive a gauge that can be voted for on snapshot.org, even those holding very little value? If so, this could lead to gamification of deprecated or old vaults. | Is there a maximum allocation a gauge can receive? Is there minimum quorum for governance votes? Convex specifies these values: https://docs.convexfinance.com/convexfinance/general-information/voting-and-gauge-weights | . Impact . Informational. Because the off-chain voting is heavily interconnected with the on-chain contracts and unresolved questions leave risk around implementation errors in the off-chain voting proposal or strategy process. Recommendation . Several items should be considered: . | Choose an off-chain voting strategy from snapshot.org and outline all the assumptions for the voting process. veYFI is borrowing heavily from Convex, but using the same erc20-balance-of snapshot.org strategy should be thoroughly analyzed given the protocol and liquidity differences between Yearn Finance and Curve. | Determine whether the gamification risks that Convex attempts to prevent with their voting caps and voting eligibility requirements are problematic enough to add similar modifications to veYFI. | Consider automatic on-chain execution strategies to reduce centralization risk as outlined in: https://blog.aragon.org/snapshot/ | . Developer Response . Will fix with snapshot.org integration . 3. Informational - Variable naming inconsistency (engn33r) . The first input to the createGauge() is named vault, and is passed to Gauge.sol initialize(). In initialize(), this value is named _stakingToken. If the goal is to allow gauges to correspond to liquidity pools that are NOT yearn vaults, the naming should be consistent through veYFI, otherwise future edits may be made assuming that only yearn vaults are involved. This was mentioned in a comment in issue 46. Proof of concept . The first input to initialize() has the following comment https://github.com/yearn/veYFI/blob/d53465c5f615a04204faed55728840a1e79377fc/contracts/Gauge.sol#L67 _stakingToken The vault token to stake . Elsewhere in veYFI, the naming convention assumes that each gauge corresponds to one Yearn vault. But the name _stakingToken and the comment in issue 46 indicates this might not be correct. This should be clarified in the comments and the variable names. Impact . Informational . Recommendation . If the intention is to limit the value of this input to only permit Yearn vaults, consider verifying whether the vault is in the list of addresses from the assetsAddresses() function of the AddressesGeneratorV2Vaults contract https://github.com/yearn/yearn-security/blob/master/SECURITY.md#production-contracts . Otherwise, if this value will not be limited to Yearn vaults, consider renaming the variables that use the word “vault” or add comments in multiple places to clarify this address may not be a yearn vault. Developer Response . Fixed . 4. Informational - Missing 0 check in setDuration() (engn33r) . There is no zero check in setDuration() in BaseGauge.sol. If a duration of zero is chosen, functions like _notifyRewardAmount() that divide by the duration will revert with a divide by zero error. Zero checks exist on all similar setter functions. Proof of concept . If block.timestamp &lt; periodFinish, then the code will check if newDuration is zero, but this check will not happen if the if statement is skipped when block.timestamp &gt; periodFinish https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L73 . This can cause problems in other functions that divide by the duration https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L170-L177 . Impact . Informational. If the duration is set to zero the owner can change the value to a new non-zero value later . Recommendation . Add a zero check in the setDuration() function with require() . Developer Response . Fixed . 5. Informational - Typos (engn33r) . There are some typos that have no impact on code functionality, but fixes could be considered improvements. Proof of concept . | The MAX_DELAGATED variable should be spelled MAX_DELEGATED https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VoteDelegation.sol#L16 | betwwen should be between https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L324 | The last sentence in the ExtraReward.sol contract needs to be fixed, most likely by removing the words “Gauge will”. It reads “Gauge will this contract is used behind multiple delegate proxies.” https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L13-L14 | “claimm veYFI and aditional reward” should be “claim veYFI and additional reward” (two typos) https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L373 | Triger should be Trigger https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L131 | veYFITotalSypply should be veYFITotalSupply https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L284 | “rewards are distributed during 7 days” should says “rewards are distributed during reward duration” because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L12 | “over a week” should say “over the reward duration” because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L130 | “restart a new week” should say “restart a new reward duration” because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L154 | A reference to CRV exists in the vyper code. Change ERC20CRV to ERC20YFI https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L152 | “earning for an account” should be “earnings for an account” https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L248-L249 | “address acccount” should be “address account” https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L219 | . Impact . Informational . Recommendation . Fix typos . Developer Response . Fixed . 6. Informational - Replace magic numbers with constants (engn33r) . Constant variables should be used in place of magic numbers to prevent typos. The magic number 1e18 is found in multiple places in YieldStreamer.sol and should be replaced with a constant. Using a constant also adds a description using the variable name to explain what this value is for. Proof of concept . The value 1e18 appears throughout the contracts . | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L62 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L69 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L245 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L274 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L280 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L75 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L86 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L92 | . Impact . Informational . Recommendation . Use constant variables instead of magic numbers. Developer Response . Fixed . 7. Informational - Code inconsistency (engn33r) . There are three _updateReward() functions in veYFI. The Gauge.sol _updateReward() function includes a check if (_balances[account] != 0) while the other two functions do not. It is unclear if this check should be added to the other functions or can be removed from Gauge.sol, but the developers should compare these three implementations for differences. Proof of concept . The three different _updateReward() functions . | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L44 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L36 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L183 | . Impact . Informational . Recommendation . Use consistent logic in similar functions. Developer Response . This is to distribute veYFI incentives which only applies the Gauge. 8. Informational - Curve safety check removed (engn33r) . There is a check in Curve’s VotingEscrow.vy to prevent contracts from calling certain functions related to increase the amount of locked ve tokens. This is most likely to prevent a rare scenario where a perfect storm is created when: . | A user has granted the ve token contract infinite allowance | The user has a large amount of tokens that they purposefully have not locked | The user interact with a malicious contract that acts as a proxy to lock the user’s tokens in the ve token contract | . If this sequence of events occurs, the user will not be able to withdraw their locked tokens without a loss of value. However, this is a minor problem compared to most interactions with malicious contracts, so it may be reasonable to remove this check and allow contract interaction with these functions. Proof of concept . This is the check in Curve: . | https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418 | https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438 | https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455 | . The check does not exist in the same locations in the veYFI VotingEscrow contract: . | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L458 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L496 | https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L512 | . If this check is added to veYFI, it should also be added to createLockFor, a function that Curve does not have: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L477 . Impact . Informational. This check only adds value if a user interacts with a malicious contract and has non-zero allowance to transfer to the veYFI contract which is an extreme edge case that doesn’t necessarily need special handling. Recommendation . Consider reintroducing the self.assert_not_contract(msg.sender) check found in the original Curve code in the locations mentioned above. Developer Response . The checks are to prevent contract to tokenize crv locks unless they are whitelisted. 9. Informational - No migrateLock sample implementation (engn33r) . The veYFI contract can be migrated. The migrator contract will need to implement the migrateLock() function, which is called by the existing implementation of veYFI. No sample implementation of this function is in veYFI, meaning that a core piece of the migration functionality was not examined in this review. Proof of concept . The migrateLock() call in the existing veYFI code: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L606 . Impact . Informational . Recommendation . Consider creating a reference implementation for the migrateLock() function before deploying veYFI so any last minute changes in veYFI that can make the lock migration easier can be handled in advance. This is especially important if the migrate function might be used in an emergency situation. Developer Response . That will be done when needed. 10. Informational - Use -= to keep code concise (engn33r) . The withdraw() function of Gauge.sol can use -= to reduce code complexity. Proof of concept . The += operator is used often in veYFI, but the -= operator is not used in this line https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L391 . _balances[msg.sender] = _balances[msg.sender] - _amount; . Consider changing this line to . _balances[msg.sender] -= _amount; . Impact . Informational . Recommendation . Use -= when available for concise code. Developer Response . Fixed . 11. Informational - Update rewards for other users (engn33r) . The depositFor() function in Gauge.sol allows the _updateReward() function to be called for other depositors. This may lead to an attack where a depositor in a gauge finds a way to reduce the rewards for other depositors of the same gauge, possibly similar to the flash loan method mentioned in Medium #3, and calling depositFor() with an extremely small value to trigger _updateReward() to update the checkpoint for the other depositors. The attacker may be able to take more rewards from the gauge than they could otherwise. This was noticed at the very end of the review so examination of an attack vector was not performed. Proof of concept . The depositFor() function: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L344 . Impact . Informational . Recommendation . If there is no strong use case for depositFor(), removing this function would be the safest approach. Developer Response . An approval mechanism has been added to the contract to whitelist addresses that has been allowed to deposit on your behalf: https://github.com/yearn/veYFI/blob/83d62f9e03ef0cc463aa31c36ce23cd3d7c184eb/contracts/Gauge.sol#L376 . ",
    "url": "/reports/04-2022-veYFI/#informational-findings",
    "relUrl": "/reports/04-2022-veYFI/#informational-findings"
  },"41": {
    "doc": "04-2022-veYFI",
    "title": "Final remarks",
    "content": "engn33r . I focused on the voting mechanics because there have been bugs here on similar projects. Once the voting implementation is fully completed and reviewed, I think veYFI will look more solid. There are some minor edge cases in the rewards system that can be ironed out, but the most critical deposit, withdraw, lock, and rewards functions look like they have been thoughtfully pieced together into a cohesive solution. Improvements to the overall documentation of the veYFI contracts and inclusion of similar protective measures to Convex are nice-to-have improvements. NibblerExpress . I looked for ways to attack the deposit, withdraw, and reward functions to receive excess rewards or to block others from receiving rewards. I was unable to find attacks that circumvented the reward checkpointing or that manipulated the voting escrow contract. The problems seemed to be in how rewards were actually calculated. The reward formula should be reviewed to ensure that the contract is more precisely incentivizing the desired behaviors. I did not take a close look at how voting would occur outside the contract and what mischief could be caused by malicious proposals. ",
    "url": "/reports/04-2022-veYFI/#final-remarks",
    "relUrl": "/reports/04-2022-veYFI/#final-remarks"
  },"42": {
    "doc": "04-2022-veYFI",
    "title": "About yAcademy",
    "content": "yAcademy is an ecosystem initiative started by Yearn Finance and its ecosystem partners to bootstrap sustainable and collaborative blockchain security reviews and to nurture aspiring security talent. yAcademy includes a fellowship program and a residents program. In the fellowship program, fellows perform a series of periodic security reviews and presentations during the program. Residents are past fellows who continue to gain experience by performing security reviews of contracts submitted to yAcademy for review (such as this contract). ",
    "url": "/reports/04-2022-veYFI/#about-yacademy",
    "relUrl": "/reports/04-2022-veYFI/#about-yacademy"
  },"43": {
    "doc": "04-2022-veYFI",
    "title": "Appendix and FAQ",
    "content": " ",
    "url": "/reports/04-2022-veYFI/#appendix-and-faq",
    "relUrl": "/reports/04-2022-veYFI/#appendix-and-faq"
  },"44": {
    "doc": "04-2022-veYFI",
    "title": "04-2022-veYFI",
    "content": " ",
    "url": "/reports/04-2022-veYFI/",
    "relUrl": "/reports/04-2022-veYFI/"
  },"45": {
    "doc": "05-2022-OpenMEV",
    "title": "yAcademy OpenMEV review",
    "content": "Review Resources: Wiki Docs and whitepaper . Residents: . | Jackson | engn33r | . ",
    "url": "/reports/05-2022-OpenMEVRouter/#yacademy-openmev-review",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#yacademy-openmev-review"
  },"46": {
    "doc": "05-2022-OpenMEV",
    "title": "Table of Contents",
    "content": ". | Review Summary | Scope | Code Evaluation Matrix | Findings Explanation | High Findings . | 1. High - The swap and stake mechanisms in OpenMevZapper leave funds in the contract (Jackson) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 2. High - Using normal functions for fee-on-transfer tokens causes value loss (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 3. High - Backrun arb not designed for fee-on-transfer tokens (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | . | Medium Findings . | 1. Medium - Failed flashloan arbitrage reverts the original swap (Jackson) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | . | Low Findings . | 1. Low - Edge case suboptimal arb profit (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 2. Low - One failed arb can revert otherwise profitable arb (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 3. Low - Max approval granted to spender (Jackson) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 4. Low - No check For Aave flashloan balance (Jackson) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | . | Gas Savings Findings . | 1. Gas - Use _isNonZero() for gas savings (engn33r) . | Proof of Concept | Impact | Recommendation | Developer response (Sandy) | . | 2. Gas - Use _inc() instead of ++ and _dec() instead of -- (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 3. Gas - Bitshifting is cheaper than multiplication or division (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 4. Gas - Unnecessary zero initialization (engn33r) . | Proof of Concept | Impact | Recommendation | Developer response (Sandy) | . | 5. Gas - Payable functions can save gas (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 6. Gas - Avoid &amp;&amp; logic in require statements (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 7. Gas - Declare constant internal when possible (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 8. Gas - Replace require with errors in OpenMevRouter (Jackson) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 9. Gas - Remove unused code (Jackson) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 10. Gas - Use simple comparison (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 11. Gas - Combine reserve value checks (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 12. Gas - Use msg global vars directly (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 13. Gas - Remove duplicate internal function call (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 14. Gas - deadline special case not aligned with permit (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 15. Gas - Replace pair.swap() with _asmSwap() (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 16. Gas - Remove a sortTokens call (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 17. Gas - Missing curly brace (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 18. Gas - Reduce number of swaps (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 19. Gas - Revert if zero flashloan profit (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | . | Informational Findings . | 1. Informational - OpenMevRouter should inherit from IFlashBorrower and IOpenMevRouter (Jackson) . | Impact | Developer response (Sandy) | . | 2. Informational - The ETHERSCAN_API key is present in plaintext (Jackson) . | Impact | Developer response (Sandy) | . | 3. Informational - SafeTransferLib does not match Solmate’s main branch (Jackson) . | Impact | Developer response (Sandy) | . | 4. Informational - Incorrect comment (engn33r, Jackson) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 5. Informational - Replace magic numbers with constants (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 6. Informational - Typos (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 7. Informational - Hard coded Aave token list (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 8. Informational - Inconsistency in WETH transfers (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 9. Informational - safeApprove vulnerable to double withdraw (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 10. Informational - Same frontrunning weaknesses as Uniswap/SushiSwap (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 11. Informational - Kashi flashloanable tokens assumed same as aave (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | 12. Informational - (engn33r) . | Proof of concept | Impact | Recommendation | Developer response (Sandy) | . | . | Final remarks . | engn33r | Jackson | . | About yAcademy | Appendix and FAQ | . ",
    "url": "/reports/05-2022-OpenMEVRouter/#table-of-contents",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#table-of-contents"
  },"47": {
    "doc": "05-2022-OpenMEV",
    "title": "Review Summary",
    "content": "OpenMEV . The purpose of OpenMEVRouter is to offer a drop-in replacement to a similar Uniswap/SushiSwap router. While enabling exchanges with UniSwap and SushiSwap, it also protects against direct MEV arbitrage (arb) between the two platforms by performing the arb within the DEX swap process. This leaves no arbitrage opportunities for MEV searches. The main branch of the OpenMEV Repo was reviewed over 22 days, 4 of which were used to create an initial overview of the contract. The code review was performed between May 12 and June 3, 2022. The code was reviewed by 2 residents for a total of 59 man hours (engn33r: 34 hours, and Jackson 25 hours). The repository was under active development during the review, but the review was limited to one specific commit. ",
    "url": "/reports/05-2022-OpenMEVRouter/#review-summary",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#review-summary"
  },"48": {
    "doc": "05-2022-OpenMEV",
    "title": "Scope",
    "content": "Code Repo Commit . The commit reviewed was 8648277c0a89d0091f959948682543bdcf0c280b. The review covered the entire repository at this specific commit but focused on the contracts directory. After the findings were presented to the OpenMEV team, fixes were made and included in several PRs. The review was a time-limited review to provide rapid feedback on potential vulnerabilities. The review was not a full audit. The review did not explore all potential attack vectors or areas of vulnerability and may not have identified all potential issues. yAcademy and the residents make no warranties regarding the security of the code and do not warrant that the code is free from defects. yAcademy and the residents do not represent nor imply to third parties that the code has been audited nor that the code is free from defects. Manifold and third parties should use the code at their own risk. ",
    "url": "/reports/05-2022-OpenMEVRouter/#scope",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#scope"
  },"49": {
    "doc": "05-2022-OpenMEV",
    "title": "Code Evaluation Matrix",
    "content": "| Category | Mark | Description | . | Access Control | Good | The onlyOwner modifier was only applied to the harvest() function. Access controls existed on the relevant callback functions in OpenMevRouter.sol for flashloans. msg.sender is properly used so that the user cannot perform actions they should not be able to. Access controls are applied where needed. | . | Mathematics | Average | Solidity 0.8.13 is used, which provides overflow and underflow protect. There was no unusually complex math beyond the Uint512 library. The sqrt512() function using the Karatsuba Square Root method is an unusual and potentially custom implementation. | . | Complexity | Average | Many function names and implementations are borrowed from UniswapV2 contracts and BeefySwap’s zapper. This reduces the amount of custom development work necessary. The primary source of complexity is the backrun swap arb process and the equations derived for that purpose. | . | Libraries | Good | A custom OpenMevLibrary contract is based heavily on the UniswapV2Library contract. The Uint512 contract supports math operations for uint512 integers comprised of two uint256 integers. SafeTransferLib and ERC20 libraries are imported by OpenMevRouter but are commonly used contracts. | . | Decentralization | Good | The onlyOwner modifier on the harvest() function indicates there is some centralization risk, but it is expected that Sushi governance will take this role and can be considered a trusted party. | . | Code stability | Good | Changes were reviewed at a specific commit hash and the scope was not expanded after the review was started. The code reviewed had nearly all features implemented. | . | Documentation | Good | Descriptive NatSpec comments are found throughout the OpenMevRouter contracts. The comments accurately describe the function purpose and function input/output arguments. | . | Monitoring | Average | Only _backrunSwaps() emitted an event. However, the UniswapV2 Router does not emit any events and the OpenMevRouter contracts prioritize gas savings, so additional events may not be necessary. | . | Testing and verification | Average | Brownie tests and foundry tests were written. The foundry tests were more comprehensive that the brownie tests, but getting the exact test coverage numbers with foundry is still a work in progress at the time this review was performed. The coverage could be improved to test for the edge cases introduced by modifications to the forked Uniswap and BeefySwap contracts as demonstrated by the findings. | . ",
    "url": "/reports/05-2022-OpenMEVRouter/#code-evaluation-matrix",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#code-evaluation-matrix"
  },"50": {
    "doc": "05-2022-OpenMEV",
    "title": "Findings Explanation",
    "content": "Findings are broken down into sections by their respective impact: . | Critical, High, Medium, Low impact . | These are findings that range from attacks that may cause loss of funds, impact control/ownership of the contracts, or cause any unintended consequences/actions that are outside the scope of the requirements | . | Gas savings . | Findings that can improve the gas efficiency of the contracts | . | Informational . | Findings including recommendations and best practices | . | . ",
    "url": "/reports/05-2022-OpenMEVRouter/#findings-explanation",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#findings-explanation"
  },"51": {
    "doc": "05-2022-OpenMEV",
    "title": "High Findings",
    "content": "1. High - The swap and stake mechanisms in OpenMevZapper leave funds in the contract (Jackson) . Half of the input amount in both swapAndStakeLiquidity and swapETHAndStakeLiquidity is used as the swapAmountIn when atomically swapping and staking. However, this leaves funds in the contract due to the reserve asset ratio change post-swap. See “Optimal One-sided Supply to Uniswap” for more information. Proof of concept . Both swapAndStakeLiquidity and swapETHAndStakeLiquidity take the input tokens or ETH sent by a user, divide it by 2, swap it into the B token, and stake these tokens as a pair. However, this approach leaves some of the B token in the contract due to the reserve asset ratio change before and after the swap. Impact . High. The funds are not returned to the user, and will likely be swept by Sushi governance during a call to harvest. Recommendation . Use the formula found in “Optimal One-sided Supply to Uniswap” for the swapAmountIn, rather than ` / 2`. sqrt( reserveIn.mul(userIn.mul(3988000) + reserveIn.mul(3988009))) .sub(reserveIn.mul(1997)) / 1994; . Developer response (Sandy) . Fixed here and here. 2. High - Using normal functions for fee-on-transfer tokens causes value loss (engn33r) . Uniswap’s code relies on the assumption that functions without direct support for fee-on-transfer tokens, like removeLiquidityETH, will revert. This assumption is invalid in OpenMevRouter. The difference is that Uniswap routers are designed to not hold token balance, which the etherscan token balance confirms. In comparison, the docs for OpenMevRouter.sol show it stores value that is later collected with the harvest() function. If enough fee-on-transfer tokens are held by the OpenMevRouter contract, functions such as removeLiquidityETH() can be called instead of removeLiquidityETHSupportingFeeOnTransferTokens() and the function will not revert. This leads to the OpenMevRouter contract losing value due to the fees paid for the fee-on-transfer transfer. Proof of concept . The NatSpec comment for removeLiquidityETHSupportingFeeOnTransferTokens() includes . Identical to removeLiquidityETH, but succeeds for tokens that take a fee on transfer . The only difference in these functions, and what is implied to cause the revert condition in removeLiquidityETH(), is the amount used in safeTransfer(). removeLiquidityETH() has an amount of amountToken, while removeLiquidityETHSupportingFeeOnTransferTokens() uses ERC20(token).balanceOf(address(this)) - balanceBefore. This does cause a revert in Uniswap’s code because of the Uniswap assumption that the router holds no token balance, but OpenMevRouter can hold a token balance. The process of value loss is: . | Fee-on-transfer token is held by the router. This can happen either with an initial deposit by the Manifold team or from backrun arbitrage profits. The devs suggested the tokens that will be sent to the router will likely be tokens that Aave does not support flashloans for, which could include lesser known tokens with fee-on-transfer support. | User wants to remove liquidity from WETH-ERC20 pair where the ERC20 has a non-zero fee-on-transfer. Instead of using removeLiquidityETHSupportingFeeOnTransferTokens(), the user calls removeLiquidityETH(). | The code of removeLiquidityETHSupportingFeeOnTransferTokens() and removeLiquidityETH() is identical except for the amount in ERC20(token).safeTransfer(). The amountToken value used in removeLiquidityETH() is greater than the amount of fee-on-transfer tokens received from the removeLiquidity() call, so the amount transferred to the user will include some of the token balance that was held by the router before the user’s remove liquidity interaction. | Result: The router lost value in the form of the transfer-on-fee token | . Impact . High. Value can be lost from the router if the router stores fee-on-transfer tokens. While it may be unlikely for OpenMevRouter.sol to hold many fee-on-transfer tokens (note: USDT could become fee-on-transfer in the future), value loss would occur if the scenario does arise and no protections prevent against this. Recommendation . The router should follow the Uniswap assumptions and not store value. Instead, the profits from any arbs should be stored in a separate contract where it can be flashloaned to the router for arbitrage opportunities. This would impact the harvest() and _backrunSwaps() functions at a minimum, and most likely require some redesigning of the overall contract. If there is a preference to maintain the current design where the router holds value, add stricter checks to functions not designed for fee-on-transfer tokens. For example, a rewrite of removeLiquidityETH() logic: . ensure(deadline); address weth = WETH09; uint256 balanceBefore = ERC20(token).balanceOf(address(this)); (amountToken, amountETH) = removeLiquidity( token, weth, liquidity, amountTokenMin, amountETHMin, address(this), deadline ); if (amountToken != ERC20(token).balanceOf(address(this)) - balanceBefore) revert TokenIsFeeOnTransfer(); ERC20(token).safeTransfer(to, amountToken); IWETH(weth).withdraw(amountETH); SafeTransferLib.safeTransferETH(to, amountETH); . Developer response (Sandy) . Good find and good recommendation. Fixed. 3. High - Backrun arb not designed for fee-on-transfer tokens (engn33r) . The backrun process is performed for any swap, but the backrun process is not designed for fee-on-transfer tokens. Because the router contract may hold fee-on-transfer tokens, the router contract may lose some of this stored value to fees when performing an arb involving a fee-on-transfer token. Proof of concept . While Aave and Kashi do not currently allow flashloans on any fee-on-transfer tokens, this call of _arb() using internal router contract funds is problematic. The first and second swaps are performed with _asmSwap(), which have a safeTransfer() performed first to send the token to the pair address. It is assumed that the amountOut value calculated by OpenMevLibrary.getAmountOut() accurately stores the amount of tokens that the router contract receives from the swap process. Instead, to support fee-on-transfer tokens, a calculation of ERC20(token).balanceOf(address(this)) - balanceBefore as found in the router function removeLiquidityETHSupportingFeeOnTransferTokens() should be used. The _arb() function can even cause problems when neither the first nor last token is a fee-on-transfer token, but one of the intermediate swaps uses a fee-on-transfer token. Because the _backrunSwaps() function loops through the array of swaps, any of the backrun swaps that involve a fee-on-transfer token could be problematic. Impact . High. The router contract can lose funds when paying fees for fee-on-transfer token transfers. Recommendation . If the router is redesigned to not hold fee-on-transfer tokens, the backrun would likely revert because the math is not designed for fee-on-transfer tokens. The easiest solution is to remove the _backrunSwaps() calls when a fee-on-transfer swap is involved. Another option is to write a new _arb() function that supports fee-on-transfer arbitrage. | First instance | Second instance | Third instance | . Developer response (Sandy) . Backrun attempts have been removed from fee-on-transfer swaps. Fixed. ",
    "url": "/reports/05-2022-OpenMEVRouter/#high-findings",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#high-findings"
  },"52": {
    "doc": "05-2022-OpenMEV",
    "title": "Medium Findings",
    "content": "1. Medium - Failed flashloan arbitrage reverts the original swap (Jackson) . If one of the backrun flashloan arbitrages fails to return a profit, the original swap is reverted. Proof of concept . These lines include the revert for each flashloan [1, 2]. Impact . Medium. While this will not involve a loss of user funds, it will result it a poor user experience when user swaps are unecessarily reverted. Recommendation . Use a try-catch when executing the flashloans such that if they revert, the entire swap is not also reverted. Developer response (Sandy) . Fixed. ",
    "url": "/reports/05-2022-OpenMEVRouter/#medium-findings",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#medium-findings"
  },"53": {
    "doc": "05-2022-OpenMEV",
    "title": "Low Findings",
    "content": "1. Low - Edge case suboptimal arb profit (engn33r) . There can be cases where contractAssetBalance &gt;= optimalAmount is not true, but using the available contractAssetBalance is still cheaper than using a flashloan with a fee. For example, if contractAssetBalance = optimalAmount - 1, using contractAssetBalance will normally produce a superior result to using a flashloan. Proof of concept . The logic branch checks if contractAssetBalance &gt;= optimalAmount, otherwise a flashloan is used. Impact . Low. This is an edge case that may be rare, but can reduce the profits of the router. Hypothetically this could be gamed by liquidity providers looking to increase yield through flashloan fees on certain assets in Aave or Kashi, because the fees are paid by OpenMevRouter arb profits. Recommendation . When calculating the optimalAmount for the backrun process, account for the profit loss due to Aave or Kashi fees. Developer response (Sandy) . Acknowledged. I am looking for an efficient way to implement this logic. At first glance, it seems like it would add complexity to every backrun for a rare edge case where the profit difference is marginal. As a follow-up, I ran some tests with this check implemented in branch test/profit-edge. In short the extra gas cost for the check averaged 11,500 while there was 0 profit difference from the generic tests. Details below. Code check for edge case inserted after line 429 in OpenMevLibrary . if (optimalAmount &gt; contractAssetBalance &amp;&amp; _isNonZero(contractAssetBalance)) { uint256 _balanceReturns = calcReturns(Cb, Cf, Cg, contractAssetBalance); uint256 _fee = optimalAmount &lt;= bentoBalance ? optimalAmount * 5 / 10000 : optimalAmount * 9 / 10000; if (_balanceReturns &gt;= (optimalReturns - _fee)) { optimalAmount = contractAssetBalance; optimalReturns = _balanceReturns; } } . Test comparison: . brownie run deployAndTestGas.py --network mainnet-fork2 . Gas results: . | Gas without edge profit check | Gas with edge profit check | Gas difference | . | 113591 | 113591 | 0 | . | 87791 | 75631 | -12160 | . | 94634 | 94692 | 58 | . | 233389 | 233447 | 58 | . | 455588 | 456057 | 469 | . | 444788 | 445257 | 469 | . | 365001 | 445005 | 80004 | . | 150411 | 150411 | 0 | . | 143863 | 168183 | 24320 | . | 442431 | 442547 | 116 | . | 674209 | 675136 | 927 | . | 86431 | 98591 | 12160 | . | 86431 | 86431 | 0 | . | 184572 | 196635 | 12063 | . | 208748 | 208795 | 47 | . | 184572 | 184619 | 47 | . | 184596 | 208819 | 24223 | . | 184582 | 208805 | 24223 | . | 135411 | 135411 | 0 | . | 268015 | 268062 | 47 | . | 366412 | 403253 | 36841 | . | 560339 | 609207 | 48868 | . |   | Average extra gas | 11490 | . 2. Low - One failed arb can revert otherwise profitable arb (engn33r) . The _backrunSwaps() function may loop through multiple swaps to arbitrage each one. If one of these swaps does not have a sufficiently profitable opportunity or has a failed flashloan, the profitable opportunity from the other swaps may be missed. Proof of concept . The _backrunSwaps() function loops through the array of swaps. Imagine a scenario where _backrunSwaps() is called with a swaps array of length 4. Assume the 1st, 2nd, and 4th backrun swaps are profitable, but the 3rd backrun swap is not. Performing this series of four backrun swaps can still be net profitable even if one of the individual backrun swaps is not. The reason the 3rd backrun swap is not profitable may be because the flashloan fee costs more than the profit of this arb, which reverts here or here, or a similar revert can happen if the router contract funds are used for the arb and the amount received is less than expected. The result is the transaction reverts and OpenMevRouter will miss out on the arb profits if the swaps had been completed even if one individual backrun swap wasn’t profitable. Impact . Low. This is an edge case that may be rare, but can reduce the profits of the router. Recommendation . A single flashloan or arb opportunity resulting in no profit should not revert the entire transaction. Instead, that specific backrun swap arb should be skipped. It is not even necessary to skip an unprofitable backrun swap if there is a positive net profit that is calculated at the start of the _backrunSwaps() function. Developer response (Sandy) . Fixed for flashloan backruns with try/catch. Acknowledged as an edge case for non-flashloan backruns. Looking for a good solution to this case. 3. Low - Max approval granted to spender (Jackson) . Maximum approvals should be avoided, particularly when the necessary amount is known. Proof of concept . ERC20(token).safeApprove(spender, type(uint256).max); in _approveTokenIfNeeded approves the spend to spent the entire balance. Impact . Low. Assuming nothing problematic occurs this is not a problem. However, it is a level of protection in case of attack. Recommendation . Only approve what is necessary for the transaction when it is known prior to granting approval. Developer response (Sandy) . Fixed. 4. Low - No check For Aave flashloan balance (Jackson) . _backrunSwaps in OpenMevRouter checks that Kashi has the necessary liqudity to take a flashloan against, but does not check that Aave does as well. Proof of concept . L915 of OpenMevRouter . Impact . Low. It is unlikely that Aave will not have the necessary liquidity for the flashloan. Recommendation . Check that Aave contains the necessary liquidity at the time of the flashloan as is done for Kashi. A fix is underway in PR #40. Developer response (Sandy) . Fixed. ",
    "url": "/reports/05-2022-OpenMEVRouter/#low-findings",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#low-findings"
  },"54": {
    "doc": "05-2022-OpenMEV",
    "title": "Gas Savings Findings",
    "content": "1. Gas - Use _isNonZero() for gas savings (engn33r) . There is a gas efficient _isNonZero() function that is not used in two places. Otherwise, != 0 is preferred to &gt; 0 when comparing a uint to zero. Proof of Concept . Two instances of this were found: . | First instance | Second instance | . Impact . Gas savings . Recommendation . Replace &gt; 0 with != 0 to save gas. Even better, use the existing _isNonZero() function in OpenMevLibrary.sol. Developer response (Sandy) . Fixed. 2. Gas - Use _inc() instead of ++ and _dec() instead of -- (engn33r) . Gas efficient functions _inc() and _dec() should be used to replace normal increments and decrements. Otherwise, if these functions were not available, use prefix is preferred to postfix for gas efficiency. In other words, use ++i instead of i++. Proof of concept . There is one instance of an increment improvement. There are two instances of a double decrement that could be replaced with _dec(_decr()) or with unchecked { length - 2; }: . | First instance | Second instance | . Impact . Gas savings . Recommendation . Increment with prefix addition and not postfix in for loops. Even better, use _inc() and _dec(). Developer response (Sandy) . Fixed. 3. Gas - Bitshifting is cheaper than multiplication or division (engn33r) . Bitshifting is cheaper than multiplication or division. Multiplication and division can be replaced by a bitshift easily when a multiple of two is involved. Proof of concept . There are four instance of divide by 2 operations that can use bitshifting for gas efficiency: . | First instance | Second instance | Third instance | Fourth instance | . Impact . Gas savings . Recommendation . Replace multiplication and division by a bitshift when a power of two is involved. Developer response (Sandy) . Fixed. 4. Gas - Unnecessary zero initialization (engn33r) . Initializing an int or uint to zero is unnecessary, because solidity defaults int/uint variables to a zero value. Removing the initialization to zero can save gas. Proof of Concept . Two instances of this were found: . | First instance | Second instance | . Impact . Gas savings . Recommendation . Remove the explicit uint variable initializations to zero. Developer response (Sandy) . Fixed. 5. Gas - Payable functions can save gas (engn33r) . If there is no risk of a function accidentally receiving ether, such as a function with the onlyOwner modifier, this function can use the payable modifier to save gas. Proof of concept . The following functions have the onlyOwner modifier and can be marked as payable . | First function | Second function | Third function | . Impact . Gas savings . Recommendation . Mark functions that have onlyOwner as payable for gas savings. This might not be aesthetically pleasing, but it works. Developer response (Sandy) . Fixed. 6. Gas - Avoid &amp;&amp; logic in require statements (engn33r) . Using &amp;&amp; logic in require statements uses more gas than using separate require statements. Dividing the logic into multiple require statements is more gas efficient. Proof of concept . One instance of require with &amp;&amp; logic was found. Impact . Gas savings . Recommendation . Replace require statements that use &amp;&amp; by dividing up the logic into multiple require statements. Developer response (Sandy) . Fixed. 7. Gas - Declare constant internal when possible (engn33r) . Declaring constant with internal visibility is cheaper than public constants. This is already applied to all constants in the code except one. Proof of concept . The bento constant should be internal if possible. Impact . Gas savings . Recommendation . Make constant variables internal for gas savings. Developer response (Sandy) . Fixed. 8. Gas - Replace require with errors in OpenMevRouter (Jackson) . Two require statements can be replaced with custom errors in OpenMevRouter. Custom errors are already used elsewhere in OpenMevRouter and are more gas-efficient than require statements. Proof of concept . One instance in _addLiquidity (require(amountAOptimal &lt;= amountADesired);) and another instance in addLiquidityETH (require(IWETH(weth).transfer(pair, amountETH));, which can be replaced with safeTransfer as is done in swapExactETHForTokens). Impact . Gas savings . Recommendation . Use solidity custom errors instead of require statements. Developer response (Sandy) . Fixed. 9. Gas - Remove unused code (Jackson) . RESERVE_SELECTOR is not used in OpenMevLibrary and can be removed, neither are _require() or _revert() in OpenMevErrors. Proof of concept . | First instance | Second instance | Third instance | . Impact . Gas savings . Recommendation . Remove unused code to save gas on deployment. Developer response (Sandy) . Fixed here and here. 10. Gas - Use simple comparison (engn33r) . Using a compound comparison such as ≥ or ≤ uses more gas than a simple comparison check like &gt;, &lt;, or ==. Compound comparison operators can be replaced with simple ones for gas savings. Proof of concept . The _addLiquidity() function in OpenMenRouter.sol contains this code: . if (amountBOptimal &lt;= amountBDesired) { // require(amountBOptimal &gt;= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT'); if (amountBOptimal &lt; amountBMin) revert InsufficientBAmount(); // revert InsufficientBAmount({ available: amountBOptimal, required: amountBMin }); (amountA, amountB) = (amountADesired, amountBOptimal); } else { uint256 amountAOptimal = OpenMevLibrary.quote(amountBDesired, reserveB, reserveA); require(amountAOptimal &lt;= amountADesired); // require(amountAOptimal &gt;= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT'); if (amountAOptimal &lt; amountAMin) revert InsufficientAAmount(); // revert InsufficientAAmount({ available: amountAOptimal, required: amountAMin }); (amountA, amountB) = (amountAOptimal, amountBDesired); } . By switching around the if/else clauses, we can replace the compound operator with a simple one . if (amountBOptimal &gt; amountBDesired) { uint256 amountAOptimal = OpenMevLibrary.quote(amountBDesired, reserveB, reserveA); require(amountAOptimal &lt;= amountADesired); // require(amountAOptimal &gt;= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT'); if (amountAOptimal &lt; amountAMin) revert InsufficientAAmount(); // revert InsufficientAAmount({ available: amountAOptimal, required: amountAMin }); (amountA, amountB) = (amountAOptimal, amountBDesired); } else { // require(amountBOptimal &gt;= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT'); if (amountBOptimal &lt; amountBMin) revert InsufficientBAmount(); // revert InsufficientBAmount({ available: amountBOptimal, required: amountBMin }); (amountA, amountB) = (amountADesired, amountBOptimal); } . Another instance of this improvement is found with the comparison &gt;= 1. Two other instances of this are in OpenMevLibrary.sol (lines 270 and 331), but to show the example from _swapSupportingFeeOnTransferTokens(): . swaps[i].isBackrunable = ((1000 * amountInput) / reserveInput) &gt;= 1; . Because &gt;= 1 equates to &gt; 0, and G1 shows how != 0 or _isNonZero() is better than &gt; 0, the comparison can be simplified to . swaps[i].isBackrunable = _isNonZero(((1000 * amountInput) / reserveInput)); . Impact . Gas savings . Recommendation . Replace compound comparison operators with simple ones for gas savings. Developer response (Sandy) . Fixed. 11. Gas - Combine reserve value checks (engn33r) . getAmountOut() in OpenMevLibrary.sol checks if the reserve values with _isZero(). Most locations where OpenMevLibrary.getAmountOut() is called also use the check if (reserve0 &lt; 1000 || reserve1 &lt; 1000) before getAmountOut() is called. Rather than duplicating similar checks, gas could be saved by consistently checking reserve values before calling getAmountOut(), or requiring reserve0 &lt; 1000 &amp;&amp; reserve1 &lt; 1000 inside getAmountOut(). Proof of concept . Most places where OpenMevLibrary.getAmountOut() in OpenMevZapper results in duplicated reserve checks. Impact . Gas savings . Recommendation . Remove duplicated reserves checks to save gas . Developer response (Sandy) . Fixed. 12. Gas - Use msg global vars directly (engn33r) . Using msg.sender and msg.value without caching is slightly more gas efficient than caching the value. Proof of concept . msg.value is unnecessarily cached in: . | addLiquidityETH() | swapETHForExactTokens() | swapETHAndStakeLiquidity() | . msg.value can replace swaps[0].amountIn . | swapExactETHForTokens() here and here | . Impact . Gas savings . Recommendation . Improve gas efficiency by removing the caching of msg global vars to use the global vars directly . Developer response (Sandy) . Fixed. 13. Gas - Remove duplicate internal function call (engn33r) . ensure() gets called twice in ETH-related functions. The first call happens at the start of addLiquidityETH() or removeLiquidityETH(), and the second call happens when this function calls addLiquidity() or removeLiquidity(). However, this only helps in the case where no revert occurs, otherwise reverting earlier is better. Proof of concept . One example: . | First call | Second call | . Impact . Gas savings . Recommendation . Remove the ensure() call at the start of the ETH-related functions in OpenMevRouter.sol. Developer response (Sandy) . Fixed. 14. Gas - deadline special case not aligned with permit (engn33r) . From EIP-2612: . The deadline argument can be set to uint(-1) to create Permits that effectively never expire. In contrast, ensure() implies a value of zero for a deadline that never expires . if (deadline &lt; block.timestamp &amp;&amp; _isNonZero(deadline)) revert Expired(); . Proof of concept . EIP-2612 text . ensure() function . Impact . Gas savings . Recommendation . Use the same permit approach as EIP-2612. This simplifies and aligns the check in ensure() to match Uniswap’s check. Uniswap code: require(deadline &gt;= block.timestamp, 'UniswapV2: EXPIRED'); . Revised OpenMevRouter.sol ensure() logic: if (deadline &lt; block.timestamp) revert Expired(); . Developer response (Sandy) . This was a feature request from Sam. Not sure why. Removed for compliance. Fixed. 15. Gas - Replace pair.swap() with _asmSwap() (engn33r) . One instance of pair.swap() has not been replaced with _asmSwap() for gas efficiency. Proof of concept . Line 699 of OpenMEVRouter.sol . Impact . Gas savings . Recommendation . Replace all instances of pair.swap() with _asmSwap(). This may allow the swap to be moved out of _swapSupportingFeeOnTransferTokensExecute() and into _swapSupportingFeeOnTransferTokens(). Developer response (Sandy) . Fixed. 16. Gas - Remove a sortTokens call (engn33r) . _swapSupportingFeeOnTransferTokens() in OpenMevRouter.sol calls sortTokens() twice. Caching the outputs from the first call can remove the need for the 2nd call. Proof of concept . | The first sortTokens() call | The second sortTokens() call happens in pairFor() | . Impact . Gas savings . Recommendation . Cache the outputs from the first sortTokens() call, then replace OpenMevLibrary.pairFor() with OpenMevLibrary._asmPairFor(). Developer response (Sandy) . Fixed. 17. Gas - Missing curly brace (engn33r) . The final if statement in withdrawLiquidityAndSwap() is missing curly braces. The code added in OpenMevZapper not found in Beefy is designed to save gas, but the curly braces are necessary to provide the gas savings. Otherwise the token swap always happens even if desiredTokenOutMin of desiredToken are already available to send to the user. Proof of concept . This if statement is missing curly braces. Impact . Gas savings . Recommendation . The revised code should read . if (desiredTokenOutMin &gt; ERC20(desiredToken).balanceOf(address(this))) { desiredSwapAmount = desiredTokenOutMin - ERC20(desiredToken).balanceOf(address(this)); router.swapExactTokensForTokens( ERC20(swapToken).balanceOf(address(this)), desiredSwapAmount, path, address(this), block.timestamp ); } . Developer response (Sandy) . I think there is some confusion over the intention of this code. I have added a comment above this condition to mitigate this in future in commit 27e04357e7dceb38ad9e65eef068363f98a192da . Essentially, the last swap needs to happen regardless of the prior condition. The condition sets a sensible expected amount out min for the last swap. As an example, if a user has ~$100 of liquidity for a USDC-DAI pool and wants to withdraw all in USDC, they might set desiredTokenOutMin to 96 USDC. After _removeLiquidity there might be ~ 49 USDC on the Zapper contract, so the minimum amount needed for the last swap (DAI-&gt;USDC) is 96 - 49 = 47 USDC. If the user specifies desiredTokenOutMin to be lower than 49 (amount already withdrawn), then the min amount out number remained the same. This has now been changed to default to zero in this case, for consistency. 18. Gas - Reduce number of swaps (engn33r) . There are three steps in the swap and arb process. The steps are: 1. Perform the user swap with factory0 2. Perform arb with a swap in the opposite direction with optimalAmount on factory0 3. Continue the arb with a swap in the initial direction on factory1. The first two steps (swap and arb on the same factory liquidity pool) can be combined because the 2nd step is effectively reversing a part of the first step. Because the end goal is to remove a price differential between the Uniswap and SushiSwap pools, this can be achieved by splitting the initial user swap between the Uniswap and SushiSwap pools to optimize the overall exchange rate rather than by arbing a larger swap that happens in a single LP. The profit for OpenMevRouter can be taken from the improved exchange rate (returning the user tokens based on the exchange rate if the swap happened in only one LP) rather than taking profit from the arb. Proof of concept . Consider the constant product diagram . Point 1 shows the liquidity pool amounts before OpenMevRouter interaction, point 2 shows the amounts after the OpenMevRouter user swap, and point 3 shows the amounts after the first backrun of the arb process. These two steps can be combined to arrive from point 1 to point 3, skipping to need to swap to arrive at point 2. The math in OpenMevRouter.sol would need changing, but gas savings from removing one swap may be enough to reduce overall gas consumption. Impact . Gas savings . Recommendation . Remove a swap by combining the user swap and the first step of the backrun that reverse the user swap by exchanging output token to input token. Developer response (Sandy) . Smart order routers are alternative solutions to the same MEV extraction and protection provided by this backrun solution. Indeed it is a project we are currently working on separately with an aggregation of more exchange pools. This project however, primarily services sushiswap pools by design. 19. Gas - Revert if zero flashloan profit (engn33r) . If there is no profit realized from the flashloan arb, the flashloan should revert to save remaining gas just like it would revert if there is loss of value. Proof of concept . The revert logic for the kashi flashloan callback is currently: . if (amountOver &lt; amountOwing) revert InsufficientOutputAmount(); . Instead, the revert should also happen on the equality case: . if (amountOver &lt;= amountOwing) revert InsufficientOutputAmount(); . The same improvement can be made in the Aave flashloan callback. Impact . Gas savings . Recommendation . Revert on zero profit case. Developer response (Sandy) . Fixed. ",
    "url": "/reports/05-2022-OpenMEVRouter/#gas-savings-findings",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#gas-savings-findings"
  },"55": {
    "doc": "05-2022-OpenMEV",
    "title": "Informational Findings",
    "content": "1. Informational - OpenMevRouter should inherit from IFlashBorrower and IOpenMevRouter (Jackson) . OpenMevRouter should also inherit from IFlashBorrower and IOpenMevRouter aside from TwoStepOwnable. Impact . Type safety. Developer response (Sandy) . Fixed. 2. Informational - The ETHERSCAN_API key is present in plaintext (Jackson) . ETHERSCAN_API is present in plaintext in test_Swaps.py . Impact . Malicious use of your Etherscan API key. Developer response (Sandy) . Fixed in this commit. 3. Informational - SafeTransferLib does not match Solmate’s main branch (Jackson) . The SafeTransferLib does not match Solmate’s latest implementation. Consider whether an update would be useful or save gas. Impact . Possible gas savings. Developer response (Sandy) . Fixed. 4. Informational - Incorrect comment (engn33r, Jackson) . A comment in OpenMevRouter.sol has an extra function argument that doesn’t exist in the code. Elsewhere, in addLiquidityETH() . Proof of concept . The comment on line 1001 doesn’t match the code in line 1002. Impact . Informational . Recommendation . Remove the extra function argument. Developer response (Sandy) . Fixed. 5. Informational - Replace magic numbers with constants (engn33r) . Constant variables should be used in place of magic numbers to prevent typos. For one example, the magic number 1000 is found in multiple places in OpenMevRouter.sol and should be replaced with a constant. Using a constant also adds a description using the variable name to explain what this value is for. This will not change gas consumption. Proof of concept . There are many instances of the value 1000. Consider replacing this magic number with a constant internal variable named MINIMUM_LIQUIDITY like Uniswap does: . | First instance | Second instance | Third instance | Fourth instance | Fifth instance | . Other instances of magic numbers are found in calcCoeffs(). Impact . Informational . Recommendation . Use constant variables instead of magic numbers . Developer response (Sandy) . MINIMUM_LIQUIDITY has been used in a fix. Some of the other numbers fall straight out of an equation derived in separate documentation and do not suit constants for efficiency or understanding. 6. Informational - Typos (engn33r) . balanaceToDistribute might be better named balanceToDistribute. isBackrunable might be better named isBackrunnable. Proof of concept . | First typo | Second typo | . Impact . Informational . Recommendation . Fix typos . Developer response (Sandy) . Fixed. 7. Informational - Hard coded Aave token list (engn33r) . Aave can modify their list of supported tokens that support flashloans. The aaveList() function in OpenMevLibrary.sol stores a hard coded list of these tokens, meaning OpenMevRouter does not support a way of updating its internal list of tokens supporting Aave flashloans. The list in the contract does match the list of supported Aave tokens at the time of this review. Proof of concept . The hard coded list of tokens in OpenMevLibrary.sol. Impact . Informational . Recommendation . Store Aave token addresses in a state variable that has a setter function with the onlyOwner modifier to enable changes to the Aave token list. Developer response (Sandy) . Fixed here and here. 8. Informational - Inconsistency in WETH transfers (engn33r) . There is one inconsistent instance of WETH transfer. Consider using a consistent approach for gas savings and code simplification. Proof of concept . The one instance of a WETH transfer with require(IWETH(weth).transfer(pair, amount));. All other instances use IWETH(weth).deposit{ value: amount }(); . | First instance | Second instance | Third instance | . Impact . Informational . Recommendation . Use consistent WETH transfer approach. Developer response (Sandy) . Fixed. 9. Informational - safeApprove vulnerable to double withdraw (engn33r) . Using approve() or safeApprove() adds the risk of a double withdrawal. The same race condition applies to permit(). Furthermore, the safeApprove() function is deprecated per OpenZeppelin docs. Proof of concept . One relevant safeApprove() call was found. Permit is used in several functions in OpenMevRouter.sol: . | First function | Second function | Third function | . Impact . Informational. This has not been shown to be a notable problem on mainnet, but better solutions do exist. Recommendation . Use safeIncreaseAllowance() or safeDecreaseAllowance() instead of safeApprove(). Developer response (Sandy) . Acknowledged. 10. Informational - Same frontrunning weaknesses as Uniswap/SushiSwap (engn33r) . While the description of this protection is to prevent MEV extraction with a specific form of MEV, there is no protection for other forms of MEV. This is acknowledged by the devs in project documentation, with acknowledgement that Uniswap does not protect against this either. Attack vectors such as frontrunning or an uncle bandit attack can extract value from transactions that swap with OpenMevRouter.sol because only backrun arbitrage MEV protection is built into the OpenMevRouter design. Proof of concept . Project documentation explaining these attack vectors still remain. Impact . Informational . Recommendation . Clarify user documentation to make it clear that amountOutMin or a similarly named function argument is still an important slippage setting in OpenMevRouter.sol and OpenMevZapper.sol. Developer response (Sandy) . Acknowledged. 11. Informational - Kashi flashloanable tokens assumed same as aave (engn33r) . The list of tokens that can be flashloaned with Kashi is assumed to be the same as the list of tokens that can be flashloaned from Aave. If there is a token that can be flashloaned with Kashi, the _backrunSwaps() function will never perform a backrun with this token even though it may result in profit. Proof of concept . The logic to backrun a swap happens if either there is sufficient token balance in the router that no flashloan is needed, or the token can be flashloaned from Aave. There is no separate list of Kashi-supported flashloanable tokens. Only a list of Aave flashloanable tokens exists. Impact . Informational . Recommendation . Add a list of Kashi flashloanable tokens to allow profitable backruns if Kashi supports more flashloanable tokens than Aave. Developer response (Sandy) . Fixed. 12. Informational - (engn33r) . The add512x512() additional function has a comment copied from sub512x512() which reads “Calculates the difference of two uint512”. It should instead read “Calculates the sum of two uint512”. Proof of concept . Incorrect comment for add512x512() . Impact . Informational . Recommendation . Fix the comment as described to properly describe function purpose. Developer response (Sandy) . Fixed. ",
    "url": "/reports/05-2022-OpenMEVRouter/#informational-findings",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#informational-findings"
  },"56": {
    "doc": "05-2022-OpenMEV",
    "title": "Final remarks",
    "content": "engn33r . The custom logic around the backrun to capture MEV and the corresponding whitepaper with equation derivations is well thought out and implemented. The main points of concern are actually the modifications made to forked code from Uniswap and Beefy, as the high risk findings indicate. The gas savings optimizations applied to the OpenMevRouter contracts are above and beyond the level of most projects. I think this project can play an important role in the future of MEV and the solid code structure gives me confidence it can properly fill this role. Jackson . This is one of those ideas that you think “why didn’t I think of that?”. I’m excited for it to go into production and see what the effects will be for both users and holders of Sushi. The number, type, and breadth of tests give me confidence in the correctness of the implementation. My only concerns are around whether we missed something related to the intention of the implementation as most of the high and medium findings seem to suggest. ",
    "url": "/reports/05-2022-OpenMEVRouter/#final-remarks",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#final-remarks"
  },"57": {
    "doc": "05-2022-OpenMEV",
    "title": "About yAcademy",
    "content": "yAcademy is an ecosystem initiative started by Yearn Finance and its ecosystem partners to bootstrap sustainable and collaborative blockchain security reviews and to nurture aspiring security talent. yAcademy includes a fellowship program and a residents program. In the fellowship program, fellows perform a series of periodic security reviews and presentations during the program. Residents are past fellows who continue to gain experience by performing security reviews of contracts submitted to yAcademy for review (such as this contract). ",
    "url": "/reports/05-2022-OpenMEVRouter/#about-yacademy",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#about-yacademy"
  },"58": {
    "doc": "05-2022-OpenMEV",
    "title": "Appendix and FAQ",
    "content": " ",
    "url": "/reports/05-2022-OpenMEVRouter/#appendix-and-faq",
    "relUrl": "/reports/05-2022-OpenMEVRouter/#appendix-and-faq"
  },"59": {
    "doc": "05-2022-OpenMEV",
    "title": "05-2022-OpenMEV",
    "content": " ",
    "url": "/reports/05-2022-OpenMEVRouter/",
    "relUrl": "/reports/05-2022-OpenMEVRouter/"
  },"60": {
    "doc": "08-2022-Bunni",
    "title": "yAcademy Bunni review",
    "content": "Review Resources: README . Residents: . | Jackson | devtooligan | . ",
    "url": "/reports/08-2022-Bunni/#yacademy-bunni-review",
    "relUrl": "/reports/08-2022-Bunni/#yacademy-bunni-review"
  },"61": {
    "doc": "08-2022-Bunni",
    "title": "Table of Contents",
    "content": ". | Review Summary | Scope | Code Evaluation Matrix | Findings Explanation | Critical Findings . | 1. Critical - Anyone can call uniswapV3MintCallback() stealing the protocol fees (devtooligan, Jackson) . | Technical Details | Impact | Recommendation | Developer response (zeframL) | . | 2. Critical - Anyone can call the PeripheryPayments sweepToken() stealing the protocol fees (Jackson) . | Technical Details | Impact | Recommendation | Developer response (zeframL) | . | 3. Critical - Anyone can call the PeripheryPayments unwrapWETH9() stealing the weth stored in BunniHub (Jackson) . | Technical Details | Impact | Recommendation | Developer response (zeframL) | . | . | High Findings | Medium Findings | Low Findings . | 1. Low - General complexity around ETH management including certain circumstances where ETH could be lost (devtooligan) . | Technical Details | Impact | Recommendation | Developer response (zeframL) | . | 2. Low - Calling withdraw() forfeits uncollected LP fees (devtooligan) . | Technical Details | Impact | Recommendation | Developer response (zeframL) | . | . | Gas Savings Findings . | 1. Gas - Optimize the sweepTokens() loop (devtooligan) . | Technical Details | Impact | Developer response (zeframL) | . | . | Informational Findings . | 1. Informational - Upgrade to at least solidity 0.8.4 (devtooligan) . | Technical Details | Impact | Recommendation | Developer response (zeframL) | . | 2. Informational - Use latest versions of unmodified libraries (devtooligan) . | Technical Details | Impact | Recommendation | Developer response (zeframL) | . | 3. Informational - Consider Foundry scripting for the deployment scripts (Jackson) . | Technical Details | Impact | Recommendation | Developer response (zeframL) | . | 4. Informational - Typo in README (Jackson) . | Technical Details | Impact | Recommendation | Developer response (zeframL) | . | 5. Informational - Consider adding npm related steps to the README (Jackson) . | Technical Details | Impact | Recommendation | Developer response (zeframL) | . | 6. Informational - Consider removing the WETH unwrapping logic (Jackson) . | Technical Details | Impact | Recommendation | Developer response (zeframL) | . | . | Final remarks . | devtooligan | Jackson | . | About yAcademy | . ",
    "url": "/reports/08-2022-Bunni/#table-of-contents",
    "relUrl": "/reports/08-2022-Bunni/#table-of-contents"
  },"62": {
    "doc": "08-2022-Bunni",
    "title": "Review Summary",
    "content": "Bunni . From Bunni’s README: . Bunni enables projects to create ERC-20 LP tokens on Uniswap V3 and plug them into existing liquidity incentivization contracts designed for Uniswap V2/Sushiswap. The main branch of the Bunni repo was reviewed over 14 days, 5 of which were used to create an initial overview of the contract. The code review was performed between August 29 and September 11, 2022. The code was reviewed by 2 residents for a total of 52 man hours (devtooligan: 27 hours, and Jackson 25 hours). The review was limited to one specific commit. ",
    "url": "/reports/08-2022-Bunni/#review-summary",
    "relUrl": "/reports/08-2022-Bunni/#review-summary"
  },"63": {
    "doc": "08-2022-Bunni",
    "title": "Scope",
    "content": "Code Repo Commit . The commit reviewed was fc3535c35ca182dee5684e0a9dd9c152cc33047e. The review covered the entire repository at this specific commit but focused on the contracts directory. This review is a code review to identify potential vulnerabilities in the code. The reviewers did not investigate security practices or operational security and assumed that privileged accounts could be trusted. The reviewers did not evaluate the security of the code relative to a standard or specification. The review may not have identified all potential attack vectors or areas of vulnerability. yAcademy and the residents make no warranties regarding the security of the code and do not warrant that the code is free from defects. yAcademy and the residents do not represent nor imply to third parties that the code has been audited nor that the code is free from defects. Bunni and third parties should use the code at their own risk. ",
    "url": "/reports/08-2022-Bunni/#scope",
    "relUrl": "/reports/08-2022-Bunni/#scope"
  },"64": {
    "doc": "08-2022-Bunni",
    "title": "Code Evaluation Matrix",
    "content": "| Category | Mark | Description | . | Access Control | Good | The onlyOwner modifier was only applied to the sweepTokens() and setProtocolFee() functions. Access controls existed on the relevant callback functions in LiquidityManagement.sol for deposits into the underlying Uniswap liquidity pool and BunniToken. msg.sender is properly used so that the user cannot perform actions they should not be able to. Access controls are applied where needed. | . | Mathematics | Average | Solidity 0.7.6 is used, which does not provide overflow and underflow protect. However, Uniswap’s FullMath and LowGasSafeMath libraries are used where overflow and underflow protection is necessary. | . | Complexity | Average | Many function names and implementations are borrowed from UniswapV3 contracts and Solmate. This reduces the amount of custom development work necessary. The primary source of complexity is in the handling of callbacks from UniswapV3 pools and proper accounting in the BunniHub. | . | Libraries | Average | Since the contracts are using Solidity 0.7.6 some library contracts were copied into the directory rather than being imported. These dependencies include Solmate’s CREATE3, ERC20, and SafeTransferLib. However, due to these being copied into the project, they do not match the latest versions of these projects. | . | Decentralization | Good | Only two functions contain onlyOwner modifiers, sweepTokens() and setProtocolFee() in the BunniHub. | . | Code stability | Good | Changes were reviewed at a specific commit hash and the scope was not expanded after the review was started. The code reviewed had nearly all features implemented. | . | Documentation | Good | Descriptive NatSpec comments are found in the interface contracts. The comments accurately describe the function purpose and function input/output arguments. The BunniHub compound() function is particularly well commented. The README contains useful information about the intended use and purpose of Bunni. | . | Monitoring | Average | The core functions in BunniHub contain events, however, the other auxilliary functions do not. | . | Testing and verification | Average | Bunni uses Foundry for testing. Foundry coverage was used to produce a coverage report that indicates roughly 50% coverage. However, the majority of core logic is found in the src/ directory, which has roughly 75% coverage. The coverage could be improved to test for the edge cases introduced by modifications to the forked Uniswap contracts as demonstrated by the findings. Fuzz and fork tests could also be easily included due to the use of Foundry. | . ",
    "url": "/reports/08-2022-Bunni/#code-evaluation-matrix",
    "relUrl": "/reports/08-2022-Bunni/#code-evaluation-matrix"
  },"65": {
    "doc": "08-2022-Bunni",
    "title": "Findings Explanation",
    "content": "Findings are broken down into sections by their respective impact: . | Critical, High, Medium, Low impact . | These are findings that range from attacks that may cause loss of funds, impact control/ownership of the contracts, or cause any unintended consequences/actions that are outside the scope of the requirements | . | Gas savings . | Findings that can improve the gas efficiency of the contracts | . | Informational . | Findings including recommendations and best practices | . | . ",
    "url": "/reports/08-2022-Bunni/#findings-explanation",
    "relUrl": "/reports/08-2022-Bunni/#findings-explanation"
  },"66": {
    "doc": "08-2022-Bunni",
    "title": "Critical Findings",
    "content": "1. Critical - Anyone can call uniswapV3MintCallback() stealing the protocol fees (devtooligan, Jackson) . Technical Details . LiquidityManagement::uniswapV3MintCallback() only checks that msg.sender == address(decodedData.pool), which any attacker can trivially fulfill by setting decodedData.pool to an address they own. The function then transfers decodedData.pool.token0() and decodedData.pool.token1() to msg.sender, the amount of which is specified by the caller. Impact . Critical, anyone can take the protocol fees stored in BunniHub. Recommendation . Use the Uniswap V3 factory to verify that the caller is indeed the Uniswap pool associated with the desired tokens and fee tier. Developer response (zeframL) . This was fixed in commit f6fa8cd1ef06e71ddc25ac15e82c9fe9859a9aec by using the Uniswap V3 factory to verify that the caller is indeed the Uniswap pool associated with the desired tokens and fee tier. 2. Critical - Anyone can call the PeripheryPayments sweepToken() stealing the protocol fees (Jackson) . Technical Details . PeripheryPayments is a dependency of the LiquidityManagement contract, which is a dependency of the BunniHub contract. PeripheryPayments has a sweepToken() with no access control which allows a caller to transfer any token from the BunniHub contract to any recipient. Impact . Critical. Anyone can take the protocol fees stored in BunniHub. Recommendation . Remove or access control the PeripheryPayments sweepToken() function. Developer response (zeframL) . Fixed in commit cfead992384cf959350439eb1ca79d73b0c528ac by removing PeripheryPayments. 3. Critical - Anyone can call the PeripheryPayments unwrapWETH9() stealing the weth stored in BunniHub (Jackson) . Technical Details . PeripheryPayments is a dependency of the LiquidityManagement contract, which is a dependency of the BunniHub contract. PeripheryPayments has a unwrapWETH9() with no access control which allows a caller to the contract’s weth balance from the BunniHub contract to any recipient. Impact . Critical. Anyone can take the weth stored in BunniHub. Recommendation . Remove or access control the PeripheryPayments unwrapWETH9() function. Developer response (zeframL) . Fixed in commit cfead992384cf959350439eb1ca79d73b0c528ac by removing PeripheryPayments. ",
    "url": "/reports/08-2022-Bunni/#critical-findings",
    "relUrl": "/reports/08-2022-Bunni/#critical-findings"
  },"67": {
    "doc": "08-2022-Bunni",
    "title": "High Findings",
    "content": "None. ",
    "url": "/reports/08-2022-Bunni/#high-findings",
    "relUrl": "/reports/08-2022-Bunni/#high-findings"
  },"68": {
    "doc": "08-2022-Bunni",
    "title": "Medium Findings",
    "content": "None. ",
    "url": "/reports/08-2022-Bunni/#medium-findings",
    "relUrl": "/reports/08-2022-Bunni/#medium-findings"
  },"69": {
    "doc": "08-2022-Bunni",
    "title": "Low Findings",
    "content": "1. Low - General complexity around ETH management including certain circumstances where ETH could be lost (devtooligan) . Technical Details . The BunniHub contract currently only has one payable function that can receive ETH which is the receive() found in PeripheryPayments. That function requires that the sender is WETH9. In general BunniHub will not be interacting with ETH but there is functionality embedded with the Uniswap imports related to the management of ETH which adds complexity and some risk. abstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState { receive() external payable { require(msg.sender == WETH9, 'Not WETH9'); } . If for some reason someone unwrapped WETH and set the recipient to the BunniHub, then the contract would no hold the ETH. This ETH could be taken by anyone via refundEth() or it could also be included used the next time anyone deposited into a WETH pool since pay() includes some logic that is designed to work with with unwrapping WETH: . function pay( address token, address payer, address recipient, uint256 value ) internal { if (token == WETH9 &amp;&amp; address(this).balance &gt;= value) { // pay with WETH9 IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay IWETH9(WETH9).transfer(recipient, value); } else if (payer == address(this)) { ... Impact . Low. It is a real edge case where a user could lose ETH via pay() but the general complexity of including the ETH management is more of a concern. Recommendation . Consider removing ETH management logic, including the receive() and refundEth() functions in PeripheryPayments, as well as the conditional logic found in pay(). Developer response (zeframL) . Fixed in commit cfead992384cf959350439eb1ca79d73b0c528ac by removing PeripheryPayments. 2. Low - Calling withdraw() forfeits uncollected LP fees (devtooligan) . Technical Details . Fees are collected and reinvested via compound(), but when withdraw() is called, fees are not collected. Impact . Low. Depending on the size of the deposit and the amount of time since compound() was called, a depositor lose out on significant portion of fees. Recommendation . Consider adding a second function compoundAndWithdraw() or else adding a bool to the current withdraw() which explicitly indicates whether or not compound() should be called prior to withdraw(). Developer response (zeframL) . This is fine, since BunniHub inherits Multicall where the caller can batch multiple calls in the same transaction. If the user is okay with paying the extra gas cost, the user can choose to call compound() before withdraw(). ",
    "url": "/reports/08-2022-Bunni/#low-findings",
    "relUrl": "/reports/08-2022-Bunni/#low-findings"
  },"70": {
    "doc": "08-2022-Bunni",
    "title": "Gas Savings Findings",
    "content": "1. Gas - Optimize the sweepTokens() loop (devtooligan) . Technical Details . @@ -436,12 +453,16 @@ contract BunniHub is - for (uint256 i = 0; i &lt; tokenList.length; i++) { + uint256 tokenListLength = tokenList.length; + for (uint256 i = 0; i &lt; tokenListLength;) { SafeTransferLib.safeTransfer( tokenList[i], recipient, tokenList[i].balanceOf(address(this)) ); + unchecked { + ++i; + } } . Incrementing i can be done in an unchecked block because the number of tokens will not overflow saving 108 gas per per iteration. The length of an array can be stored outside of the for loop for additional gas savings 3 gas per iteration.of as is suggested here. Incrementing with ++i instead of i++ saves ~5 gas per iteration from reduced stack operations. Impact . Gas savings ~115 per token submitted. Developer response (zeframL) . Fixed in commit 8587a86bb5f45a5bcf82d10ce22cca04989b2abd. ",
    "url": "/reports/08-2022-Bunni/#gas-savings-findings",
    "relUrl": "/reports/08-2022-Bunni/#gas-savings-findings"
  },"71": {
    "doc": "08-2022-Bunni",
    "title": "Informational Findings",
    "content": "1. Informational - Upgrade to at least solidity 0.8.4 (devtooligan) . Technical Details . Currently there is no underflow or overflow protection at the compiler level in Bunni, which means SafeMath style libraries are necessary, which are gas inefficient compared to the compiler and potentially less safe. Also see hrkrshnn’s related comment. Impact . Informational. Recommendation . Uniswap V3 now has a 0.8 branch of their contracts. Consider using this branch and upgrading to a more modern version of Solidity. Developer response (zeframL) . Fixed in commit d2a7f886ce619096c4c79c7a89c4bcc06e941a81. 2. Informational - Use latest versions of unmodified libraries (devtooligan) . Technical Details . The contracts are using Solidity 0.7.6 some library contracts (CREATE3, ERC20, and SafeTransferLib) were copied into the directory rather than being imported. However, due to these being copied into the project and also because of some modifications, they do not match the latest versions of these projects. Impact . Informational. Recommendation . We recommend using the latest versions of the libraries, and using the libraries without modification. Developer response (zeframL) . Fixed in commit d2a7f886ce619096c4c79c7a89c4bcc06e941a81. Note that ERC20 and SafeTransferLib still need to be copied and modified, because we need ERC20 to inherit from IERC20 in order to allow BunniToken to inherit from both ERC20 and IERC20. 3. Informational - Consider Foundry scripting for the deployment scripts (Jackson) . Technical Details . Currently bash scripts are used for the deployment scripts. While they are currently relatively simple, as the project progresses this may no longer be the case. Impact . Informational. Recommendation . Since Foundry is used in the project for testing, consider migrating to Foundry for the deployment scripts as well, as it provides a few benefits over a bash script, to include compile time checking and transaction simulation. Developer response (zeframL) . Fixed in 86739fcec723fc7be7d2386152d369597c532ef3. 4. Informational - Typo in README (Jackson) . Technical Details . There is a typo in the README “perfer”. Impact . Informational. Recommendation . Change “perfer” to “prefer”. Developer response (zeframL) . Fixed in commit 5ebca63def23b21004efbbff84a7f105438a6308. 5. Informational - Consider adding npm related steps to the README (Jackson) . Technical Details . npm is used to manage dependencies but this information is not present in the README. Impact . Informational. Recommendation . Consider adding the dependency management steps to the README for future contributors. Developer response (zeframL) . Fixed in commit 5ebca63def23b21004efbbff84a7f105438a6308. 6. Informational - Consider removing the WETH unwrapping logic (Jackson) . Technical Details . One of the critical findings is related to WETH management. If it’s not necessary it is a source of unecessary additional complexity that may lead to other future vulnerabilities. Impact . Informational. Recommendation . Consider removing this functionality from all contracts and treat WETH as any other token in order to simplify the logic. Developer response (zeframL) . Fixed in commit cfead992384cf959350439eb1ca79d73b0c528ac by removing PeripheryPayments. ",
    "url": "/reports/08-2022-Bunni/#informational-findings",
    "relUrl": "/reports/08-2022-Bunni/#informational-findings"
  },"72": {
    "doc": "08-2022-Bunni",
    "title": "Final remarks",
    "content": "devtooligan . We conducted extensive testing based on a mainnet fork to ensure realistic interaction with Uniswap deployed contracts. We stress tested the deposit() and withdraw() by conducting unit and fuzz tests on multiple scenarios including changing the existing liquidity (through deposit/withdraws) before/after transactions as well as affecting the market price of the pair itself through Uniswap trades. In all of these tests, the target amount being tested was unaffected, remaining constant to the wei. We noted some seemingly unnecessary complexity and risk associated with WETH/ETH logic which can probably be removed completely. Additionally, all functions in the SafeTransferLib implementation were stress tested with fuzzing and no counterexamples were found. Overall, I found the contracts to be clean, well documented, and using best practices. Jackson . I spent quite a bit of time trying to manipulate the underlying pool in an attempt to get more BunniToken shares, or more underlying tokens from the pool when withdrawing. But, none of these approaches proved fruitful. This is primarily because the ticks used with the Uniswap V3 liquidity pools mean that deposits and withdrawals are contained to those liquidity ranges and those liquidity ranges only even if the pool itself is not trading in those liquidity ranges. As is said in the Bunni README, the project is an ERC20 wrapper over the Uniswap V3 LP NFTs, which makes the system somewhat simple and therefore hard to game and relatively safe from a security perspective. ",
    "url": "/reports/08-2022-Bunni/#final-remarks",
    "relUrl": "/reports/08-2022-Bunni/#final-remarks"
  },"73": {
    "doc": "08-2022-Bunni",
    "title": "About yAcademy",
    "content": "yAcademy is an ecosystem initiative started by Yearn Finance and its ecosystem partners to bootstrap sustainable and collaborative blockchain security reviews and to nurture aspiring security talent. yAcademy includes a fellowship program, a residents program, and a guest auditor program. In the fellowship program, fellows perform a series of periodic security reviews and presentations during the program. Residents are past fellows who continue to gain experience by performing security reviews of contracts submitted to yAcademy for review (such as this contract). Guest auditors are experts with a track record in the security space who temporarily assist with the review efforts. ",
    "url": "/reports/08-2022-Bunni/#about-yacademy",
    "relUrl": "/reports/08-2022-Bunni/#about-yacademy"
  },"74": {
    "doc": "08-2022-Bunni",
    "title": "08-2022-Bunni",
    "content": " ",
    "url": "/reports/08-2022-Bunni/",
    "relUrl": "/reports/08-2022-Bunni/"
  },"75": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "yAcademy Timeless Yield Daddy review",
    "content": "Review Resources: None beyond the code repositories . Residents: . | engn33r | Benjamin Samuels | . ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#yacademy-timeless-yield-daddy-review",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#yacademy-timeless-yield-daddy-review"
  },"76": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "Table of Contents",
    "content": ". | Review Summary | Scope | Code Evaluation Matrix | Findings Explanation | High Findings . | 1. High - Incorrect order of operations in LibCompound.sol (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 2. High - User can set arbitrary approveMaxIfNeeded() target (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 3. High - Lack of slippage protection in Curve swaps (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | . | Medium Findings . | 1. Medium - Accrued rewards may not be returned to depositors (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 2. Medium - Bypass to add cEtherAddress to underlyingToCToken array (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 3. Medium - Improper wrapEthInput() call can cause value loss (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 4. Medium - ERC20 tokens sitting in contracts can be extracted (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | . | Low Findings . | 1. Low - Difficult to use withdraw() with full deposit (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 2. Low - Inaccurate function return values (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 3. Low - No fee-on-transfer token support (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 4. Low - Curve’s price_oracle() may provide less effective sandwiching protection post-merge (Benjamin Samuels) . | Technical Details | Impact | Recommendation | Developer Response | . | 5. Low - Insufficient SwapArgs input validation (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 6. Low - Curve Swap design may generate unexpected NYT/PYT dust (Benjamin Samuels) . | Technical Details | Impact | Recommendation | Developer Response | . | 7. Low - xPYT deployment lacks trust mechanism (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 8. Low - Missing PYT/NYT lookup mechanism (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | . | Gas Savings Findings . | 1. Gas - Replace require blocks with errors (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 2. Gas - Declare variables internal, immutable, or constant when possible (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 3. Gas - Remove beforeWithdraw() calls (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 4. Gas - Replace duplicate code with internal function (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 5. Gas - Declare functions external for gas savings (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 6. Gas - Use claimComp() with borrowers = false (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 7. Gas - Use unchecked if no underflow risk (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 8. Gas - Function arg should be calldata not memory (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 9. Gas - Move revert earlier in function (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 10. Gas - Internal function is cheaper than modifier (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 11. Gas - Zero check could save gas (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 12. Gas - Remove unnecessary approve (engn33r, Benjamin Samuels) . | Technical Details | Impact | Recommendation | Developer Response | . | 13. Gas - Unnecessary logic in approveMaxIfNeeded() function (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | . | Informational Findings . | 1. Informational - Direct transfer of aTokens impacts share value (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 2. Informational - aAMPL edge cases (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 3. Informational - Invert constant mask variables (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 4. Informational - Simplify logic in maxDeposit() and maxMint() (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 5. Informational - Add parentheses to avoid order of operations ambiguity (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 6. Informational - Inconsistent ERC4626 callback usage (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 7. Informational - Some hard coded variables might be better adjustable (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 8. Informational - Unclear upgrade mechanism (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 9. Informational - General lack of documentation and comments (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 10. Informational - Typos (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 11. Informational - Aave LendingPool getConfiguration() can replace getReserveData() (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 12. Informational - Redundant dependency imports (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 13. Informational - Interface doesn’t match mainnet contract (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 14. Informational - Consider upgrade to latest solidity release (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 15. Informational - Theoretical overflow of convertToShares() and convertToAssets() (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 16. Informational - No zero address checks in constructor (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 17. Informational - Modify Gate.sol claimYieldAndEnter() function argument (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 18. Informational - CurveV2xPYT utilizes a non-TWAP price oracle (Benjamin Samuels) . | Technical Details | Impact | Recommendation | Developer Response | . | 19. Informational - Replace magic numbers with constants (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 20. Informational - No timelock or other protection around changing fee or fee recipient (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 21. Informational - safeApprove is deprecated (Benjamin Samuels) . | Technical Details | Impact | Recommendation | Developer Response | . | 22. Informational - Swapper repo foundry coverage failing (engn33r) . | Technical Details | Impact | Recommendation | Developer Response | . | 23. Informational - StETHERC4626.t.sol test failing (Benjamin Samuels) . | Technical Details | Impact | Recommendation | Developer Response | . | . | Final remarks . | engn33r | Benjamin Samuels | . | About yAcademy | . ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#table-of-contents",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#table-of-contents"
  },"77": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "Review Summary",
    "content": "Yield Daddy . Yield Daddy provides ERC4626 wrappers for common tokens from yield-generating protocols. This includes tokens received from Aave, Compound, Curve, and other lending protocols that provide users with tokens that increase in value over time. The contracts of the Yield Daddy repo, xPYT repo, and swapper repo were reviewed over 16 days, 2 of which were used to create an initial overview of the contract. The code review was performed between August 31 and September 16, 2022. The code was reviewed by 2 residents for a total of 60 review hours (engn33r 32 hours, Benjamin Samuels 28 hours). The repository was under active development during the review, but the review was limited to the latest commit at the start of the review. This was commit 2c8f62681ab90325ede093ac9c9f94dbcc5f7e49 for the Yield Daddy repo, commit fabe9d7cb9700334b10a48ee5d081234eb98def9 for the xPYT repo, and commit 35db08558aa01e8473ada13c092e24857d01461b for the Swapper repo. ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#review-summary",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#review-summary"
  },"78": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "Scope",
    "content": "The scope of the review consisted of the following contracts at the specific commit: . | Yield Daddy Code Repo @ 2c8f62681ab90325ede093ac9c9f94dbcc5f7e49 . | AaveV2ERC4626.sol | AaveV2ERC4626Factory.sol | AaveV3ERC4626.sol | AaveV3ERC4626Factory.sol | CompoundERC4626.sol | CompoundERC4626Factory.sol | EulerERC4626.sol | EulerERC4626Factory.sol | StETHERC4626.sol | . | xPYT Code Repo @ fabe9d7cb9700334b10a48ee5d081234eb98def9 . | CurveV2xPYT.sol | CurveV2xPYTFactory.sol | . | Swapper Code Repo @ 35db08558aa01e8473ada13c092e24857d01461b . | CurveV2Swapper.sol | CurveV2Juggler.sol | . | . No other protocol ERC4626 wrappers are to be reviewed in Yield Daddy, such as the Uniswap wrappers present in the repositories at the time of review. Contracts from the main Timeless repo that are integrated with the xPYT and swapper repositories, including Gate.sol, were out of scope and not fully reviewed, although some interactions with in-scope contracts were examined. After the findings were presented to the Yield Daddy team, fixes were made and included in several PRs. This review is a code review to identify potential vulnerabilities in the code. The reviewers did not investigate security practices or operational security and assumed that privileged accounts could be trusted. The reviewers did not evaluate the security of the code relative to a standard or specification. The review may not have identified all potential attack vectors or areas of vulnerability. yAcademy and the residents make no warranties regarding the security of the code and do not warrant that the code is free from defects. yAcademy and the residents do not represent nor imply to third parties that the code has been audited nor that the code is free from defects. By deploying or using the code, Yield Daddy and users of the contracts agree to use the code at their own risk. ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#scope",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#scope"
  },"79": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "Code Evaluation Matrix",
    "content": "| Category | Mark | Description | . | Access Control | Good | No access control modifiers are present besides the use of the onlyOwner modifier in one location. Governance has no special privileges, which limits centralization risks and attack vectors targeting privileged addresses. | . | Mathematics | Good | The only math involved in the custom code of the protocol involves adding and subtracting account balances. There is no reliance on complex math. | . | Complexity | Low | The scope of the review is roughly 1200 lines of code. The ERC4626 wrappers are very concise. However, the xPYT and Swapper repositories are relatively complex and are very tightly coupled with several other contracts that were out of scope of the audit. | . | Libraries | Average | An average number of solmate libraries are imported into the project, as well as the BoringOwnable.sol library. This is common practice, but relying on external dependencies always increases the risk of vulnerabilities in these dependencies. | . | Decentralization | Good | Only ownerSetProtocolFee() in Swapper.sol provides extra functionality based on an access modifier. The rest of the code is permissionless and does not rely on governance, whitelisting, or other special admin requirements. | . | Code stability | Good | No changes were made to the code in the review scope after the review started and the code did not have TODO comments indicating unfinished code. | . | Documentation | Low | There are no developer docs for the project and many functions are missing NatSpec comments. Custom logic, like the value comparisons in maxWithdraw() and maxRedeem() in Yield Daddy, are missing comments explaining why the values are being compared (in these specific functions, the reason for the comparison is an edge case of undercollateralized Aave aTokens). Developer docs should be created, explaining a typical user’s interaction with the protocol. NatSpec comments should be added to all functions, even functions that are part of the ERC4626 specification. | . | Monitoring | Average | Events exist in all functions involving state changes except the Swapper swap-related functions. | . | Testing and verification | Average | Tests are implemented in foundry but could use improved coverage. Specifically, the Compound ERC4626 wrapper and factory is at 0% code coverage, CurveV2xPYTFactory.sol in xPYT is also at 0% coverage, and the swapper repository returns a CompilerError: Stack too deep when compiling inline assembly error when forge coverage is run. Some contracts such as CurveV2Juggler are only tested indirectly through other contract’s testing. There are also few integration tests for testing the system against a live network. | . ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#code-evaluation-matrix",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#code-evaluation-matrix"
  },"80": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "Findings Explanation",
    "content": "Findings are broken down into sections by their respective impact: . | Critical, High, Medium, Low impact . | These are findings that range from attacks that may cause loss of funds, impact control/ownership of the contracts, or cause any unintended consequences/actions that are outside the scope of the requirements | . | Gas savings . | Findings that can improve the gas efficiency of the contracts | . | Informational . | Findings including recommendations and best practices | . | . ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#findings-explanation",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#findings-explanation"
  },"81": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "High Findings",
    "content": "1. High - Incorrect order of operations in LibCompound.sol (engn33r) . Changes made to the LibCompound.sol dependency modify the order of operations. The original version of this file on github does not have the same order of operations. This changes the result of the math, causing incorrect calculations. Technical Details . The problematic computations are for the variables interestAccumulated and the return value. interestAccumulated calculation from transmissions11/libcompound repo: . uint256 interestAccumulated = (borrowRateMantissa * (block.number - accrualBlockNumberPrior)).mulWadDown( borrowsPrior ); . interestAccumulated calculation from local LibCompound.sol contract: . uint256 interestAccumulated = borrowRateMantissa * block.number - accrualBlockNumberPrior.mulWadDown(borrowsPrior); . Made up example values: . | borrowRateMantissa = 1000000000 | block.number = 15460000 | accrualBlockNumberPrior = 15459990 | borrowsPrior = 500000000000000000000000 interestAccumulated result from transmissions11/libcompound: 5000000000000000 interestAccumulated result from local LibCompound.sol: 15452270005000000 | . Return value calculation from transmissions11/libcompound repo: . (totalCash + totalBorrows - totalReserves).divWadDown(totalSupply); . Return value calculation from local LibCompound.sol contract: . totalCash + totalBorrows - totalReserves.divWadDown(totalSupply); . Example values loosely taken from cDAI: . | totalCash = 400000000000000000000000000 | totalBorrows = 300000000000000000000000000 | totalReserves = 20000000000000000000000000 | totalSupply = 3100000000000000000 Return value result from transmissions11/libcompound: 219354838709677419354838709 Return value result from local LibCompound.sol: 693548387096774193548387097 | . Impact . High. Incorrect order of operations leads to different calculation results for totalAssets(), which impacts key value management functions including convertToShares() and convertToAssets(). Recommendation . Use the latest version of the transmissions11/libcompound repo after confirming its math is correct. Developer Response . Fixed in commit 0ea9347d360dc6d226fa134c9c73d025d2fc6aa5. 2. High - User can set arbitrary approveMaxIfNeeded() target (engn33r) . The Swapper.sol contract is written in a way that a malicious contract could be written that: . | is approved for type(uint256).max of the token types that pass through Swapper.sol | calls safeTransferFrom() on these ERC20 tokens it has been approved for | . To be clear, this in itself would not steal value from Swapper.sol. But the nonReentrant modifiers in CurveV2Swapper.sol indicate there is in theory a non-zero chance that an external contract may execute malicious code to call back into a CurveV2Swapper.sol function partway through a function’s execution. If such an action were possible, the nonReentrant modifier would not protect against a malicious contract calling safeTransferFrom(). Technical Details . This finding is not a complete attack chain, but the missing link of the chain depends on a hypothetical weakness in an external contract, which is out of scope of this review. In order for value to be stolen from Swapper.sol, a malicious actor would: . | Create a malicious contract that is approved by Swapper.sol for ERC20 tokens that pass through Swapper.sol, which enables it to transferFrom() those tokens | Use an external call from Swapper.sol to call the malicious contract while Swapper.sol holds value to take that value before it can be sent to the user calling the contract | . The first step is possible because the input argument to approveMaxIfNeeded() in Swapper.sol code is a user-specified argument. Not only that, but in a function such as _swapXpytToUnderlying(), the args.gate parameter approved for args.xPYT here is only used for one function call, exitToUnderlying(). This function could be implemented in a malicious contract as an empty function and the rest of the _swapXpytToUnderlying() function would still succeed, allowing the args.gate user-specific argument to be set to an address under the malicious user’s control. Even worse, this exitToUnderlying() could be where the transferFrom() call happens, so if an innocent user specifies this value for the args.gate value (either due to a mistake, a Timeless frontend hack, or any other means), the value would be transferred to the malicious gate contract and the innocent user would lose the value that was going to be sent to them. It is not even necessary for the user to provide a malicious value for args.gate for this to become a problem. Multiple external calls exist within the functions of Swapper.sol, and if any of these are insecure or have an external call to an insecure contract, loss of value can occur even if the user’s transaction has the proper function argument values set. Impact . High. The complete attack chain is not defined in the scope of this review. However, there is a non-zero risk of removal of value from Swapper.sol despite the nonReentrant modifiers on the external functions due to approval of arbitrary addresses. Recommendation . As described in finding Low #5, there is insufficient input validation on the SwapArgs args function argument. For this specific issue, it would be best to: . | Confirm that args.gate is a legitimate gate contract (and not a malicious contract that resembles the gate contract) by querying the factory contract or another contract that maintains a whitelist of legitimate gate contracts. If there is no such whitelist, it should be created. For example, Uniswap maintains a mapping of legitimate token pairs. | Confirm that the other values related to the approveMaxIfNeeded() calls, namely args.xPYT, args.pyt, and args.nyt, are legitimate Timeless tokens (and not malicious contracts) with the same solution of querying the relevant factory contract that is described above for the args.gate argument. Also perform a check the args.underlying corresponds to the Timeless tokens and is not an unrelated token. | If added protection against a malicious contract calling transferFrom in an external call is needed, consider checking that the token balance held by the contract before the external call and after the external call is unchanged, reverting if this is not the case. | . Developer Response . This is fine. We assume that input validation is done on the frontend/by the caller, so user foot-gunning by giving invalid/malicious parameters is not in scope. The permissionlessness of the contract is more important to us. 3. High - Lack of slippage protection in Curve swaps (engn33r) . The Curve exchange() function has a min_dy parameter to specify the minimum amount of the output token to receive. This value is set to zero, meaning there is no slippage requirement for the swap. Lack of slippage protection can result in loss of value from frontrunning and backrunning. Technical Details . The exchange() call in _swap() in CurveV2xPYT.sol sets a minimum output token quantity of zero. This means the swap will happen regardless of how imbalanced the pool is. The only check that is applied to the quantity of tokens received is validating the amount is greater than minXpytAmountOut. The value of minXpytAmountOut does not help with slippage and is not user customizable, it only helps avoid a case where a very small (near zero) amount of of xPYT is returned. This is in contrast to where pool.exchange() is used in _swapFromUnderlying() in the swapper repository. There is a check of tokenAmountOut &lt; args.minAmountOut in Swapper.sol to check the return value of pool.exchange(). Whether the args.minAmountOut value will be calculated properly in the user interface is outside the scope of this review, but at least users have the option to specify a slippage tolerance. Similarly, the output of the swapAmountOut return value from _swapFromYieldToken() is compared against args.minAmountOut in Swapper.sol. Impact . High. Lack of slippage protection is likely to result in loss of value from MEV on larger swaps, especially because the pound() function can be called by anyone. The existing assumption is that MEV will cause this function to be called frequently so the extracted value amount is small. But this function may not be called frequently by users, which could lead to a sizeable loss of value when the function is finally called and MEV bots extract value. Recommendation . Because this function is designed to be called relatively frequently, hard code a reasonable slippage tolerance for this external function depending on the pool that is traded. The cost/benefit of using keepers from the Keeper Network or Gelato should be examined, because it may preserve more value for users (less MEV extracting value from the pound() process). Developer Response . This is by design. The description . The value of minXpytAmountOut does not help with slippage and is not user customizable, it only helps avoid a case where a very small (near zero) amount of of xPYT is returned. is incorrect. minXpytAmountOut is computed using the EMA price oracle of the Curve pool to ensure the experienced slippage is not too high. It does not “only helps avoid a case where a very small (near zero) amount of of xPYT is returned”, it works as a generalized &amp; permissionless way to limit slippage &amp; sandwiching attacks. Because pound() is permissionless by design, allowing the caller to specify slippage parameters does not help. ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#high-findings",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#high-findings"
  },"82": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "Medium Findings",
    "content": "1. Medium - Accrued rewards may not be returned to depositors (engn33r) . The claimRewards() function sends all accrued rewards for the vault to rewardRecipient. These rewards are liquidity mining incentives that sometimes provided in addition to the base APY of the pool. The contracts in the scope of review did not show how (or if) rewards from rewardRecipient would be returned to depositors. This is a possible rug pull vector where the contract deployer could steal value from users. Technical Details . The claimRewards() function is an external function without access controls, so anyone can call it. When it is called, the liquidity mining incentive rewards accrued to the aTokens held by the ERC4626 vault are sent to the address rewardRecipient. The rewardRecipient address may be a previously audited contract that is out of scope of this review, but because it is not in the scope of this review, it is not clear whether users will receive rewards claimed from this function. Impact . Medium. Depositors could lose accrued rewards that they expected to receive. Recommendation . The protocol should make it clear how users receive rewards that are swept by the claimRewards() function. Rewards should be distributed to users fairly and the contract code should demonstrate how this fairness is calculated. If users that deposited in the ERC4626 vault earlier than other users should receive more rewards, the code should illustrate this. Developer Response . This is by design. We have considered building a reward distribution system inside the Yield Daddy wrapper contracts, but decided against it. The reason is that liquidity mining incentives are usually temporary, and it’s not worth it to add significant complexity to the contracts just for it to be useless after the incentives are over. The reward tokens will be handled by Timeless as it sees fit, for example using them to incentivize yield token liquidity. 2. Medium - Bypass to add cEtherAddress to underlyingToCToken array (engn33r) . The CompoundERC4626Factory.sol constructor has an if statement to prevent cEtherAddress from being added to the underlyingToCToken array. This if statement does not exist in updateUnderlyingToCToken(), a function with no access controls, so any user can added cEtherAddress to underlyingToCToken, which bypasses the check in the constructor. Technical Details . The CompoundERC4626Factory.sol constructor has an if statement that prevents cEtherAddress from getting added to the underlyingToCToken array. The updateUnderlyingToCToken() function has a for loop very similar to the constructor, but the if statement check is missing. Because updateUnderlyingToCToken() has no access controls, anyone can use updateUnderlyingToCToken() to add the cEtherAddress to the array. This will cause problems because the CompoundERC4626.sol code assumes ERC20 tokens when using imported SafeTransferLib functions and does not use safeTransferETH() for the case where ETH is the underlying asset. Impact . Medium. The protocol is designed to support only ERC20 tokens and not ether. Adding cEther to the underlyingToCToken array could result in a denial of service problem when functions handling ether are called. Recommendation . Add the same if (address(cToken) != cEtherAddress) check from the constructor to the updateUnderlyingToCToken() function to prevent cEtherAddress from being added to the underlyingToCToken array. Developer Response . Fixed in commit 46e528a99773cf4060331cfe065cb1d781b2ff55. 3. Medium - Improper wrapEthInput() call can cause value loss (engn33r) . wrapEthInput() in Swapper.sol must be used in a multicall when an external contract is depositing ETH. If this function is called on its own or in a separate transaction, this can cause loss of value for the user who called wrapEthInput() improperly. A footgun of this type should have the risks of improper use more clearly documented or add protections against improper use. Technical Details . If a user calls wrapEthInput() as a separate transaction, ether will be converted to WETH and deposited to the Swapper.sol address. Even if the user intends to call swapUnderlyingToXpyt() or swapUnderlyingToNyt() in their next transaction, the user can be frontrun. Whoever calls swapUnderlyingToXpyt() or swapUnderlyingToNyt() while Swapper.sol holds value can extract that value because those functions use args.underlying.balanceOf(address(this)) for the value of tokenAmountIn (here and here). Impact . Medium. The risk only exists if a user improperly uses the protocol, but the protocol could add additional protections to avoid the improper usage scenario. Recommendation . Two options are possible depending if the developers want to remove the footgun entirely or leave the footgun with a better warning sign: . | To remove the footgun from the code, create _swapUnderlyingETHToXpyt() and _swapUnderlyingETHToNyt() functions that are specifically designed to handle the case where ether is sent to Swapper.sol as the underlying asset. This is the approach taken by Uniswap, which has swapExactTokensForETH() and swapETHForExactTokens() functions. | While not the recommended approach, the code can remain as is if the users are assumed to be trusted, but clearer warnings around wrapEthInput() should be added to indicate that this function can lead to loss of value if used improperly. If or when a website with developer documentation is created, add a colored “Warning” text box (similar to those in the solidity documentation) when documenting this function. | . Developer Response . This is fine. 4. Medium - ERC20 tokens sitting in contracts can be extracted (engn33r) . Any ERC20 tokens left in Swapper.sol can be extracted. Any unaccounted for asset tokens in xPYT.sol can be extracted with sweep(). This is similar to Uniswap’s V2 router, which is not intended to “hold token balances” per Uniswap documentation. This is unlikely a concern because tokens are not designed to be stored in the Swapper contract, but if the protocol is misused it can lead to loss of value for users. Technical Details . The Swapper.sol contract uses the code args.TOKEN.balanceOf(address(this)) in several places. The value of args.xPYT, args.pyt, or args.nyt can be any address, which means any token balance stored by the contract can be queried, and soon after extracted, with this code. The contract is not designed to store value, but if it does store value (say if a user accidentally sends tokens directly to the contract), the value could be extracted in a backrun transaction. A similar scenario exists with Uniswap’s V2 router, which is not designed to store any token balances but it does have non-zero token balances as seen on etherscan. Separately, sweep() in xPYT.sol is described with Uses the extra asset balance of the xPYT contract to mint shares. This can remove any extra assets of token asset that sits in the xPYT.sol contract. While less generalize than the Sweeper.sol contract, a more specific case of the same issue exists. Impact . Medium. No edge case that forcibly traps tokens in the Swapper contract was found so it is unlikely a user will expect a different result. Recommendation . Clearly document that the Swapper contract should not store any token balances, ideally in developer documentation that is more reader friendly that reading NatSpec comments directly from the source code. Developer Response . This is fine. ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#medium-findings",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#medium-findings"
  },"83": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "Low Findings",
    "content": "1. Low - Difficult to use withdraw() with full deposit (engn33r) . The withdraw() function allows users to specify the amount of assets they wish to withdraw. If a user wants to withdraw all the assets they have deposited in Yield Daddy without leaving dust, it can be hard to accurately specify their full assets value because of the constantly rebasing nature of Aave aTokens. Technical Details . Aave allows users to submit the value type(uint256).max to withdraw the user’s full balance. No similar feature is present in the Yield Daddy ERC4626 vault. This makes it hard to use withdraw() while specifying the correct value of assets to remove all aTokens from the vault because the aTokens are rebasing and increasing over time. In contrast, the redeem() function allows a user a specify the number of shares they want to withdraw. Shares are not always rebasing and are easier for a user to specify an accurate number for a complete withdrawal. Impact . Low. Recommendation . If the users are intended to call redeem() instead of withdraw() when withdrawing their entire vault deposit, this should at minimum be made clear in the documentation. If it should be possible to allow users to call withdraw() to receive their entire deposit, consider replacing this line in withdraw() with the following code: . shares = assets == type(uint256).max ? balanceOf[owner] : previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up. A similar feature to redeem all shares may be useful for redeem(). Although it may not be worth the gas cost because a user’s shares do not rebase in the same way that the underlying aTokens do, so redeem() can already allow a relatively simple way of withdrawing the entire deposit for a user. Developer Response . This is fine. The recommendation would make the wrappers not conform to the ERC-4626 specs. 2. Low - Inaccurate function return values (engn33r) . maxDeposit() and maxMint() return type(uint256).max even though that value may not be possible to deposit or mint without a revert. Most likely these functions were copied from a default ERC4626 implementation and not customized for the underlying tokens. Technical Details . The maxDeposit() and maxMint() functions only return the value type(uint256).max when the underlying pool can accept a deposit or mint. The value type(uint256).max does not accurately represent the maximum value that can be deposited into the vault when some ERC4626 tokens have already been minted. This is because the vault normally can mint a maximum of type(uint256).max, otherwise the totalSupply state variable will overflow and cause a revert, so the existing token supply should be subtracted. The same is true for aTokens, which should have the existing supply excluded. EIP4626 defines this requirement for maxMint(): . MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). The output of maxDeposit() cannot be passed into withdraw() without a revert, which does not satisfy this ERC4626 requirement. A more accurate return value for maxDeposit() in Aave V2 and Aave V3 is: . return type(uint256).max - aToken.totalSupply(); . The totalSupply value limitation of the ERC4626 vault can be ignored because the totalSupply of the vault will always be less than or equal to aToken.totalSupply(), so the aToken totalSupply is the limiting factor. The same issue is relevant for maxMint(), but the return value of maxMint() should be in units of shares instead of assets because the ERC4626 mint() function takes a shares value as input. The more accurate return value for maxMint() in Aave V2 and Aave V3 is therefore: . return convertToShares(type(uint256).max - aToken.totalSupply()); . This issue is present in the Compound ERC4626 wrapper as well. A similar solution should be applied. Impact . Low. The maxDeposit() and maxMint() are view functions that do not directly impact any state variables, but the value returned from these functions does not match the intended purposes of these functions. Recommendation . Use the above code instead of returning the constant type(uint256).max in AaveV2ERC4626.sol and AaveV3ERC4626.sol. If a vault does not allow a max of type(uint256).max in deposits, use custom math for that vault, which is already done with the supplyCap in AaveV3ERC4626.sol but not used for Aave V2. Fix the Compound wrapper with a similar approach. Developer Response . This is fine. While the ERC-4626 specs are not completely clear about what to do in this case, I’ve consulted transmissions11 and the return values of maxMint() and maxDeposit() are only supposed to differ from type(uint256).max when the ERC-4626 contract itself (or the contracts it interacts with) implements an explicit limit on deposits. Implicit limits, such as it being impossible to deposit a token with an amount greater than the token’s total supply, or it being impossible to deposit enough tokens to make the wrapper’s total supply exceed 256 bits, should not be reflected. 3. Low - No fee-on-transfer token support (engn33r) . The beforeWithdraw() and afterDeposit() functions are not implemented with fee-on-transfer tokens in mind. If one of the supported lending platforms adds a fee-on-transfer token, or an existing supported tokens enables the fee-on-transfer feature, some ERC4626 wrapper functions in yield daddy will revert. The same lack of fee-on-transfer support exists in the swapper repo. Technical Details . Fee-on-transfer tokens have the property where the value that is sent is not the same as the value that is received. This difference in logic compared to standard ERC20 tokens requires special handling in solidity to avoid a revert or loss of value. No fee-on-transfer ERC20 appears to exist on the supported lending platforms at the time of the review, but if one is added in the future or if the fee is enabled on an existing token that supports fee-on-transfer, the ERC4626 wrappers for protocols that require two separate transfers for depositing and withdrawing (Euler, Compound, Aave only for depositing) would not function with fee-on-transfer tokens because the deposit or withdraw process would revert because the fee is not accounted for in between the two transfers. The swapper repo also lacks fee-on-transfer support. This is because the tokenAmountIn value used in the safeTransferFrom() call is assumed to equal the value held by the Swapper.sol contract after the transfer takes place. This will revert when args.gate.enterWithUnderlying() is called because the underlying.safeTransferFrom() call in Gate.sol’s enterWithUnderlying() will not have sufficient balance to transfer. Impact . Low. It is unlikely that fee-on-transfer tokens would be added to these lending protocols, but if this does occur, the ERC4626 wrapper as designed would not support these fee-on-transfer tokens. Recommendation . Add support for fee-on-transfer tokens if these wrappers are intended to remain in use without modifications for an extended period of time. A solution similar to Uniswap’s swapExactTokensForTokensSupportingFeeOnTransferTokens() could enable this support. Otherwise, be mindful that future changes to tokens supported by the lending protocols could cause compatibility issues with yield daddy. Developer Response . This is fine. We have zero intentions to support fee-on-transfer tokens. 4. Low - Curve’s price_oracle() may provide less effective sandwiching protection post-merge (Benjamin Samuels) . CurveV2xPYT uses Curve’s price_oracle() function to prevent swaps from being sandwiched. Curve’s price_oracle() function is implemented using an Exponential Moving Average (EMA) filter. This filter prevents MEV extractors from manipulating the result of the price oracle, since doing so would require either a prohibitive amount of capital, or full control over multiple blocks in a row. Technical Details . In the upcoming Merge of the Ethereum mainnet, block proposers and validators are assigned randomly 2 epochs in advance. This enables an attacker with a sufficient amount of capital to fully manipulate the contents of two or more blocks in a row, undermining previous the security assumption that arbitrageurs could disrupt a multi-block oracle manipulation attack. This risk is compounded by price oracles that put more weight on recent observations, such as Curve’s EMA oracle. Impact . Low. Given the undermining of several security assumptions in TWAP/EMA price oracles, it is possible that given the correct liquidity conditions and validator assignments, an attacker can sufficiently manipulate an oracle to enable an effective, multi-block sandwich attack. While this attack has not been demonstrated in the wild yet, research is ongoing on its viability. Recommendation . An alternate mechanism for permissionless compounding is to use Keep3r Network, which operates semi-permissionlessly and can be configured to require transactions be routed through Flashbots for sandwiching protection. Given the lack of demonstrated attacks, implementing a measure such as Keep3r may be better left off to later protocol versions. Developer Response . Acknowledged. 5. Low - Insufficient SwapArgs input validation (engn33r) . swapUnderlyingToNyt() and swapUnderlyingToXpyt() in CurveV2Swapper allows a user to input a SwapArgs struct that could be custom crafted. There is no validation of the data from this struct, which could lead to unexpected consequences. Technical Details . There is no validation in _swapUnderlyingToNyt() that confirms that the addresses of args.underlying, args.nyt, args.pyt, args.xPYT, and args.vault are all related to the same underlying asset. Similarly, the value args.gate may not hold the address of the actual Gate.sol contract in the timeless protocol, but instead may be the address of an attacker’s contract. An external call is made to args.gate in _swapUnderlyingToNyt() and _swapUnderlyingToXpyt(), and although the external functions swapUnderlyingToNyt() and swapUnderlyingToXpyt() have the nonReentrant modifier, there is no global reentrancy lock across the Timeless protocol(s), so the risk of a hack involving reentrancy is not zero. Impact . Low. No direct attack vectors were observed, but lack of user input validation is often a cause for concern. Recommendation . Add multiple validation checks to confirm the SwapArgs function argument complies with certain assumptions. When possible, do not trust the function argument fully, but instead derive the necessary values using external calls to look up the necessary values using args.underlying or similar values. To reduce the number of inputs that need to be validated, at least three parameters in the SwapArgs struct can be removed and derived from existing parameters: . | args.gate is unnecessary because the proper gate can be derived using args.xPYT.gate or from args.pyt.gate | args.vault can be derived from args.xPYT.vault or from args.pyt.vault | args.nyt can be derived from args.xPYT.nyt | . Developer Response . This is by design, validation is not present to save on the gas costs of swapping. 6. Low - Curve Swap design may generate unexpected NYT/PYT dust (Benjamin Samuels) . CurveV2Swapper will leave behind unexpected dust due the use of the off-chain oracle implemented by CurveV2Juggler. Technical Details . According to the documentation, CurveV2Swapper’s swapNytToUnderlying() and swapXpytToUnderlying() functions are intended to be used in conjunction with CurveV2Juggler.juggleXpytInput() and CurveV2Juggler.juggleNytInput() respectively. These two juggle function are intended to operate as off-chain oracles which are used to calculate the correct quantities of NYT/PYT tokens to be swapped. The goal of the swap is for the user to end up with a nominally equivalent number of NYT+PYT tokens for a vault, which are then redeemed in equal amounts for xPYT tokens, which is then redeemed for the underlying vault’s token. The decoupling of the off-chain price oracle with the on-chain swap introduces a chance that the swap is executed at a different price that the price oracle expected. If a swap is executed at a different price than the oracle predicted, then the user will have differing quantities of NYT and PYT, and will have some amount of dust remaining after they redeem their NYT+PYT for xPYT. Impact . Low. As usage of the protocol increases, an increasingly large fraction of NYT/PYT redemption flows utilizing Curve swaps will generate NYT or PYT dust. In scenarios where the Curve pool’s parameters are being modified (gamma, fees, amp parameter, etc.), all swap-based redemption flows will generate dust. Recommendation . CurveJuggler currently implements a numeric solution for calculating how much NYT/PYT should be swapped. This approach consumes a large amount of gas, which is why it can only be used as an off-chain oracle. If CurveJuggler implemented an analytic solution, gas consumption may be reduced enough that the oracle can be consulted from the on-chain swap transaction. If an analytic solution is not possible, then an alternate AMM should be considered for NYT/PYT swaps. Developer Response . This is fine, since the extra dust is returned to the user. There is no analytical solution for Curve swaps, as even Curve itself uses Newton’s method to approximate the solution. 7. Low - xPYT deployment lacks trust mechanism (engn33r) . xPYT.sol is designed to allow for many xPYTs to exist for a single underlying vault. deployCurveV2xPYT() in CurveV2xPYTFactory.sol does not use CREATE2 to deploy the xPYT contract, not does it store an array or mapping of deployed xPYT contracts. This means there is no way to determine whether an address is a legitimate xPYT contract deployed by CurveV2xPYTFactory.sol or a malicious contract deployed by a third party with the same function names and interfaces. Any contracts that take a xPYT address as a function argument, including third-party contracts that want to integrate with xPYT tokens, cannot validate that the address is legitimate and must treat the contract as potentially malicious. This also means that a xPYT contract call could add risk of reentrancy or other attack vectors. Technical Details . Often the CREATE2 opcode is used to deploy contracts that depend on underlying parameters, because the address of the contract can be derived from those underlying parameters. This is the approach used in deployYieldTokenPair() of Factory.sol to deploy new NYT/PYT pairs and by Uniswap V2 to deploy new pairs. But because multiple xPYT tokens can exist for a single underlying vault, perhaps CREATE2 cannot be used in this case. There is no state variable in CurveV2xPYTFactory.sol that stores the address of deployed xPYT contracts, which means that functions that accept a xPYT address as a function argument, including several functions in Swapper.sol that have a SwapArgs.xPYT function argument, cannot determine whether the xPYT address is a legitimate xPYT token or a malicious contract. This is unlikely to impact most users who use a web interface in their browser, but it may open up an attack vector of a malicious contract posing as a legitimate xPYT token. Impact . Low. No specific proof of concept attacks were found during the allocated review time, but the lack of trust for xPYT contracts is likely a concern that should be mitigated. Recommendation . Use CREATE2 to deploy new xPYT contracts if possible, otherwise add a mechanism to validate whether an address is a legitimate xPYT token. A mapping of xPYT addresses stored in CurveV2xPYTFactory.sol is a reasonable solution for this, as found in Uniswap V2. Developer Response . Fixed in commit 5bcc2e5f053b7e7c31610b532f29720625429aa2. 8. Low - Missing PYT/NYT lookup mechanism (engn33r) . There is no good way to list all valid PYT/NYT token pairs. deployYieldTokenPair() has no access controls so anyone can call the function with their own vault and a malicious gate-like contract. If a frontend or bot creates a list of existing PYT/NYT tokens by collecting all the DeployYieldTokenPair events emitted from deployYieldTokenPair(), the list would then need to be filtered to contain only trusted gate addresses and validate the gate type corresponded to the vault type. Note that this finding is outside the scope of this review, but was still highlighted. Technical Details . The PerpetualYieldToken.sol and NegativeYieldToken.sol contracts contain many external calls to the gate contract, notably the gate.beforePerpetualYieldTokenTransfer() call in PYT’s transfer() and transferFrom() functions and the gate-protected gateMint() and gateBurn() in BaseERC20.sol. If the gate is malicious, it could leverage these callbacks for a variety of attack vectors. Impact . Low. A malicious gate address can be specified which increases the risk of several attack vectors. Recommendation . A whitelist of valid gate addresses or a similar mechanism should be added to Factory.sol to prevent PYT/NYT token pair creation with arbitrary gate addresses. An additional check should exist to validate that the vault is matched with a proper gate, otherwise an ERC20Gate may be paired with a ERC4626 token. For reference, Uniswap V2’s createPair() function only allows users to specify the two token addresses and nothing else, so users only need to trust the underlying tokens. To interact with Timeless PYT/NYT tokens as it is designed now, the user must trust the vault AND the gate, PLUS verify the gate type and vault type match. Developer Response . This is fine. Gate contracts are immutable, so malicious gate contracts are easy to avoid. We do not intend to add whitelists for contracts in order to keep the protocol permissionless. There’s no good way that can ensure a vault matches the Gate type on the smart contract level, it is assumed that the validation is done in the frontend; furthermore, there’s no incentive for people to deploy yield tokens for a mismatched Gate and vault pair. ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#low-findings",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#low-findings"
  },"84": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "Gas Savings Findings",
    "content": "1. Gas - Replace require blocks with errors (engn33r) . One require block can be replaced with a custom error for gas savings. Errors were introduced in Solidity 0.8.4 and offer a gas savings. Custom errors are already used elsewhere in the project but are not applied everywhere. Technical Details . Instances of require that can be replace with custom errors are found in: . | AaveV2 | AaveV3 | xPYT | . Impact . Gas savings. Recommendation . Use solidity custom errors instead of require statements. Developer Response . This is fine. 2. Gas - Declare variables internal, immutable, or constant when possible (engn33r) . Declaring a constant with internal visibility enables a cheaper contract deployment than public constants because public variables automatically receive a getter function. Technical Details . Many public immutable variables exist in the Euler, Aave V2, Aave V3, and Compound wrappers. If possible, make these internal instead of public for gas savings. There is one variable in xPYT.sol, assetBalance, that can be made private because it already has a public getter function in the form of totalAssets(). A variable in CurveV2xPYT.sol, curvePool, can be made immutable because it is only changed once, in the initializer. Impact . Gas savings. Recommendation . Make variables internal or private for gas savings on contract deployment. Developer Response . It’s not possible to make curvePool in CurveV2xPYT immutable, as it would create a circular dependency between the xPYT contract and the Curve pool. We’re ok with the other variables being public. 3. Gas - Remove beforeWithdraw() calls (engn33r) . An unnecessary function call can be removed. Technical Details . withdraw() and redeem() call beforeWithdraw(), but beforeWithdraw() is never implemented with code. beforeWithdraw() is declared in ERC4626.sol as an empty virtual function. The calls to beforeWithdraw() can be removed because it doesn’t run any code. Impact . Gas savings. Recommendation . Remove function calls to functions that are never implemented, specifically this line and this line. Developer Response . This is by design. It makes it easier for other contracts to inherit from it and still implement withdraw hooks. 4. Gas - Replace duplicate code with internal function (engn33r) . Certain code is duplicated. This code can be replaced with an internal function that could reduce gas costs on deployment. Technical Details . The code below is found in two places in AaveV2ERC4626.sol (here and here): . // check if pool is paused if (lendingPool.paused()) { return 0; } // check if asset is paused uint256 configData = lendingPool.getReserveData(address(asset)).configuration.data; if (!_getActive(configData)) { return 0; } . This code could be moved into an internal view function to reduce contract deployment costs. The same could be done with the similar duplicate code block (here and here). The Aave V3 wrapper has duplicate code in the same functions of maxDeposit(), maxMint(), maxWithdraw(), and maxRedeem(). Impact . Gas savings. Recommendation . Replace duplicate code with internal functions to reduce contract deployment costs. Developer Response . This won’t save gas since it’s in a view function. 5. Gas - Declare functions external for gas savings (engn33r) . The boostedBalanceOf function and deposit function of Gauge.sol should be declared external, not public, for gas savings. Technical Details . There is a public function updateUnderlyingToCToken() in CompoundERC4626Factory.sol that can be made external. Impact . Gas savings. Recommendation . Declare functions as an external functions for gas savings. Developer Response . Fixed in commit 6722541c7ae9a2c152bc90dcdb39f204af809312. 6. Gas - Use claimComp() with borrowers = false (engn33r) . There are three claimComp() functions in the Compound Comptroller contract. The one called by CompoundERC4626.sol sets borrowers = true and suppliers = true. Because the vault does not borrow from Compound, the borrowers bool can be set to false, which will save gas by skipping logic in this claimComp() function. Technical Details . claimComp() is called in claimRewards(). It can be replaced with a call to the other claimComp() function with borrowers set to false. Impact . Gas savings. Recommendation . Replace this call to claimComp() with the following code: . address[] memory holders = new address[](1); holders[0] = address(this); comptroller.claimComp(holders, cTokens, false, true); . Developer Response . Fixed in commit a53c2333f40a7e3056a7dfeec3fa994e4da37993. 7. Gas - Use unchecked if no underflow risk (engn33r) . There is a subtraction that can be made unchecked for gas savings. Technical Details . There are two subtraction operations (here and here) that should not underflow because the supplyCap should be greater than the value of totalSupply(). The Aave V3 code should be checked to confirm that there is a valid comparison to supplyCap when the supply increases. Another subtraction operation can be made unchecked in CurveV2Juggler.sol (and the out of scope UniswapV3Juggler.sol contract), found here and here. This operation can be unchecked because tokenAmountIn &gt;= (tokenAmountIn &gt;&gt; 1), and because swapAmountIn = (tokenAmountIn &gt;&gt; 1), then tokenAmountIn &gt;= swapAmountIn and tokenAmountIn - swapAmountIn &gt;= 0. Swapper.sol has two operations repeated four times that can be unchecked to save gas. A similar operation that already is unchecked is found in xPYT.sol. | Division here, here, here, and here can be unchecked because (protocolFeeInfo_.fee / 10000) &lt; 1 so it cannot overflow. uint256 feeAmount = (tokenAmountIn * protocolFeeInfo_.fee) / 10000; . | Subtraction here, here, here, and here can be unchecked because feeAmount &lt; tokenAmountIn so it cannot underflow. tokenAmountIn -= feeAmount; . | . Impact . Gas savings. Recommendation . Use unchecked where there is no overflow or underflow risk. Developer Response . Many of the suggested operations that can be made unchecked are in view functions meant to be called off chain, so gas optimization is meaningless for them. For the first point, the intermediate multiplication may overflow, so unchecked cannot be used here. The second point has been fixed in commit 9fbd20056c2bf6261524741d62ddeef2c6067d08. 8. Gas - Function arg should be calldata not memory (engn33r) . Array function arguments that are calldata are cheaper to read than arguments that are memory. Technical Details . The Compound factory contract has a memory argument that can be changed to calldata for gas savings. The same change can be made for _deployCurvePool() in CurveV2xPYTFactory.sol. Impact . Gas savings. Recommendation . Replace memory with calldata for the Compound factory function. Developer Response . The point about the Compound factory is fixed in commit 6722541c7ae9a2c152bc90dcdb39f204af809312. It makes no sense to update _deployCurvePool(), since the coins array is indeed initialized in memory and not from calldata. 9. Gas - Move revert earlier in function (engn33r) . If a function reverts, the remaining gas is returned to the user. This means that the earlier a function reverts, the more gas that could be returned to the user. Revert checks should happen as early in the function as possible. Technical Details . This revert check in the xPYT constructor can take place earlier in the constructor because it only relies on a function argument and does not rely on any other calculations. Move this if statement to immediately follow the other if statement revert check. Impact . Gas savings. Recommendation . Move revert checks earlier in functions by combining the related checks into one: . if (minOutputMultiplier_ &gt; ONE || pounderRewardMultiplier_ &gt; ONE) { revert Error_InvalidMultiplierValue(); } . Developer Response . This is fine. 10. Gas - Internal function is cheaper than modifier (engn33r) . One access control modifier in Swapper.sol could be replaced with an internal function for gas savings. Technical Details . This onlyOwner modifier could be replaced with a require check in this function or an internal function. For example, add this line to ownerSetProtocolFee() to replace the modifier on the function. require(msg.sender == owner, \"UNAUTHORIZED\"); . Impact . Gas savings. Recommendation . Replace modifiers with internal functions or require checks for gas savings. Developer Response . Acknowledged. 11. Gas - Zero check could save gas (engn33r) . There are two places where the claimable yield is calculated, but in one place the code does not confirm that yieldAmount != 0. Applying this zero check in both places where yield is calculated can provide a gas savings when yieldAmount is zero. While this finding relies on code outside the scope of this review, the in-scope contacts use this function, so it was reviewed in excess of the requested scope. Technical Details . getClaimableYieldAmount() is called once in xPYT.sol, but this function is missing a zero check for yieldAmount. The first function that calculates the claimable yield, claimYieldAndEnter(), confirms that yieldAmount != 0. The other locations where the claimable yield is calculated, getClaimableYieldAmount, does not confirm that yieldAmount != 0. This zero check could provide a gas savings in the case that yieldAmount is zero. Impact . Gas savings. Recommendation . Add the missing zero check. A longer term improvement would be to write the yield calculation logic only in one place inside a function and call this function as needed. This would avoid similar pieces of code with minor differences that could result in unexpected differences in behavior. Developer Response . Acknowledged. 12. Gas - Remove unnecessary approve (engn33r, Benjamin Samuels) . There is an unnecessary approve() call in CurveV2xPYT.sol which can be removed. Technical Details . This approve() call is designed to initialize the storage slot to a non-zero value in order to save gas on future changes of this slot. The problem is that the approve() call that happens before each swap overwrites the initial allowance value, which is subsequently consumed by the Curve swap and re-set to zero. Impact . Gas savings. Recommendation . In order for the initially approved value of 1 to remain after the swap’s transferFrom() call, the increaseAllowance() function can be used as implemented in OpenZeppelin’s ERC20 implementation. Alternatively, the approval at line 93 can be modified so it grants an approval on nytAmountIn + 1 wei; . nyt.approve(address(curvePool_), nytAmountIn + 1); . Developer Response . Fixed in commit 59c3d152da5c4af50b24edbce68db053c6bbac05. 13. Gas - Unnecessary logic in approveMaxIfNeeded() function (engn33r) . The approveMaxIfNeeded() differs from a simple token.safeApprove(spender, type(uint256).max); call by setting the allowance to zero first if the existing allowance is non-zero. This is to handle the edge case of USDT, which requires this series of actions. Because there is no other approve in the contracts that use approveMaxIfNeeded(), these extra steps are not necessary because the only approve that can happen is approving type(uint256).max. Technical Details . The contracts that call approveMaxIfNeeded() include Swapper.sol and CurveV2Swapper.sol. No other approve() or safeApprove() calls happen in these contracts, so the only allowance being set is an allowance of type(uint256).max. If the allowance is set to type(int256).max, USDT will not decrease the allowance when a transfer happens. So the process of checking the allowance and setting it to zero if the value is not type(int256).max is unnecessary and can be replaced with a simple token.safeApprove(spender, type(uint256).max); call. There might be an edge case other than USDT that the approveMaxIfNeeded() was designed for, but the function should not be necessary for USDT or standard ERC20 tokens. Impact . Gas savings. Recommendation . Remove unnecessary checks in approveMaxIfNeeded() or use a simpler safeApprove() if approval value is never set to a value other than type(uint256).max. Developer Response . Fixed in commit 14c6928f9d0efb37c4d63d9bf6f5f3b4dcb53d99. ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#gas-savings-findings",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#gas-savings-findings"
  },"85": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "Informational Findings",
    "content": "1. Informational - Direct transfer of aTokens impacts share value (engn33r) . The totalAssets() function returns the balance of aTokens held by the ERC4626 vault. Any user can transfer aTokens to the vault directly, without depositing, and alter the output values of other functions. This would be equivalent to an instantaneous spike in the aToken yield. This scenario may cause unexpected consequences with other protocols integrating with the Yield Daddy ERC4626 vaults. There is a comment for this edge case in the code. Technical Details . function totalAssets() public view virtual override returns (uint256) { // aTokens use rebasing to accrue interest, so the total assets is just the aToken balance return aToken.balanceOf(address(this)); } . The totalAssets() function in AaveV2ERC4626.sol and AaveV3ERC4626.sol is an important function. It is called in the calculations of convertToShares(), convertToAssets(), previewMint(), and previewWithdraw(). It is possible for anyone to transfer Aave aTokens directly to the vault, which would change the value returned by totalAssets(). Although such an increase in value happens normally as deposits take place or yield is earned, an instantaneous change may impact how other protocols interface with Yield Daddy ERC4626 tokens depending on how the other protocols are implemented. This comment is absent from the Compound ERC4626 wrapper, but the same edge case of a user sending tokens directly to the vault can apply. Impact . Informational. Recommendation . If a contract modification is warranted, created an internal aTokenBalance variable that is increased in afterDeposit() and decreased in withdraw() and redeem(). Most importantly, documentation should clearly highlight that a change in totalSupply() is possible from a direct transfer so other protocols interfacing with Yield Daddy ERC4626 tokens can implement their protocols accordingly. If there is a significant risk from a direct transfer of aTokens, measures can be taken to deal with this, but there is no contract upgrade process implemented in the contracts. Developer Response . Acknowledged. 2. Informational - aAMPL edge cases (engn33r) . AMPL is a rebasing token, and aAMPL is a rebasing token. The Yield Daddy vault will be exposed to two layers of rebasing, which could lead to unexpected edge cases. Aave even has a special docs page about AMPL caveats, and a similar documentation page listing caveats for Yield Daddy may be useful. Technical Details . AMPL is a rebasing token, but unlike Aave aTokens, AMPL can increase or decrease the balance that user’s hold. This website shows some recent rebasing activity in both the positive and negative directions. The ability to rebalance in either direction means that a user depositing into the Yield Daddy aAMPL vault may receive less tokens when withdrawing than when they deposited. If there are very few depositors in the aAMPL vault, a user with a large fraction of vault ownership may be able to take advantage of the timing of the AMPL rebasing (which happens once per day) at the cost of the other vault shareholders. Impact . Informational. Recommendation . Although AMPL owners should be aware of the potential for positive and negative rebasing, Yield Daddy is exposed to two levels of rebasing. Proper testing of this 2nd order effect should take place and users should be warned of possible side effects, including withdrawing fewer tokens than were deposited. Developer Response . Acknowledged. 3. Informational - Invert constant mask variables (engn33r) . There are five mask variables used only once, in the _getDecimals(), _getActive(), _getFrozen(), _getPaused(), and _getSupplyCap() functions. The mask values are constants but are only used in their inverted or negated form. Instead of negating the constants each time, the constant value should be the negated value of the current constant. This will improve readability. Technical Details . Modify the constant masks in the Aave V3 wrapper to the following: . - uint256 internal constant DECIMALS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; + uint256 internal constant DECIMALS_MASK = 0xFF &lt;&lt; 48; - uint256 internal constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; + uint256 internal constant ACTIVE_MASK = 1 &lt;&lt; 56; - uint256 internal constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; + uint256 internal constant FROZEN_MASK = 1 &lt;&lt; 57; - uint256 internal constant PAUSED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; + uint256 internal constant PAUSED_MASK = 1 &lt;&lt; 60; - uint256 internal constant SUPPLY_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; + uint256 internal constant PAUSED_MASK = 0xFFFFFFFFF &lt;&lt; 116; . Remember to remove the negation where the variables are used, so ~DECIMALS_MASK will become DECIMALS_MASK. Impact . Informational. Recommendation . Change the constant variables to their inverse values. Developer Response . This is fine. 4. Informational - Simplify logic in maxDeposit() and maxMint() (engn33r) . The logic reused in several functions in AaveV3ERC4626.sol can be simplified. Technical Details . maxDeposit() and maxMint() have logic which can be simplified: . - if (!(_getActive(configData) &amp;&amp; !_getFrozen(configData) &amp;&amp; !_getPaused(configData))) { + if (!_getActive(configData) || _getFrozen(configData) || _getPaused(configData)) { . Impact . Informational. Recommendation . Simplify boolean logic to make the code easier to read. Developer Response . This is fine. 5. Informational - Add parentheses to avoid order of operations ambiguity (engn33r) . _getActive(), _getFrozen(), and _getPaused() rely on bitwise operations taking place left to right. Because solidity version updates can sometimes alter this process, such as solidity 0.8.0 changing exponentiation from left associative to right associative, adding parentheses would help remove any ambiguity and make it clearer to readers of the code what is happening. Technical Details . These three functions have boolean logic that relies on order of operations. If this changes in a future solidity version, an incorrect value may be calculated. Applying parentheses would remove any ambiguity and make it easier to upgrade to future solidity releases with reduced concerns. function _getActive(uint256 configData) internal pure returns (bool) { - return configData &amp; ~ACTIVE_MASK != 0; + return (configData &amp; ~ACTIVE_MASK) != 0; } function _getFrozen(uint256 configData) internal pure returns (bool) { - return configData &amp; ~FROZEN_MASK != 0; + return (configData &amp; ~FROZEN_MASK) != 0; } function _getPaused(uint256 configData) internal pure returns (bool) { - return configData &amp; ~PAUSED_MASK != 0; + return (configData &amp; ~PAUSED_MASK) != 0; } . Impact . Informational. Recommendation . Removing ambiguity from important logic is a good practice. Developer Response . This is fine. 6. Informational - Inconsistent ERC4626 callback usage (engn33r) . The afterDeposit() callback is implemented in AaveV2ERC4626.sol but the beforeWithdraw() callback is not implemented. Instead of implementing the beforeWithdraw() callback, the withdraw() and redeem() function have a custom implementation to remove the need for the beforeWithdraw() callback. Ideally AaveV2ERC4626.sol should be consistent and implement both callbacks or neither. Technical Details . The default withdraw() and redeem() function implementations are overridden in AaveV2ERC4626.sol, possibly to save gas from one ERC20 token transfer. The same approach could be used for deposit() and mint() by having the user send their reserve asset directly to Aave with an onBehalfOf value in the deposit() call of the Yield Daddy vault. This may require the user to approval the Aave pool, but it would improve consistency in the Yield Daddy code. Impact . Informational. Recommendation . Consider using one approach consistently throughout the contracts. Using the more gas efficient option can improve gas efficiency. Developer Response . This is more gas efficient. 7. Informational - Some hard coded variables might be better adjustable (engn33r) . Some variables are hard coded in Yield Daddy, but making these values modifiable in functions with the onlyGovernance() modifier may make the protocol more adaptable. Technical Details . The rewardRecipient is an address that receives accrued rewards from the ERC4626 vault. This address cannot be changed in the existing AaveV2ERC4626.sol contract. Scenarios may arise where this value needs to be changed, but the contract does not currently allow this to happen. Impact . Informational. Recommendation . Making certain variables adjustable could make the contract easier to upgrade, maintain, or simply make the contract more versatile to unexpected scenarios. Another option is to set rewardRecipient to a proxy address so that the logic behind the proxy can be modified if needed. Developer Response . The contracts are not intended to be upgradeable. If a new version of the wrappers become available, existing wrapper holders can easily migrate to the new wrapper if desired. 8. Informational - Unclear upgrade mechanism (engn33r) . There is no clear upgrade mechanism if the Yield Daddy contracts needs to be upgraded. This may cause problems later on if an upgrade to the vault needs to happen. Technical Details . The Yield Daddy contracts have no clear upgrade mechanism even though some hard coded values might need changing in the future. Some examples of upgrade use cases include: . | If extra features are planned for a future Yield Daddy vault version, there is no clear path for migrating the aTokens from the existing vault. | The Yield Daddy vaults do not have a mechanism to borrow from Aave using the aTokens the vault holds. Borrowing with some amount of this collateral could allow Yield Daddy to increase the yield generated and improve the value proposition to users. Introducing such a mechanism in the future would require the vault to approve the aTokens to another address or borrowing directly from Aave, and neither option is available with the contract logic. | Aave had a referral program in the past which is now inactive, and a governance proposal could theoretically bring the program back. Even though this scenario is unlikely, if it were to happen the Aave deposit() call in Yield Daddy has a hard coded value of 0 for the referral code, so no referral rewards could be collected if the reward program is resumed by Aave. | . Impact . Informational. Recommendation . Consider the current strategy for handling a scenario where the contracts need to be upgraded and the probability of such scenarios surfacing. If necessary, make it easier to upgrade the contracts. If upgrades are not necessary, the code can be left as it is. Developer Response . The contracts are not intended to be upgradeable. If a new version of the wrappers become available, existing wrapper holders can easily migrate to the new wrapper if desired. 9. Informational - General lack of documentation and comments (engn33r) . There is no developer docs for Yield Daddy. Not all functions have NatSpec documentation. Improved documentation should be added before deployment. Technical Details . To give one example of some unclear code that should have comments, the maxRedeem() function checks how much of the reserve asset is held by the aToken address. It may not be obvious to all readers that the reason that an external protocol is queried before returning a result for Yield Daddy users is to cover the edge case where the Aave pool is undercollateralized (which is common due to Aave’s lending feature) and the Yield Daddy withdrawal would be larger than the entire Aave aToken reserve balance. A comment in the code or developer docs explaining this reasoning could expedite understanding for developers interfacing with this protocol or future code reviewers. Another place where NetSpec comments would help is clarifying that the return value of maxWithdraw() is in units of shares while the return value of maxRedeem() is in units of the underlying asset. Impact . Informational. Recommendation . Improve the Yield Daddy project documentation. Developer Response . Acknowledged. 10. Informational - Typos (engn33r) . There were some typos found in the repo. Technical Details . The Aave V2 factory contract has a comment accidentally copied from Aave V3. This should be modified to reference Aave V2. This comment about burn the xPYT should be removed or changed. It was erroneously copied from a similar function that does burn xPYT. The same applieds to this other comment in the same function. Impact . Informational. Recommendation . Fix typos. Developer Response . Fixed in commit 6c679121d2b4bacc5376c69d676928958a2b602b. 11. Informational - Aave LendingPool getConfiguration() can replace getReserveData() (engn33r) . In the Aave V2 and V3 wrappers, lendingPool.getReserveData() is used, which returns many pieces of data. These calls can be replaced with lendingPool.getConfiguration(), which returns less data. There are no gas savings because this is a view function. Technical Details . getReserveData() returns many pieces of data in Aave V2 and Aave V3. The only data needed in the wrapper contracts can be received from getConfiguration(), which returns less data in Aave V2 and Aave V3. This efficiency boost won’t save gas because it is used in a view function. Impact . Informational. Recommendation . Use more efficient external Aave call when possible. Developer Response . Acknowledged. 12. Informational - Redundant dependency imports (engn33r) . The factory contracts for each protocol (Aave V2, Aave V3, Compound, Euler) import ERC4626Factory.sol and two solmate files. The ERC4626Factory.sol contract already imports the two solmate files, so they are imported twice. A similar instance is found in StETHERC4626.sol. Technical Details . The ERC4626 factory contracts have the same redundant import of two solmate files. For example, Aave V3 imports ERC4626Factory.sol and two solmate files. But the imported base factory contract has the solmate files imported, making the import of these files redundant. StETHERC4626.sol has a similar instance of this where StETHERC4626.sol imports “solmate/tokens/ERC20.sol” and “./external/IStETH.sol”, but “solmate/tokens/ERC20.sol” is already imported by IStETH.sol making the separate import unnecessary. CurveV2Swapper.sol has a similar instance of this where CurveV2Swapper.sol imports “../Swapper.sol” and “../lib/ApproveMaxIfNeeded.sol”, but “../lib/ApproveMaxIfNeeded.sol” is already imported by Swapper.sol. The same applies to the solmate and timeless imports in CurveV2Swapper.sol. Impact . Informational. Recommendation . Remove redundant solmate file imports from Aave V2, Aave V3, Compound, and Euler factory contracts. Separately, remove StETHERC4626.sol and CurveV2Swapper.sol redundant import. Developer Response . This is by design. I want it to be obvious where each imported contract comes from in every file, so each symbol is explicitly imported from the file in which they were defined instead of importing all symbols from some other files. 13. Informational - Interface doesn’t match mainnet contract (engn33r) . The interface for mintGuardianPaused() in IComptroller.sol doesn’t match the actual Compound contract. When yield daddy ERC4626 functions that rely on this external call are called on mainnet, they will revert because the ICERC20 type must be cast to an address first. Technical Details . This is the Compound code defining the mintGuardianPaused mapping as mapping(address =&gt; bool) public mintGuardianPaused. The interface for this mapping is defined as function mintGuardianPaused(ICERC20 cToken) external view returns (bool). This is problematic because the address type is not equal to the ICERC20 type. A foundry test was created to test if this type mismatch caused a revert, but the test passed without a revert. However, the custom maxMint() and maxDeposit() functions are not tested with existing tests for Compound or Aave V3. Impact . Informational. Recommendation . Modify the interface file IComptroller.sol to match Compound’s code. Add foundry tests to confirm these functions work as expected. Developer Response . This is by design. Contract types are treated the same as address types in external calls, so it’s good to use contract types to enforce extra type checking and avoid passing in the wrong parameters. 14. Informational - Consider upgrade to latest solidity release (engn33r) . The ERC4626 wrapper contracts use solidity 0.8.13. The latest solidity release at the time of writing, 0.8.16, has improvements that could be useful to take advantage of by upgrading the release version. Technical Details . The release notes of solidity releases since 0.8.13 describe code generation bugfixes and gas optimizations that have been introduced in the more recent releases. It would be best to use the latest release unless there is a good reason to continue using 0.8.13. Impact . Informational. Recommendation . Upgrade contracts to 0.8.16 to use the recent bug fixes and optimizations. Developer Response . The Solidity pragma used is pragma solidity ^0.8.13;, which means if a newer version of Solidity has been released it would automatically be used during compilation. 15. Informational - Theoretical overflow of convertToShares() and convertToAssets() (engn33r) . The ERC4626 functions convertToShares() and convertToAssets() could overflow and revert if a very large assets input parameter value is used. This is unlikely because it requires a small denominator and a very large numerator and most tokens don’t have a supply cap that large. Technical Details . Below is the custom convertToShares() function from StETHERC4626.sol: . function convertToShares(uint256 assets) public view virtual override returns (uint256) { uint256 supply = stETH().totalSupply(); return supply == 0 ? assets : assets.mulDivDown(stETH().getTotalShares(), supply); } . If the value of the assets input parameter or the value of stETH().getTotalShares() is very close to type(uint256).max at the same time that supply is a very small value, this function could revert during the mulDivDown library call. The same is true of the convertToShares() function in the standard solmate implementation. The convertToAssets() function suffers from the same side effect in this extreme case. Impact . Informational. Recommendation . Most likely no change is needed because the revert condition is on a view function and only happens in extreme edge cases. Developer Response . Acknowledged. 16. Informational - No zero address checks in constructor (engn33r) . There is no zero address checks in the constructor of xPYT.sol. This is acceptable if it is assumed that no mistake will occur during the contract deployment, but for security purposes it is best to err on the side of caution. Technical Details . The xPYT.sol constructor sets three state variables to specific external contract addresses. No zero address check is performed, making it possible that one of these state variables could be set to the zero address. Impact . Informational. Recommendation . Add the following lines at the end of the xPYT.sol constructor. Note that storing nyt in a temporary nyt_ variable like is done with the other state variables may save gas. require(address(gate_) != address(0)); require(address(vault_) != address(0)); require(address(nyt) != address(0)); . Developer Response . This is fine. 17. Informational - Modify Gate.sol claimYieldAndEnter() function argument (engn33r) . claimYieldAndEnter() accepts four function arguments. The fourth argument is of type IxPYT, but this value is cast to an address four out of five times that it is used in the function. Consider changing this input type of address to cast this value only one time instead of four times. Technical Details . Most locations where xPYT is used, it is cast to an address with address(xPYT). Only once is it used as IxPYT type. Instead, take in a function argument of type address and cast to IxPYT the one time that this type is needed. Impact . Informational. Recommendation . Modify claimYieldAndEnter() to take a fourth argument of type address instead of type IxPYT. Developer Response . This is by design. This adds more type checking for function parameters. 18. Informational - CurveV2xPYT utilizes a non-TWAP price oracle (Benjamin Samuels) . The CurveV2xPYT implements the _getTwapQuote function, which curvePool.price_oracle() to acquire a TWAP estimation, however, curve’s price_oracle() function implements an exponential moving average (EMA) oracle. Technical Details . Curve’s price_oracle() implementation uses an exponential moving average for its oracle. EMA oracles have different properties from TWAP oracles, most notable of which is they are more sensitive to high price volatility near the time of query. Impact . Informational. Recommendation . Modify xPYT’s _getTwapQuote function name to reflect that the implementer may use a different averaging mechanism than TWAP, such as _getOracleQuote . Developer Response . This is fine. 19. Informational - Replace magic numbers with constants (engn33r) . Constant variables should be used in place of magic numbers to prevent typos. For one example, the magic number 10000 is found in multiple places in Swapper.sol and should be replaced with a constant. Using a constant also adds a description to the value to explain the purpose of the value. This will not change gas consumption. Technical Details . There are many instances of the value 10000. Consider replacing this magic number with a constant internal variable named FEE_BASE. Instances are found here, here, here, and here. Impact . Informational. Recommendation . Use constant variables instead of magic numbers. Developer Response . Acknowledged. 20. Informational - No timelock or other protection around changing fee or fee recipient (engn33r) . ownerSetProtocolFee() allows the owner to change the fee percentage and the recipient of fees. This is a centralization risk because the owner can make this change without any delay. If holders of a timeless token are promised a fraction of these fees, the owner can redirect the fees elsewhere, effectively rugging the token holders. Technical Details . ownerSetProtocolFee() allows the owner to set the fee percentage and fee recipient. While this function has access control to only allow the owner to call this function, there is no further controls to reduce centralization risk. Whether this is necessary depends on the parties who are intended to receive the fees. If users are intended to receive a fraction of the fees from Swapper.sol, they may want additional guarantees that the fees will not be redirected somewhere else without notice. Impact . Informational. Recommendation . Consider reducing centralization risk by adding a timelock to fee changes and clarifying how the multisig works. Developer Response . Acknowledged. 21. Informational - safeApprove is deprecated (Benjamin Samuels) . The safeApprove function is used in several locations across the scoped &amp; unscoped contracts. According to the OpenZeppelin documentation, it is currently deprecated. Technical Details . This function is deprecated because it can be used to manipulate a user’s allowances using specific transaction ordering. Impact . Informational. Recommendation . Consider replacing instances of safeApprove with safeIncreaseAllowance/safeDecreaseAllowance respectively. Developer Response . This is by design. Some major tokens such as USDT will revert if safeIncreaseAllowance or safeDecreaseAllowance is used, since calling approve() with a non-zero input &amp; non-zero existing allowance is not allowed. 22. Informational - Swapper repo foundry coverage failing (engn33r) . Using foundry coverage for the swapper repo results in a CompilerError message. Technical Details . While increasing code coverage does not necessarily reduce the risk of security issues, it is generally a good idea to improve code coverage for projects. Running foundry coverage in the swapper repo returns a CompilerError: Stack too deep when compiling inline assembly: Variable value0 is 1 slot(s) too deep inside the stack. error. This implies that code coverage is not being monitored or improved for the swapper issue. Impact . Informational. Recommendation . Fix the Swapper repo to enable foundry code coverage. Developer Response . Acknowledged. 23. Informational - StETHERC4626.t.sol test failing (Benjamin Samuels) . The testVaultInteractionsForSomeoneElse test for StETHERC4626.t.sol in the yield-daddy repo is failing. Technical Details . This issue is caused by the mintUnderlying call on line 188, which mints 1e18+2 of the underlying token for alice. 1e18 of these tokens are deposited to the vault on line 201, leaving behind 2 underlying tokens in alice’s account when the following assertion is made on line 205. Impact . Informational. Recommendation . Fix the test and add automatic test-on-push using Github Actions to prevent similar test failures in the future. Developer Response . Acknowledged. ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#informational-findings",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#informational-findings"
  },"86": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "Final remarks",
    "content": "engn33r . The swapper and xPYT repositories have many code paths that involve calls to contracts that were outside the scope of this review, making it difficult to guarantee the security of the in-scope contracts given the involvement of extensive out of scope code. Additionally, the swapper and xPYT contracts are written in a way that involves many code paths that make it difficult to follow for every edge case. Refactoring this code, replacing duplicated line of code with functions and making it more linear where possible, would go a long way to making the code easier to understand in future reviews. In contrast, the ERC4626 wrappers in the yield-daddy repository were relatively straightforward to review. Beyond the complexity of the code, one area in need of improvement is documentation. The documentation for the all the repositories, including the core timeless repository (which was not in the scope of this review) could be improved, especially for the xPYT and swapper repositories. Because swaps are happening between three different Timeless tokens, it is important to keep track of what units/token each variable refers to, and the lack of documentation around what units/token each variable uses makes it harder to verify the contract logic. Benjamin Samuels . Swapper, xPYT, and yield-daddy have adequate testing that would benefit greatly from an integration test suite that runs against mainnet/other network state. Integration tests currently run against locally-deployed variants, however it should be noted that many of the protocols being integrated against utilize upgradable proxies(Lido), or have different versions of their protocol deployed on different networks (Aave). Some level of mainnet integration testing can help avoid unexpected issues such as the cETH Price Oracle incident that recent impacted Compound. If future passes on the testing suite are planned, it would be advisable to standardize the invariants that are tested in the ERC4626 wrappers. The current test suite for the ERC4626 wrappers is comprehensive for some wrappers, but relatively lacking for others. Equal testing coverage would help ensure each wrapper is conforming to the properties of the official spec. The in-code naming conventions for NYT, PYT, and xPYT made auditing the system much more difficult. This convention will likely make it more challenging for integrators to develop on top of Yield Daddy, and it would be advisable to choose a more concise naming convention in future protocol versions. The Swapper repository exposes the most dynamic behavior, so some additional time was spent focusing on verifying its behavior. Several Echidna invariants were written to verify the CurveJuggler component of Swapper, the code for which is attached to this report. While Yield Daddy’s architecture is relatively complex, it is worth noting that some care was taken to decouple its components using ERC4626. This decoupling made auditing the ERC4626 contracts much simpler, and other parts of the codebase may benefit from a similar decoupling pass. ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#final-remarks",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#final-remarks"
  },"87": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "About yAcademy",
    "content": "yAcademy is an ecosystem initiative started by Yearn Finance and its ecosystem partners to bootstrap sustainable and collaborative blockchain security reviews and to nurture aspiring security talent. yAcademy includes a fellowship program, a residents program, and a guest auditor program. In the fellowship program, fellows perform a series of periodic security reviews and presentations during the program. Residents are past fellows who continue to gain experience by performing security reviews of contracts submitted to yAcademy for review (such as this contract). Guest auditors are experts with a track record in the security space who temporarily assist with the review efforts. ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/#about-yacademy",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/#about-yacademy"
  },"88": {
    "doc": "08-2022-Timeless-Yield-Daddy",
    "title": "08-2022-Timeless-Yield-Daddy",
    "content": " ",
    "url": "/reports/08-2022-Timeless-Yield-Daddy/",
    "relUrl": "/reports/08-2022-Timeless-Yield-Daddy/"
  },"89": {
    "doc": "09-2022-yFu-NFT",
    "title": "yAcademy yFu NFT review",
    "content": "Review Resources: None beyond the code repositories . Residents: . | blockdev | NibblerExpress | . ",
    "url": "/reports/09-2022-yFu-NFT/#yacademy-yfu-nft-review",
    "relUrl": "/reports/09-2022-yFu-NFT/#yacademy-yfu-nft-review"
  },"90": {
    "doc": "09-2022-yFu-NFT",
    "title": "Table of Contents",
    "content": ". | Review Summary | Scope | Findings Explanation | Medium Findings . | 1. Medium - No function to freeze transfers after unfreezing them (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | . | Low Findings . | 1. Low - Fix supportsInterface() (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | 2. Low - NFT minting might be unfair if demand is high (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | 3. Low - Add sweep functions for Ether and ERC20 tokens (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | 4. Low - Use call to transfer Ether (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | . | Gas Savings Findings . | 1. Gas - Use constant and internal variables (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | 2. Gas - Mark public functions as external (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | 3. Gas - Use OpenZeppelin’s Ownable instead of AccessControl (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | 4. Gas - Don’t transfer mint fee to depositAddress on each mint (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | 5. Gas - Use uint256 for _tokenIdCounter (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | 6. Gas - Explore solmate’s ERC721 and ERC1155 implementation (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | . | Informational Findings . | 1. Informational - Make sure to add / at the end of IPFS base URI (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | 2. Informational - _beforeTokenTransfer() should be marked as view (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | 3. Informational - Add unit tests to gain confidence (blockdev) . | Technical Details | Impact | Recommendation | Developer response | . | 4. Informational - Follow Solidity style guide (NibblerExpress) . | Technical Details | Impact | Recommendation | Developer response | . | . | Final remarks . | blockdev | NibblerExpress | . | About yAcademy | . ",
    "url": "/reports/09-2022-yFu-NFT/#table-of-contents",
    "relUrl": "/reports/09-2022-yFu-NFT/#table-of-contents"
  },"91": {
    "doc": "09-2022-yFu-NFT",
    "title": "Review Summary",
    "content": "yFu NFT . yFu is an ERC721 NFT collection where each token represents the same metadata. Minters will be able to claim a physical comic book. The main branch of the yfu-contracts Repo was reviewed over 6 days. The contract was reviewed from September 1 to September 6, 2022. The code was reviewed by 2 residents for a total of 17 hours (blockdev 13 hours, NibblerExpress 4 hours). The review was limited to one specific commit. ",
    "url": "/reports/09-2022-yFu-NFT/#review-summary",
    "relUrl": "/reports/09-2022-yFu-NFT/#review-summary"
  },"92": {
    "doc": "09-2022-yFu-NFT",
    "title": "Scope",
    "content": "Code Repo, Commit . The commit reviewed was edacf43d777a93711530b81a829099bb885f498e. The review covered the entire repository at this specific commit but focused on the only contract in the repository. After the findings were presented to the yFu team, fixes were made and included in several PRs. The review is a code review to identify potential vulnerabilities in the code. The reviewers did not investigate security practices or operational security and assumed that privileged accounts could be trusted. The reviewers did not evaluate the security of the code relative to a standard or specification. The review may not have identified all potential attack vectors or areas of vulnerability. yAcademy and the residents make no warranties regarding the security of the code and do not warrant that the code is free from defects. yAcademy and the residents do not represent nor imply to third party users that the code has been audited nor that the code is free from defects. By deploying or using the code, yFu and users of the contracts agree to use the code at their own risk. ",
    "url": "/reports/09-2022-yFu-NFT/#scope",
    "relUrl": "/reports/09-2022-yFu-NFT/#scope"
  },"93": {
    "doc": "09-2022-yFu-NFT",
    "title": "Findings Explanation",
    "content": "Findings are broken down into sections by their respective impact: . | Critical, High, Medium, Low impact . | These are findings that range from attacks that may cause loss of funds, impact control/ownership of the contracts, or cause any unintended consequences/actions that are outside the scope of the requirements | . | Gas savings . | Findings that can improve the gas efficiency of the contracts | . | Informational . | Findings including recommendations and best practices | . | . ",
    "url": "/reports/09-2022-yFu-NFT/#findings-explanation",
    "relUrl": "/reports/09-2022-yFu-NFT/#findings-explanation"
  },"94": {
    "doc": "09-2022-yFu-NFT",
    "title": "Medium Findings",
    "content": "1. Medium - No function to freeze transfers after unfreezing them (blockdev) . NFT transfers are paused when transfers_frozen = true. Such is the case on contract deployment. Addresses with DEFAULT_ADMIN_ROLE can turn it off through unfreeze_transfers() function. However, once this is called, there is no way to set transfers_frozen to true again. So the transfers cannot be frozen again. Technical Details . YFUtechne.sol#L16, YFUtechne.sol#L33-L35 . Impact . Medium. Once transfers are allowed, they cannot be turned off. Recommendation . Replace unfreeze_transfers() with: . function set_transfers_frozen(bool b) public onlyRole(DEFAULT_ADMIN_ROLE) { transfers_frozen = b; } . Developer response . This specification is intended by the product requirements. We wanted the contract to explicitly not allow transfers to be frozen again once unfrozen, so secondary market price action can flow freely without people thinking we can freeze again. ",
    "url": "/reports/09-2022-yFu-NFT/#medium-findings",
    "relUrl": "/reports/09-2022-yFu-NFT/#medium-findings"
  },"95": {
    "doc": "09-2022-yFu-NFT",
    "title": "Low Findings",
    "content": "1. Low - Fix supportsInterface() (blockdev) . YFUtechne.supportsInterface() function overrides ERC721.supportsInterface() and AccessControl.supportsInterface(): . function supportsInterface(bytes4 interfaceId) public view override(ERC721, AccessControl) returns (bool) { return super.supportsInterface(interfaceId); } . Due to how solidity inherits contracts, calling super.supportsInterface(interfaceId) will call AccessControl.supportsInterace(). So for type(IERC721).interfaceId, this function will return false. Technical Details . YFUtechne.sol#L65-L72 . Impact . Low. Even though this NFT contract implements ERC721 interface, supportsInterface() called on ERC721’s interfaceId will return false. Recommendation . Apply this diff: . function supportsInterface(bytes4 interfaceId) public view override(ERC721, AccessControl) returns (bool) { - return super.supportsInterface(interfaceId); + return ERC721.supportsInterface(interfaceId) + || AccessControl.supportsInterface(interfaceId); } . Developer response . Fixed in PR#8 . 2. Low - NFT minting might be unfair if demand is high (blockdev) . The NFT mint function has no restrictions on address who can mint, and the number of tokens minted per address. If the demand of this collection is high, someone can mint all tokens to themselves in the worst case. Technical Details . YFUtechne.sol#L41-L50 . Impact . Low. The NFT team confirmed that this should not be an issue in practice. If it happens, they’ll re-deploy the contract, perhaps after addressing this issue. Recommendation . Consider adding an address allowlist for minting. This is achieved through hashing all the addresses in a merkle tree, and storing the merkle root in the contract. Then add a max limit on total mints per address in the allowlist. Developer response . Acknowledged. We are fine with this issue. 3. Low - Add sweep functions for Ether and ERC20 tokens (blockdev) . In case, any Ether or ERC20 end up in this NFT contract’s balance, (due to user error or incorrect royalty settings on marketplaces), there’s no way to recover those funds. Technical Details . YFUtechne.sol . Impact . Low. Funds sent to this contract accidentally will be lost. Recommendation . Add functions sweepEther() and sweepERC20() which can only be called by addresses with special privileges (DEFAULT_ADMIN_ROLE). Call these functions to transfer any stuck funds out of the contract. Developer response . Fixed in PR#8 . 4. Low - Use call to transfer Ether (blockdev) . transfer() uses a fixed gas stipend to the Ether receiver. This has a benfit that it doesn’t forward enough gas to allow the receiver to do any malicious action. However, transfer() can break in case the gas cost of Ether transfer is changed in future, or if the recipient wants to perform some non-malicious action. Technical Details . YFUtechne.sol#L45: The mint fee is transferred to depositAddress as follows: . depositAddress.transfer(PRICE); . Impact . Low. If depositAddress is a contract which consumes more gas than the allocated gas stipend, mints will fail. The risk is limited as this address can be changed if that happens. Recommendation . The team should estimate on how long the minting period might go on. It’s unlikely that the gas cost of Ether transfer is changed in the short term. If the team sets the depositAddress such that it’s able to receive Ether in the gas stipend from transfer(), it’s fine to keep it as is. Otherwise, transfer Ether as follows: . (bool success, ) = depositAddress.call{value: PRICE}(\"\"); require (success, \"ETH transfer failed\"); . This would let depositAddress to reenter the contract. However, there is no risk through reentrancy, and this address is controlled by the admin. Developer response . Fixed in PR#8 . ",
    "url": "/reports/09-2022-yFu-NFT/#low-findings",
    "relUrl": "/reports/09-2022-yFu-NFT/#low-findings"
  },"96": {
    "doc": "09-2022-yFu-NFT",
    "title": "Gas Savings Findings",
    "content": "1. Gas - Use constant and internal variables (blockdev) . For constant variables for which values are known at compile time, mark them as constant to save gas. Further, they can be marked internal since getter functions are created for public variables increasing the contract size. Technical Details . YFUtechne.sol#L13-L14 . Impact . Gas savings. Recommendation . Replace the declarations of MAX_SUPPLY and PRICE with: . uint256 internal constant MAX_SUPPLY = 10; uint256 internal constant PRICE = 1 ether; . Developer response . Fixed in PR#8 . 2. Gas - Mark public functions as external (blockdev) . For public functions which are not accessed from the contract itself, marking them as external saves gas when they are called. Technical Details . YFUtechne.sol#L25-L50 . Impact . Gas savings. Recommendation . For the functions highlighted above, mark them as external instead of public. Developer response . Fixed in PR#8 . 3. Gas - Use OpenZeppelin’s Ownable instead of AccessControl (blockdev) . If there is only one role and it is only held by one address, using Ownable based access is gas-efficient than role based access control since instead of storing a nested map, a single storage variable is used. Technical Details . YFUtechne.sol#L5 . Impact . Gas savings. Recommendation . | Inherit from OpenZeppelin’s Ownable contract instead of AccessControl. | Instead of onlyRole(DEFAULT_ADMIN_ROLE), use onlyOwnable. | . Developer response . Fixed in PR#8 . 4. Gas - Don’t transfer mint fee to depositAddress on each mint (blockdev) . On each mint, 1 ether is transferred twice, first from minter to NFT contract, and then from the contract to depositAddress. This increases the gas cost of minting. Instead, the NFT contract can hold this ether which can be sweeped at once from an address with DEFAULT_ADMIN_ROLE. Technical Details . YFUtechne.sol#L45 . Impact . Gas savings. Recommendation . | Remove all functionality related to depositAddress in safeMint() function (declaration, setter function, ether transfer). | Add a function sweepEther(): function sweepEther(address payable _addr) external onlyRole(DEFAULT_ADMIN_ROLE) { (bool success, ) = _addr.call{value: address(this).balance}(\"\"); require(success, \"!sweep\"); } . | . Developer response . Fixed in PR#8 . 5. Gas - Use uint256 for _tokenIdCounter (blockdev) . Using uint256 instead of OpenZeppelin’s Counter can save gas due to less overhead of incrementing _tokenCounter. Technical Details . YFUtechne.sol#L11, YFUtechne.sol#L47-L49 . Impact . Gas savings. Recommendation . Declare _tokenIdCounter as uint256, and apply this diff: . - uint256 tokenId = _tokenIdCounter.current(); - _tokenIdCounter.increment(); - _safeMint(to, tokenId); + _safeMint(to, tokenId++); . Developer response . Fixed in PR#8 . 6. Gas - Explore solmate’s ERC721 and ERC1155 implementation (blockdev) . There are different ERC721 implementations like from OpenZeppelin, solmate, ERC721A. ERC721A gives gas benefits on batch minting, but are expensive on transfers. solmate’s ERC721 generally gives more gas savings than that of OpenZeppelin in every way. Since each token has the same image metadata, also consider exploring using ERC1155. Technical Details . solmate’s ERC721.sol, solmate’s ERC1155.sol . Impact . Gas savings. Recommendation . | Replace the use of OpenZeppelin’s ERC721 implementation with solmate’s ERC721 implementation. This is certain to give gas saving. | Consider exploring ERC1155 and compare the gas costs between the two implementations. | . Developer response . Won’t fix. ",
    "url": "/reports/09-2022-yFu-NFT/#gas-savings-findings",
    "relUrl": "/reports/09-2022-yFu-NFT/#gas-savings-findings"
  },"97": {
    "doc": "09-2022-yFu-NFT",
    "title": "Informational Findings",
    "content": "1. Informational - Make sure to add / at the end of IPFS base URI (blockdev) . The tokenURI() function appends token ID to the IPFS base URI, hence it’s important to note that the URI should have / at the end of it to have a well-formed tokenURI. Technical Details . OpenZeppelin’s ERC721.sol#L97 . Impact . Informational. Recommendation . Make sure to add / at the end of IPFS base URI. Developer response . Acknowledged . 2. Informational - _beforeTokenTransfer() should be marked as view (blockdev) . Functions which only read storage space should be marked as view. Solidity compiler also warns about this at compile time. Technical Details . YFUtechne.sol#L52 . Impact . Informational. Recommendation . Mark _beforeTokenTransfer() as view. Developer response . Fixed in PR#8 . 3. Informational - Add unit tests to gain confidence (blockdev) . Unit tests helps to catch bugs early on and future-proofs a contract from bugs that are introduced later. Technical Details . YFUtechne.sol . Impact . Informational. Recommendation . Use any popular development environment for unit testing and local fork testing. Some things to test for would be: . | The maximum number of tokens does not exceed MAX_LIMIT. | Only token owners and approved addresses can transfer NFT. | Fee is charged on mint. | tokenURI() works correctly. | name and symbol is correct. | Access controlled function can only be called by approved addresses. | . We have separately provided a publicly available, MIT licensed NFT repository as a reference for unit tests. After unit testing, test the project on a test network before mainnet deployment. Developer response . Acknowledged . 4. Informational - Follow Solidity style guide (NibblerExpress) . Some function and variable names do not follow the naming conventions of the Solidity style guide (e.g., set_deposit_address() rather than setDepositAddress()). The naming conventions of the style guide are available here: https://docs.soliditylang.org/en/v0.8.14/style-guide.html#naming-conventions . Technical Details . YFUtechne.sol . Impact . Informational. Recommendation . Change variable and function names to mixedCase for readability. Developer response . Acknowledged . ",
    "url": "/reports/09-2022-yFu-NFT/#informational-findings",
    "relUrl": "/reports/09-2022-yFu-NFT/#informational-findings"
  },"98": {
    "doc": "09-2022-yFu-NFT",
    "title": "Final remarks",
    "content": "blockdev . The contract is pretty short and avoids complexity. No major risks were found. NibblerExpress . There is some minor clean-up to be done, but the code otherwise relies on highly used standards that are likely to be secure. ",
    "url": "/reports/09-2022-yFu-NFT/#final-remarks",
    "relUrl": "/reports/09-2022-yFu-NFT/#final-remarks"
  },"99": {
    "doc": "09-2022-yFu-NFT",
    "title": "About yAcademy",
    "content": "yAcademy is an ecosystem initiative started by Yearn Finance and its ecosystem partners to bootstrap sustainable and collaborative blockchain security reviews and to nurture aspiring security talent. yAcademy includes a fellowship program, a residents program, and a guest auditor program. In the fellowship program, fellows perform a series of periodic security reviews and presentations during the program. Residents are past fellows who continue to gain experience by performing security reviews of contracts submitted to yAcademy for review (such as this contract). Guest auditors are experts with a track record in the security space who temporarily assist with the review efforts. ",
    "url": "/reports/09-2022-yFu-NFT/#about-yacademy",
    "relUrl": "/reports/09-2022-yFu-NFT/#about-yacademy"
  },"100": {
    "doc": "09-2022-yFu-NFT",
    "title": "09-2022-yFu-NFT",
    "content": " ",
    "url": "/reports/09-2022-yFu-NFT/",
    "relUrl": "/reports/09-2022-yFu-NFT/"
  },"101": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "yAcademy NounsDAO Token Buyer review",
    "content": "Review Resources: Code Repo, Spec . Residents: . | NibblerExpress | blockdev | . ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#yacademy-nounsdao-token-buyer-review",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#yacademy-nounsdao-token-buyer-review"
  },"102": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "Table of Contents",
    "content": ". | Review Summary | Scope | Code Evaluation Matrix | Findings Explanation | High Findings . | 1. High - Price range should be within Chainlink’s range (blockdev, NibblerExpress) . | Technical Details | Impact | Recommendation | Developer Response | . | . | Medium Findings . | 1. Medium - ETH buyer pays the gas cost of debt payments (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | . | Low Findings . | 1. Low - Can require the basis point values to be less than 10_000 (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 2. Low - Use a two-step Ownership transfer pattern (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 3. Low - Existing debts should be prioritized in sendOrRegisterDebt() (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 4. Low - Risk of USDC depeg (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 5. Low - Fee-on-transfer token not supported (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | . | Gas Savings Findings . | 1. Gas - Replace owner() with msg.sender in withdrawPaymentToken() (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 2. Gas - Cache totalDebt in payBackDebt() (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 3. Gas - Use _debtAmount instead of debt.amount (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 4. Gas - DebtQueue.empty() can just check for equality (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 5. Gas - Precompute decimal factor to save gas and avoid magic numbers (NibblerExpress) . | Technical Details | Impact | Recommendation | Developer Response | . | . | Informational Findings . | 1. Informational - TokenBuyer may not use the entire received amount to pay the debt (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 2. Informational - TokenBuyer’s constructor can fetch paymentToken from payer (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 3. Informational - DebtDeque’s _begin and _end can be uint128 (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 4. Informational - Review tokens before supporting them via TokenBuyer (blockdev) . | Technical Details | Impact | Recommendation | Developer Response | . | 5. Informational - onlyAdmin() is not used (NibblerExpress) . | Technical Details | Impact | Recommendation | Developer Response | . | 6. Informational - Consider solidity 0.8.16 or higher (NibblerExpress) . | Technical Details | Impact | Recommendation | Developer Response | . | 7. Informational - Consider adding events for creating and paying back the debt if the debt is paid back on creation (invader-tak) . | Technical Details | Impact | Recommendation | Developer Response | . | . | Final remarks . | blockdev | NibblerExpress | . | About yAcademy | . ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#table-of-contents",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#table-of-contents"
  },"103": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "Review Summary",
    "content": "NounsDAO Token Buyer . TokenBuyer’s purpose is to allow the NounsDAO to pay the proposals with ERC20 tokens. Since trading a large portion of ETH incurs slippage and is susceptible to sandwich attacks, this protocol uses Chainlink oracle to fetch ETH prices and allow anyone to sell their tokens against ETH. The contracts of Token Buyer Repo were reviewed over 7 days, 1 day of which was used to create an initial overview of the contract. The code review was performed between October 11, 2022 and October 18, 2022. The code was reviewed by 2 residents for a total of 32 review hours (NibblerExpress 8 hours, blockdev 24 hours). The review was limited to the latest commit at the start of the review. This was commit 23d64ac7093f504ad4731bc4cf8d41b2c2943657 for the token-buyer repo. ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#review-summary",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#review-summary"
  },"104": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "Scope",
    "content": "The scope of the review consisted of the following contracts at the specific commit: . | TokenBuyer.sol | PriceFeed.sol | Payer.sol | . After the findings were presented to the NounsDAO team, fixes were made and included in several PRs. This review is a code review to identify potential vulnerabilities in the code. The reviewers did not investigate security practices or operational security and assumed that privileged accounts could be trusted. The reviewers did not evaluate the security of the code relative to a standard or specification. The review may not have identified all potential attack vectors or areas of vulnerability. yAcademy and the residents make no warranties regarding the security of the code and do not warrant that the code is free from defects. yAcademy and the residents do not represent nor imply to third parties that the code has been audited nor that the code is free from defects. By deploying or using the code, NounsDAO and users of the contracts agree to use the code at their own risk. ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#scope",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#scope"
  },"105": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "Code Evaluation Matrix",
    "content": "| Category | Mark | Description | . | Access Control | Good | Privileged functionality is restricted to the owner and admin. | . | Mathematics | Good | Decimal adjustment is done to convert between Oracle price and wad decimal. | . | Complexity | Good | Responsibilities are separated which reduces complexity. | . | Libraries | Good | Queue library from Open Zeppelin is modified to fit the need, others are imported. | . | Decentralization | Good | Core protocol functions are permissionless. | . | Code stability | Good | Changes were reviewed at a specific commit hash and the scope was not expanded after the review was started. The code reviewed had all features implemented. | . | Documentation | Good | Descriptive NatSpec comments are found in the interface contracts. The comments accurately describe the function. The spec contains helpful information about the intended use and purpose. | . | Monitoring | Average | Events are used. | . | Testing and verification | Good | Forge tests have high coverage and a deploy script is used. | . ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#code-evaluation-matrix",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#code-evaluation-matrix"
  },"106": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "Findings Explanation",
    "content": "Findings are broken down into sections by their respective impact: . | Critical, High, Medium, Low impact . | These are findings that range from attacks that may cause loss of funds, impact control/ownership of the contracts, or cause any unintended consequences/actions that are outside the scope of the requirements | . | Gas savings . | Findings that can improve the gas efficiency of the contracts | . | Informational . | Findings including recommendations and best practices | . | . ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#findings-explanation",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#findings-explanation"
  },"107": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "High Findings",
    "content": "1. High - Price range should be within Chainlink’s range (blockdev, NibblerExpress) . PriceFeed is already deployed at 0x4050Cd1eDDB589fe26B62F8859968cC9a415cE7F according to the deploy script. priceLowerBound is set to $100 * 10^{18}$, and priceUpperBound is set to $100,000 * 10^{18}$ which translate to $100 and $100K respectively. This is the Chainlink oracle PriceFeed is using: 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 which uses this aggregator: 0x37bC7498f4FF12C19678ee8fE19d713b87F6a9e6. minAnswer and maxAnswer values from this aggregator are: $1 * {10^8}$ and $10,000 * {10 ^ 8}$ which translate to $1 and $10K. Chainlink will never report prices outside this range. Hence, the upper bound of $100K set in PriceFeed is not useful as the check priceWad &gt; priceUpperBound is always false: . if (priceWAD &lt; priceLowerBound || priceWAD &gt; priceUpperBound) { revert InvalidPrice(priceWAD); } . Technical Details . PriceFeed.sol#L93 . Impact . High. If the market price moves above the upper bound specified by Chainlink, TokenBuyer will allow trades in the loss for Nouns DAO until the staleness check kicks in. staleAfter is set to 1 hour currently. Recommendation . Set priceUpperBound to a value &lt; $10,000 * 10^{18}$. Chainlink reports a new price in two scenarios: . | The price moves beyond a certain deviation threshold. | The price has not been reported within a certain amount of time (aka heartbeat). | . Suppose you set your upper bound to $9K, and the market price movement is say from point $8K to $11K. There are 2 scenarios: . | the price directly jumped from $8K to $11K, then the upper bound won’t be useful and only the staleness check will protect from trading. In this case, priceUpperBound is useless in both cases (in the current code and the recommendation). | the price moves from $8K -&gt; $9.5K -&gt; $11K, in this case, priceUpperBound will prevent TokenBuyer from making any trades. However, the current code will let it trade at $9.5K until the staleness check comes in. And this is a more likely scenario as Chainlink reports a price quickly when it moves above a certain deviation. | . Developer Response . Our current path forward will be to set the cap at $8K, and in the future upgrade the price feed to check the diff between Chainlink and Univ3 TWAP and revert in case of a big difference. ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#high-findings",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#high-findings"
  },"108": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "Medium Findings",
    "content": "1. Medium - ETH buyer pays the gas cost of debt payments (blockdev) . buyETH() function calls payBackDebt() which iterates over the queue and pays the debt of the first few elements. Iterating over the queue is a gas-intensive operation. If the queue is long relative to the buy amount, it may discourage the buyers as the extra gas costs may overshadow the discount. Technical Details . TokenBuyer.sol#L195, TokenBuyer.sol#L235 . Impact . Medium. The extra gas costs may disincentivize trading through TokenBuyer. Recommendation . Consider removing the debt payment in buyETH() functions. Anyone can call payBackDebt() separately for debt payments. Note: With this change, you can also consider calling payBackDebt() at the beginning of sendOrRegisterDebt() since the debt in the queue should be paid first. Developer Response . Acknowledged, won’t fix. We are aware of this issue and prefer to use it as is in order to ensure better UX by not needing anyone to manually call payBackDebt(). We expect the queue to remain short at all times. In case the queue becomes longer, we can adjust the discount parameter to increase incentives for trading. ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#medium-findings",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#medium-findings"
  },"109": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "Low Findings",
    "content": "1. Low - Can require the basis point values to be less than 10_000 (blockdev) . TokenBuyer takes several constructor arguments which are denominated in basis points. Constructor can require them to be &lt; 10_000 to be safe. Technical Details . TokenBuyer.sol#L146-L148 . Impact . Low. price() will return incorrect values in this case, however since the likelihood of this happening is low, the overall impact is limited. Recommendation . Consider either: . | Adding require checks in TokenBuyer constructor to assert that all the basis point values are &lt; 10_000. | Adding these require checks in forge script. | . Developer Response . Fixed in commit 5e252d6. 2. Low - Use a two-step Ownership transfer pattern (blockdev) . If a wrong address is passed to the function transferOwnership(), privileged functionality is permanently lost. Technical Details . TokenBuyer.sol, Payer.sol . Impact . Low. Recommendation . Consider implementing a two-step ownership transfer where the proposed new owner has to explicitly accept the role. OpenZeppelin now provides this functionality via Ownable2Step.sol . Developer Response . Acknowledged, won’t fix. We intend for the owner of the contracts to be the nouns timelock, so any ownership transfer will go through a proposal process with ample time to check for errors. In addition, when we transfer the ownership to the DAO the first time, we don’t want to go through a proposal process in order to accept the ownership. 3. Low - Existing debts should be prioritized in sendOrRegisterDebt() (blockdev) . sendOrRegisterDebt(account, amount) uses current token balance to pay account. In the current design, any new balance bought through TokenBuyer pays the existing debt. So if Payer has a balance, it means that all the existing debt was cleared, or the payment token was directly transferred to it. In the second case, the token balance is used to pay account bypassing the existing debt in the queue. Technical Details . Payer.sol#L100 . Impact . Low. Since the existing debt takes priority over the new debt, it should be paid first. It may also be seen as impartiality towards a party. Recommendation . sendOrRegisterDebt() can first call payBackDebt() and then proceed to pay the current account with the remaining amount. Developer Response . Acknowledged, won’t fix. We don’t plan to send funds to the Payer not through the TokenBuyer. In case it does happen, we can manually trigger payBackDebt(). 4. Low - Risk of USDC depeg (blockdev) . PriceFeed uses Chainlink oracle of ETH/USD for payment token USDC. This assumes that USDC is always pegged to $1. In the case that the USDC price moves below $1, TokenBuyer will make trades at a loss. Technical Details . DeployTokenBuyer.s.sol . Impact . Low. USDC depegging can be considered an unlikely event. However, in case that happens, all the ETH locked in TokenBuyer will be making trades at a loss. Recommendation . Consider using Chainlink’s USDC/ETH oracle. Another option is to monitor USDC price off-chain and pause the contract in case it depegs. However, the risk is that the pause transaction can be frontrun by trade transactions. Developer Response . Acknowledged, won’t fix. We prefer to use the ETH/USD oracle because of the significantly shorter heartbeat (1 hr vs 24 hrs). We are aware of the depeg risk and consider it very low for USDC. 5. Low - Fee-on-transfer token not supported (blockdev) . The payment token is assumed to send the full amount to the receiver on a transfer. However, if a token like USDT turns on a fee in the future, it can break accounting logic. Technical Details . TokenBuyer.sol . Impact . Low. The payment token is defined by the deployer. The deployer can ensure the payment token does not and cannot take a fee on transfer (like USDT). The current code is fine for such an ERC20. However, if a fee-on-transfer ERC20 is used as the payment token, the code should be updated to handle the fee. Recommendation . Consider one of the following two approaches: . | Either ensure off-chain before deploying that the payment token is not a fee-on-transfer token. | Update the contract logic to calculate the tokens transferred by checking the token balance before and after a transfer. | . Developer Response . Acknowledged, won’t fix. We don’t plan to use any tokens with fee-on-transfer in the near future. If we do, we will revise the logic. ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#low-findings",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#low-findings"
  },"110": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "Gas Savings Findings",
    "content": "1. Gas - Replace owner() with msg.sender in withdrawPaymentToken() (blockdev) . In onlyOwner functions, owner() is always equal to msg.sender, otherwise it reverts. In these cases, using msg.sender instead of owner() saves gas since it prevents expensive storage read. Technical Details . Payer.sol#L123 . Impact . Gas savings. Recommendation . Replace owner() with msg.sender: . function withdrawPaymentToken() external onlyOwner { - address to = owner(); + address to = msg.sender; . Developer Response . Fixed in commit 906a3d3. 2. Gas - Cache totalDebt in payBackDebt() (blockdev) . In each iteration of the loop in payBackDebt(), the storage variable totalDebt is updated. Updating it only once at the end is a cheaper alternative since it updates storage only once. Technical Details . Payer.sol#L158, Payer.sol#L173 . Impact . Gas savings. Recommendation . Consider doing the following: . | Cache totalDebt at the beginning. | Accumulate total debt paid in a separate variable. | break instead of returning in the if condition. | Update totalDebt at the end. | . Developer Response . Fixed in commit a4c601e. 3. Gas - Use _debtAmount instead of debt.amount (blockdev) . Avoiding storage reads saves gas. Here, debt.amount can be replaced with _debtAmount. uint96 _debtAmount = debt.amount; address _debtAccount = debt.account; if (amount &lt; _debtAmount) { // Not enough to cover entire debt, pay what you can and leave // cast is safe because `amount` &lt; `_debtAmount` (uint96) uint96 remainingDebt = debt.amount - uint96(amount); . Technical Details . Payer.sol#L146-L152 . Impact . Gas savings. Recommendation . Apply this diff: . -uint96 remainingDebt = debt.amount - uint96(amount); +uint96 remainingDebt = _debtAmount - uint96(amount); . Developer Response . Fixed in commit 14343d9. 4. Gas - DebtQueue.empty() can just check for equality (blockdev) . Unless _end overflows, _begin &lt;= _end is an invariant. DebtQueue also mentions this in a comment: . // The interface preserves the invariant that begin &lt;= end . Hence, . function empty(DebtDeque storage deque) internal view returns (bool) { return deque._end &lt;= deque._begin; } . can be gas optimized by just checking _end == _begin. Technical Details . DebtQueue.sol#L112 . Impact . Gas savings. Recommendation . Apply this diff: . function empty(DebtDeque storage deque) internal view returns (bool) { - return deque._end &lt;= deque._begin; + return deque._end == deque._begin; } . Developer Response . Acknowledged, won’t fix. To our understanding, the gas optimization here is very minor. We prefer to make less changes to the OZ Queue lib for such small gas gain. 5. Gas - Precompute decimal factor to save gas and avoid magic numbers (NibblerExpress) . The function ethAmountPerTokenAmount() calculates ((tokenAmount * 1e36) / price()) / paymentTokenDecimalsDigits. The function could save gas and avoid using the magic number 1e36 by having the constructor precompute a decimal factor equal to Eth decimals * price decimals / payment token decimals (i.e., 1e36/paymentTokenDecimalsDigits). The factor could also be used in tokenAmountPerEthAmount(). This should be fine for USDC which only has 6 decimals. However, for payment tokens with high decimals, this can lead to precision loss. Technical Details . TokenBuyer.sol#L292, TokenBuyer.sol#L323 . Impact . Gas savings. Recommendation . Depending on the future plan, if only USDC is being used as a payment token, precompute the decimal factor as discussed above. Developer Response . Acknowledged, won’t fix. We prefer to keep the implementation agnostic to the number of decimals used in the token and not make any assumptions. ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#gas-savings-findings",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#gas-savings-findings"
  },"111": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "Informational Findings",
    "content": "1. Informational - TokenBuyer may not use the entire received amount to pay the debt (blockdev) . buyETH(tokenAmount, to, data) transfers tokensReceived amount of payment token to payer, but only uses amount to pay debt. If tokensReceived &gt; amount, more debt can be paid if tokenReceived is used. Additionally, the event emitted is incorrect: . _payer.payBackDebt(amount); emit SoldETH(to, ethAmount, amount); . Technical Details . TokenBuyer.sol#L235-L237 . Impact . Informational. Anyone can call payBackDebt(), so even if a lower amount is used it just takes one more transaction to pay debt using the remaining received tokens. In reality, the extra tokens received will likely be dust. Recommendation . Apply this diff to line 235: . -_payer.payBackDebt(amount); +_payer.payBackDebt(tokensReceived); -emit SoldETH(to, ethAmount, amount); +emit SoldETH(to, ethAmount, tokenReceived); . Developer Response . Fixed in commit 96a3fb0. 2. Informational - TokenBuyer’s constructor can fetch paymentToken from payer (blockdev) . TokenBuyer’s constructor takes paymentToken as an argument. However, it can be fetched from payer which is another argument. This prevents deployment errors. Technical Details . TokenBuyer.sol#L153 . Impact . Informational. If deployment is correct, this won’t be an issue. Recommendation . Fetch paymentToken info from payer in constructor: . paymentToken = payer.paymentToken(); . Developer Response . Fixed in commit 9f744fb. 3. Informational - DebtDeque’s _begin and _end can be uint128 (blockdev) . DebtDeque’s Natspec says: . Indices are signed integers because the queue can grow in any direction. However, it isn’t possible to have negative indices if _end is initially 0. _begin and _end are always incremented by 1 via popFront() and pushBack(), and the assumption is that this won’t overflow: . * Since the items are added one at a time we can safely * assume that these 128-bit indices will not overflow, and use unchecked arithmetic. Technical Details . DebtQueue.sol#L30-L44 . Impact . Informational. Recommendation . Use uint128 for _begin, _end, and _data key. Developer Response . Acknowledged, won’t fix. Since we don’t gain much from the suggested change, we prefer to keep it close to the original OZ Queue code. 4. Informational - Review tokens before supporting them via TokenBuyer (blockdev) . NounsDAO team has indicated that tokens like USDC or DAI are planned to be supported via this system. However, if more tokens are planned like ERC-777, or fee-on-transfer tokens, the team should review the implementation to make sure the system remains secure. This issue does not apply to payment tokens like USDC, DAI, WETH. However, functions like sendOrRegisterDebt() and payBackDebt() are open for reentrancy via safeTransfer() if other tokens are considered. Technical Details . Repo . Impact . Informational. For stablecoins like USDC and DAI, this issue does not surface any security vulnerability. Recommendation . Consider reviewing any new payment token being considered for reentrancy attacks and any fee. Also, note the issue “Fee-on-transfer token not supported”. Developer Response . Acknowledged. 5. Informational - onlyAdmin() is not used (NibblerExpress) . The modifier onlyAdmin() is not used. The modifier onlyAdminOrOwner() is used for all functions the admin can call. Technical Details . TokenBuyer.sol#L120-L125 . Impact . Informational. Recommendation . Delete the onlyAdmin() modifier and error. Developer Response . Fixed in commit 05839da. 6. Informational - Consider solidity 0.8.16 or higher (NibblerExpress) . Solidity 0.8.16 or 0.8.17 is currently recommended over 0.8.15. Technical Details . Example: TokenBuyer.sol#L16 . Impact . Informational. Vulnerabilities in 0.8.15 do not appear to be present in the code. Recommendation . Use solidity 0.8.16 or higher. Developer Response . Fixed in commit 09c7101. 7. Informational - Consider adding events for creating and paying back the debt if the debt is paid back on creation (invader-tak) . The function sendOrRegisterDebt() in the Payer.sol contract can under certain circumstances get and pay back a debt during its call - presumably, this is done to save the gas to register the debt and calling the payBackDebt function - This may cause complications for data collection, as no RegisteredDebt or PaidBackDebt events are emitted, especially when using services such as the Graph or Dune analytics. Technical Details . Payer.sol#L100 . Impact . Informational. Streamline data collection for protocol. Recommendation . Add a RegisteredDebt and PaidBackDebt, or a separate event for a registered debt that gets paid back during registration. Developer Response . We are assuming we can use ERC20 transfer events to track flow of funds, and use the debt related events just for cases when funds are delayed which can be helpful for tracking things like the time it takes to pay back debt or how often we are in debt. ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#informational-findings",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#informational-findings"
  },"112": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "Final remarks",
    "content": "blockdev . Responsibilities are split in different contracts, and the code is well documented making it easy to understand. NibblerExpress . The code allows any user to swap payment tokens for ETH, which has a high risk. Using pausable, nonreentrant, and Chainlink oracles mitigate much of the risk. Overall, the code is well organized and commented on. ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#final-remarks",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#final-remarks"
  },"113": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "About yAcademy",
    "content": "yAcademy is an ecosystem initiative started by Yearn Finance and its ecosystem partners to bootstrap sustainable and collaborative blockchain security reviews and to nurture aspiring security talent. yAcademy includes a fellowship program, a residents program, and a guest auditor program. In the fellowship program, fellows perform a series of periodic security reviews and presentations during the program. Residents are past fellows who continue to gain experience by performing security reviews of contracts submitted to yAcademy for review (such as this contract). Guest auditors are experts with a track record in the security space who temporarily assist with the review efforts. ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/#about-yacademy",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/#about-yacademy"
  },"114": {
    "doc": "10-2022-NounsDAO-Token-Buyer",
    "title": "10-2022-NounsDAO-Token-Buyer",
    "content": " ",
    "url": "/reports/10-2022-NounsDAO-Token-Buyer/",
    "relUrl": "/reports/10-2022-NounsDAO-Token-Buyer/"
  },"115": {
    "doc": "12-2022-Gro-Protocol",
    "title": "yAcademy Gro Protocol Review",
    "content": "Review Resources: . | Current Gro Protocol docs | . Residents: . | engn33r | usmannk | . ",
    "url": "/reports/12-2022-Gro-Protocol/#yacademy-gro-protocol-review",
    "relUrl": "/reports/12-2022-Gro-Protocol/#yacademy-gro-protocol-review"
  },"116": {
    "doc": "12-2022-Gro-Protocol",
    "title": "Table of Contents",
    "content": ". | Review Summary | Scope | Code Evaluation Matrix | Findings Explanation | Critical Findings | High Findings . | 1. High - Underflow in int256 -&gt; uint256 conversion . | Technical Details | Impact | Recommendation | Developer Response | . | . | Medium Findings . | 1. Medium - sellAllRewards() reverts with non-zero numberOfRewards . | Technical Details | Impact | Recommendation | Developer Response | . | 2. Medium - wethAmount in rewards calculations should be balanceOf . | Technical Details | Impact | Recommendation | Developer Response | . | 3. Medium - Tranche deposit/withdrawal denial of service . | Technical Details | Impact | Recommendation | Developer Response | . | 4. Medium - Unreliable Senior Tranche yield . | Technical Details | Impact | Recommendation | Developer Response | . | 5. Medium - Timing mismatch between time-gated actions . | Technical Details | Impact | Recommendation | Developer Response | . | 6. Medium - Whale invest() and divest() denial of service (DoS) . | Technical Details | Impact | Recommendation | Developer Response | . | . | Low Findings . | 1. Low - Strategy migration should remove old approvals . | Technical Details | Impact | Recommendation | Developer Response | . | 2. Low - Inconsistent ERC20 imports . | Technical Details | Impact | Recommendation | Developer Response | . | 3. Low - Similar functions have different logic . | Technical Details | Impact | Recommendation | Developer Response | . | 4. Low - ConvexStrategy owner can sweep tokens . | Technical Details | Impact | Recommendation | Developer Response | . | 5. Low - Inconsistent minimum reward amount . | Technical Details | Impact | Recommendation | Developer Response | . | 6. Low - Inconsistent metapool fee inclusion . | Technical Details | Impact | Recommendation | Developer Response | . | 7. Low - Potentially incorrect branching logic . | Technical Details | Impact | Recommendation | Developer Response | . | 8. Low - setStrategies() doesn’t set strategyCheck values . | Technical Details | Impact | Recommendation | Developer Response | . | 9. Low - Weak oracle result staleness check in staleCheck() . | Technical Details | Impact | Recommendation | Developer Response | . | 10. Low - No minDeposit in GTranche . | Technical Details | Impact | Recommendation | Developer Response | . | 11. Low - Volatile token price causes higher vault fees . | Technical Details | Impact | Recommendation | Developer Response | . | 12. Low - High default slippage tolerance . | Technical Details | Impact | Recommendation | Developer Response | . | . | Gas Savings Findings . | 1. Gas - Use prefix in loops . | Technical Details | Impact | Recommendation | Developer Response | . | 2. Gas - Unnecessary zero initializations . | Technical Details | Impact | Recommendation | Developer Response | . | 3. Gas - Use simple comparison . | Technical Details | Impact | Recommendation | Developer Response | . | 4. Gas - Remove redundant check . | Technical Details | Impact | Recommendation | Developer Response | . | 5. Gas - Use Solidity errors in 0.8.4+ . | Technical Details | Impact | Recommendation | Developer Response | . | 6. Gas - Declare variables immutable when possible . | Technical Details | Impact | Recommendation | Developer Response | . | 7. Gas - Use unchecked if no underflow risk . | Technical Details | Impact | Recommendation | Developer Response | . | . | Informational Findings . | 1. Informational - Unusual minDeposit choice . | Technical Details | Impact | Recommendation | Developer Response | . | 2. Informational - Fees may be sent to address(0) . | Technical Details | Impact | Recommendation | Developer Response | . | 3. Informational - Missing _minAmount check in redeem . | Technical Details | Impact | Recommendation | Developer Response | . | 4. Informational - _owner argument shadows Ownable state variable . | Technical Details | Impact | Recommendation | Developer Response | . | 5. Informational - Junior tranche lacks immediate withdrawal guarantees . | Technical Details | Impact | Recommendation | Developer Response | . | 6. Informational - Change call sequence for reentrancy mitigation . | Technical Details | Impact | Recommendation | Developer Response | . | 7. Informational - Undocumented assumption of private Gelato mempool . | Technical Details | Impact | Recommendation | Developer Response | . | 8. Informational - Inconsistent interface files . | Technical Details | Impact | Recommendation | Developer Response | . | 9. Informational - Inconsistent Uniswap array indices . | Technical Details | Impact | Recommendation | Developer Response | . | 10. Informational - _additionalRewardTokens() works in unexpected way . | Technical Details | Impact | Recommendation | Developer Response | . | 11. Informational - Non-ideal _sellAdditionalRewards() min reward limit . | Technical Details | Impact | Recommendation | Developer Response | . | 12. Informational - Strategy migration logic can revert . | Technical Details | Impact | Recommendation | Developer Response | . | 13. Informational - Theoretical casting overflow . | Technical Details | Impact | Recommendation | Developer Response | . | 14. Informational - Differing approach to keeper role . | Technical Details | Impact | Recommendation | Developer Response | . | 15. Informational - Duplicate strategies possible with setStrategies() . | Technical Details | Impact | Recommendation | Developer Response | . | 16. Informational - Unnecessary ERC4626 casting . | Technical Details | Impact | Recommendation | Developer Response | . | 17. Informational - getSwappingPrice() doesn’t make sense with single strategy and vault . | Technical Details | Impact | Recommendation | Developer Response | . | 18. Informational - No upper limit to Junior Tranche leverage or fixed yield . | Technical Details | Impact | Recommendation | Developer Response | . | 19. Informational - Multiple migration functions increase trancheBalances . | Technical Details | Impact | Recommendation | Developer Response | . | 20. Informational - Unclear redistribution of vault fees . | Technical Details | Impact | Recommendation | Developer Response | . | 21. Informational - Tranche tokens not compliant with ERC4626 . | Technical Details | Impact | Recommendation | Developer Response | . | 22. Informational - Silent returns . | Technical Details | Impact | Recommendation | Developer Response | . | 23. Informational - Minor nitpicks . | Technical Details | Impact | Recommendation | Developer Response | . | . | Final remarks | About yAcademy | . ",
    "url": "/reports/12-2022-Gro-Protocol/#table-of-contents",
    "relUrl": "/reports/12-2022-Gro-Protocol/#table-of-contents"
  },"117": {
    "doc": "12-2022-Gro-Protocol",
    "title": "Review Summary",
    "content": "Gro Protocol . Gro Protocol is a stablecoin yield aggregator. The protocol uses a Junior Tranche and a Senior Tranche design to maximize yield in the Junior Tranche while providing asset protection in the Senior Tranche. The tranches will hold a basket of ERC4626 tokens, where the choice of tokens and weighting between them can be set by the creator of the vault. The vault invests the assets using a collection of strategies, which can allocated the assets into different protocols. Unlike some yield aggregators, the protocol does not require the strategies to remain “number go up”, so if losses are incurred by the Junior Tranche, the losses are distributed across the shareholders during the time of withdrawal. There is a keeper-triggered stop loss feature to provide a safeguard in the event of unexpected events. The contracts of the Gro Protocol Repo were reviewed over 14 days. The code was reviewed by 2 residents between December 19, 2022 and January 1, 2023. The repository was under active development during the review, but the review was limited to the latest commit at the start of the review. This was commit f1831bdb353d4a0b3a8937087e1663f73b75e905 for the Gro Protocol repo. ",
    "url": "/reports/12-2022-Gro-Protocol/#review-summary",
    "relUrl": "/reports/12-2022-Gro-Protocol/#review-summary"
  },"118": {
    "doc": "12-2022-Gro-Protocol",
    "title": "Scope",
    "content": "The scope of the review consisted of all the contracts in the repo, excluding those that were not used by the protocol such as PnL.sol. This included several key subcomponents in the system, including: . | GRouter.sol: used to simplify user interactions by handling asset conversions and deposits in a single transaction | GVault.sol and ConvexStrategy.sol: Provide an ERC4626 token that generates yield | GTranche.sol and PnLFixedRate.sol: Enables a Junior and Senior Tranche structure. The Senior Tranche offers asset value protection with fixed yield on the underlying USD asset value while the Junior Tranche offers leveraged yields. | . In the future, the goal is to allow different ERC4626 tokens to be deposited into the Gro Tranche system, but for this review only one specific ERC4626 token corresponding to a single GVault and strategy was examined. Similarly, while Gro Protocol could expand to other EVM-compatible chains in the future, only the Ethereum mainnet deployment was considered during this review. The end-to-end flow of value between the user holding stablecoins and the way that Gro provides this yield and protection involves many steps, so it is visualized below for easier understanding. After the findings were presented to the Gro Protocol team, fixes were made and included in several PRs. This review is a code review to identify potential vulnerabilities in the code. The reviewers did not investigate security practices or operational security and assumed that privileged accounts could be trusted. The reviewers did not evaluate the security of the code relative to a standard or specification. The review may not have identified all potential attack vectors or areas of vulnerability. yAcademy and the residents make no warranties regarding the security of the code and do not warrant that the code is free from defects. yAcademy and the residents do not represent nor imply to third parties that the code has been audited nor that the code is free from defects. By deploying or using the code, Gro Protocol and users of the contracts agree to use the code at their own risk. ",
    "url": "/reports/12-2022-Gro-Protocol/#scope",
    "relUrl": "/reports/12-2022-Gro-Protocol/#scope"
  },"119": {
    "doc": "12-2022-Gro-Protocol",
    "title": "Code Evaluation Matrix",
    "content": "| Category | Mark | Description | . | Access Control | Average | There are at least three privileged types of addresses (owner, keeper, whitelisted) in the protocol. Access controls appear to be applied properly, but adding privileged roles always creates the potential of an increased attack surface if one of these addresses is compromised or goes rogue. | . | Mathematics | Average | The math in this protocol is primarily used for internal accounting, but there some casting operations between int256 values and uint256 values that could be problematic in some edge cases. | . | Complexity | Low | The complexity of the system as a whole is quite high, with integration to at least 6 external protocols (Curve, Convex, Uniswap V2, Uniswap V3, Gelato, Chainlink) and a large amount of internal accounting math. The large number of token swaps and reliance on external protocols for pricing is an important part of the system, but not very simple to understand at the deepest levels. The built-in assumptions about how Gelato works that is not documented in Gelato’s documentation is an additional point of concern. | . | Libraries | Average | OpenZeppelin and solmate libraries are used in this protocol. There is an average number of libraries and external dependencies used, which can add risk if there is a vulnerability found in the underlying library code or external interactions. Using OpenZeppelin and solmate together in a single project can sometimes cause a mismatch of features and functionality. | . | Decentralization | Average | Like many protocols, the design of the Gro protocol enables migration for future upgrades and emergency functions for unexpected scenarios where market volatility is exceptionally high or an underlying DeFi lego block experiences problems. This design is double edged, as it provides additional benefits to users but at the risk of trusting the owner and other addresses that have elevated privileges to call specific functions (i.e., onlyOwner, onlyWhitelist, keeper). | . | Code stability | Average | Part of the code base builds on existing code that has been audited and live in production for over a year. Other elements of the design have been implemented and tested by other protocols. The code base did not go through any changes during the audit. | . | Documentation | Good | The documentation for the Gro protocol provided to the reviewers surpassed expectations. The documentation explained the system assumptions and requirements clearly. While there was an absence of good NatSpec comments in some places, the overall protocol documentation made up for this omission. | . | Monitoring | Good | Events were consistently emitted for crucial functions that involved the flow of assets. | . | Testing and verification | Average | Foundry and brownie tests exist for Gro. The foundry tests had good coverage for some of the most important contracts, but other contracts were near or below 70% code coverage. The coverage numbers in the Gro documentation did not exactly align to the latest coverage numbers. Coverage could be improved | . ",
    "url": "/reports/12-2022-Gro-Protocol/#code-evaluation-matrix",
    "relUrl": "/reports/12-2022-Gro-Protocol/#code-evaluation-matrix"
  },"120": {
    "doc": "12-2022-Gro-Protocol",
    "title": "Findings Explanation",
    "content": "Findings are broken down into sections by their respective impact: . | Critical, High, Medium, Low impact . | These are findings that range from attacks that may cause loss of funds, impact control/ownership of the contracts, or cause any unintended consequences/actions that are outside the scope of the requirements | . | Gas savings . | Findings that can improve the gas efficiency of the contracts | . | Informational . | Findings including recommendations and best practices | . | . ",
    "url": "/reports/12-2022-Gro-Protocol/#findings-explanation",
    "relUrl": "/reports/12-2022-Gro-Protocol/#findings-explanation"
  },"121": {
    "doc": "12-2022-Gro-Protocol",
    "title": "Critical Findings",
    "content": "None. ",
    "url": "/reports/12-2022-Gro-Protocol/#critical-findings",
    "relUrl": "/reports/12-2022-Gro-Protocol/#critical-findings"
  },"122": {
    "doc": "12-2022-Gro-Protocol",
    "title": "High Findings",
    "content": "1. High - Underflow in int256 -&gt; uint256 conversion . SafeMath does not apply to casting. Casting happens between uint256 and int256 values which can lead to a problematic underflow. Technical Details . In GTranche.sol, pnlDistribution() and _pnlDistribution() calculate the new _trancheBalances in int256 values before casting them to uint256 when storing in the return variables. This final casting will cause an underflow if the int256 value _trancheBalances is negative. For example: . | Assume a scenario where the Junior Tranche is permitted 50x leverage, so the Senior Tranche has 5000 wei and the Junior Tranche has 100 wei (root causes include: no minimum deposit in the tranche, no limit on the leverage allowed, no limit on the fixed yield paid to the Senior Tranche) | If the PnL distribution is not done in a long time, it is possible that the seniorProfit owed to the Senior Tranche will be greater than 100 wei. This needs to be paid to the Senior Tranche even if the profit of the tranche is zero (if lastTotal &lt;= totalValue then distributeProfit() will be triggered). | distributeLoss() prevents loss[0] from holding a value that is greater than _trancheBalances[0], which would cause a negative _trancheBalances[0] after this subtraction and would later underflow. In contrast, distributeProfit() has no similar check and there is even a comment stating that the profit to the Junior Tranche can be negative, which would make it similar to a loss scenario for this tranche. If the value of -1 * (_amount - seniorProfit) is greater than _trancheBalances[0], then the addition operation will actually become a subtraction and result in _trancheBalances[0] holding a negative value, which would underflow in a later casting. | . The same underflow issue may theoretically occur with distributeLoss() if _amount - _trancheBalances[0] &gt; _trancheBalances[1]. This might be possible in a tranche setup where nearly all the deposits are in the Junior Tranche so the utilization ratio is nearly zero, but an accounting error causes the losses to be greater than the total tranche assets. This scenario seems unlikely but still may be worth protecting against. Impact . High. An underflow in the internal PnL accounting that causes the balance of the Junior Tranche to become extremely large would allow for almost infinite deposits into the Senior Tranche, even though there are not sufficient real assets in the Junior Tranche to protect these deposits. Recommendation . In this specific case, it is sufficient to confirm that _trancheBalances[0] + (_amount - seniorProfit) &gt; 0 before this line. In general, it is best to use OpenZeppelin SafeCast, solmate SafeCastLib, or implement a similar form of over/underflow avoidance in GTranche.sol and other parts of Gro that convert between int256 and uint256. Developer Response . Acknowledged, fixed in #62 and discussed in #2. ",
    "url": "/reports/12-2022-Gro-Protocol/#high-findings",
    "relUrl": "/reports/12-2022-Gro-Protocol/#high-findings"
  },"123": {
    "doc": "12-2022-Gro-Protocol",
    "title": "Medium Findings",
    "content": "1. Medium - sellAllRewards() reverts with non-zero numberOfRewards . The additional reward tokens are never approved for the Uniswap V2 router, so the Uniswap V2 swapExactTokensForTokens() call will revert. Technical Details . The swapExactTokensForTokens() function in Uniswap V2 Router has a safeTransferFrom() call. The address calling the Uniswap V2 router must approve the tokens for the Router before calling this function, otherwise the function will revert. The ConvexStrategy fails to approve additional reward tokens before calling Uniswap V2. Impact . Medium. Important functions will revert if there are any reward tokens. Recommendation . In setAdditionalRewards(), make two changes: . | Before the existing rewardTokens array is deleted, set the approval for all tokens to zero | In the for loop where the rewardTokens array is populated, set an infinite approval for this token to the Uniswap V2 Router | . Developer Response . Acknowledged, fixed in #52 and discussed in #3. 2. Medium - wethAmount in rewards calculations should be balanceOf . _sellRewards() sells reward tokens to WETH, then converts the WETH to USDC to reinvest into 3CRV. The current logic could result in WETH building up in the strategy over time without getting converted into 3CRV, resulting in a lost yield opportunity for depositors. Technical Details . When _sellRewards() calculates the rewards that can be reinvested into 3CRV, it starts calculating with a wethAmount of zero. However, the minimum amount for converting CRV rewards or CVX rewards to ETH is 1E18 of CRV or CVX, while the minimum amount for converting ETH to 3CRV is 1E16 ETH. Assuming the current prices of $1200 WETH, $0.5 CRV, and $3.50 CVX, it is possible for a scenario where $11 worth of CRV and CVX is converted into WETH, but because the 1E16 threshold for converting WETH to 3CRV is $12, the WETH will not be converted into 3CRV. If this case happens many times, substantial WETH could accumulate in the strategy without getting reinvested to earn more yield. Impact . Medium. WETH could accumulate in the contract over time without getting reinvested. The current contract would allow the owner could sweep and reinvest manually, but if this process is not automated it can result in lost yield for users. Recommendation . Consider removing wethAmount in _sellRewards() completely and instead reference the current WETH balance in the strategy when determining if WETH should be swapped and reinvested: . - if (wethAmount &gt; MIN_WETH_SELL_AMOUNT) { + if (IERC20(WETH).balanceOf(address(this)) &gt; MIN_WETH_SELL_AMOUNT) { . Developer Response . Acknowledged, fixed in #54 and discussed in #5. 3. Medium - Tranche deposit/withdrawal denial of service . It is possible for the utilisation ratio of the two tranches to be greater than utilisationThreshold. If this scenario occurs and a user wishes to withdraw or deposit to a tranche with an amount that does not bring the tranches back under the utilisationThreshold, this can result in a denial of service for most users where a single whale-sized deposit or withdrawal must happen in order to bring the utilisation ratio below utilisationThreshold. Technical Details . The current code is written in a way that assumes the utilisation ratio remains below the utilisationThreshold unless a deposit or withdrawal will move it above the threshold. In fact, the utilisation ratio can achieve a value greater than utilisationThreshold in a couple of ways: . | The owner can set utilisationThreshold to any value with setUtilizationThreshold(). If the threshold is set to a value less than the current utilisation ratio, it can break assumptions about how the protocol should work and prevent tranche deposits or withdrawals. | Losses for the Junior Tranche may result in a scenario where the utilisation ratio exceeds the utilisationThreshold. Note that the Junior tranche can experience a loss even when distributeProfit() is called because the yield paid to the Senior Tranche depositors may exceed the profit earned. | . If the utilisation ratio exceeds the utilisationThreshold, a GTranche deposit() or withdraw() that attempts to move the utilisation ratio in the correct direction may revert if it does not bring the ratio below utilisationThreshold. This behaviour breaks an assumption in the protocol documentation that such actions should always be allowed. Impact . Medium. The tranche design requires the Junior Tranche to always allow deposits and Senior Tranche should always allow withdrawals, but these requirements can be broken in edge cases. Recommendation . Allow GTranche deposit() and withdrawal() to happen even if trancheUtilization &gt; utilisationThreshold. If trancheUtilization &gt; utilisationThreshold, then the trancheUtilization should be reduced as a result of the deposit or withdrawal action when compared to the value of trancheUtilization before the deposit or withdrawal so that the trancheUtilization is changed in a directionally correct manner. Developer Response . Acknowledged, won’t fix. | Owner is a trusted party and therefore is not expected to set the utilisationThreshold in this way. | This is acknowledged as part of the design and is not considered an issue. | . Addressed in #6. 4. Medium - Unreliable Senior Tranche yield . The Senior Tranche is designed to earn a fixed amount of yield. This yield is not always accounted for in the PnL calculations. Technical Details . PnLFixedRate.sol does not account for seniorProfit in two cases: . | In distributeLoss() when the loss is greater than or equal to the value of the Junior Tranche and could cause losses for the Senior Tranche | In distributeProfit() when the utilisation ratio is greater than utilisationThreshold | . Impact . Medium. The PnLFixedRate.sol calculations do not account for seniorProfit in less common edge cases. Recommendation . The amount seniorProfit should likely be summed into loss[1] or profit[1] respectively. Otherwise, when distributeAssets() is called and fixedRate.lastDistribution is updated without the seniorProfit getting added to either tranche, users who deposited into the Senior Tranche will lose out on the yield they should have received since the previous distribution. Developer Response . Acknowledged, won’t fix. By design, senior tranche assets are only protected by the value of junior tranche assets. A highly leveraged tranche structure can lead to greater risk to senior tranche assets. Addressed in #7. 5. Medium - Timing mismatch between time-gated actions . _calculateLockedProfit() uses a 24 hour interval releaseTime to release profits to the vault. In contrast, the lockedProfit amount is only updated when report() is called by the strategy which has a MIN_REPORT_DELAY value of 48 hours. Technical Details . _calculateLockedProfit() is designed to slowly release profits to the GVault depositors. If the releaseTime is surpassed, which is 24 hours, it returns zero, which means no profit is locked. The lockedProfit value is updated when report() in GVault is called by a strategy’s runHarvest(). ConvexStrategy’s canHarvest(), which indicates when a keeper can call runHarvest(), has a constant MIN_REPORT_DELAY value of 48 hours. This means that if MIN_REPORT_DELAY is the determining factor for when a harvest happens, _calculateLockedProfit() will return zero for roughly half of that minimum time period. During the time that _calculateLockedProfit() returns zero, the profit calculation in PnLFixedRate of totalValue - lastTotal will return zero. This will causes the Senior Tranche to take value from the Junior Tranche to pay the fixed yield of the Senior Tranche. An example of how this could be leveraged to cause a loss for Junior Tranche holders: . | Depositor deposits 3CRV into the GVault | The GVault does not move 3CRV to the strategy until report() is called by a strategy, so the assets may not maximize their yield for some time | Depositor deposits their GVault ERC4626 tokens into the Senior Tranche and soon withdraws. The deposit and withdrawal may both be done in a short period (say, 24 hours) while _calculateLockedProfit() is returning zero. This means before report() will not have been called to deposit the loose 3CRV in the GVault to maximize yield, yet the depositor claims their fixed yield from the Senior Tranche at the cost of Junior Tranche depositors, who don’t reap the full benefits of the 3CRV deposit into the GVault. | . If the above actions are performed frequently with large amounts of capital, say twice a week, the Junior Tranche may be less appealing for depositors. This is because the Junior Tranche is willing to pay the Senior Tranche the borrowing cost for leverage, but this cost makes more sense if the Junior Tranche is able to use the 3CRV in the strategy and not when it is sitting idle in the GVault. This scenario would get worse if the tranche had a large utilization ratio, say 10x, because the fee paid to the Senior Tranche would be larger. The flip side of this is that Junior Tranche depositors would be incentivized to withdraw their deposits during the time when _calculateLockedProfit() returns zero for the same reason. Impact . Medium. Many withdrawals from the Senior Tranche may extract substantial value from the Junior Tranche when _calculateLockedProfit() returns zero. Recommendation . Consider requiring strategies to use the same MIN_REPORT_DELAY value as the GVault’s releaseTime. Other redesigns should be considered as well to minimize the time when _calculateLockedProfit() returns zero. Developer Response . Acknowledged, will fix in later release. Addressed in #8. 6. Medium - Whale invest() and divest() denial of service (DoS) . If a whale deposits a large enough amount of 3CRV into the GVault, ConvexStrategy may not be able to deposit the large amount into the Curve metapool without substantial slippage. This can cause invest() in ConvexStrategy to revert and block the strategy’s harvesting from operating properly. The same could happen with divest(), but would require the whale creating an imbalance in the Curve pool outside of Gro, which is likely an unprofitable approach. Technical Details . A whale may deposit an extremely large amount of 3CRV into GVault. When the GVault provides this 3CRV to ConvexStrategy to invest, the invest() function makes sure that the liquidity added to the metapool is within proper slippage tolerance. If the Curve pool is imbalanced sufficiently by the added liquidity, it may not return sufficient value and cause invest() to revert due to the slippage exceeding the slippage tolerance. This denial of service would not cost the whale much to sustain the DoS because they could deposit the GVault tokens into the Senior Tranche (at least until the utilization ratio is met) and receive their fixed yield, even though the Junior Tranche is not receiving its yield because the strategy’s harvesting mechanism is locked up. In theory this could lead to bankrupting the Junior Tranche if carried out for long enough because the whale’s deposit can’t be deposited into the metapool to maximize rewards, like the “leach attack” described in a separate finding. divest() has a similar slippage check that may also revert under some conditions. Since users cannot control when divest happens, the whale would need to imbalance the pool outside of Gro. This DoS is likely far more costly than the invest() DoS vector because imbalancing the Curve pool would most likely create and arbitrage opportunity. Impact . Medium. Denial of Service of a key function in the protocol could happen and there does not appear to be a simple way to resolve the situation. Recommendation . Modify invest() to avoid a revert in this case of a whale deposit. For instance, invest() could calculate the maximum assets that could be deposited into the metapool within slippage limits and then deposit that amount. Alternatively, set an owner controlled max cap on the total assets value than the GVault can receive in deposit() to add one layer of prevention for this edge case. Developer Response . Acknowledged, will fix in #9. ",
    "url": "/reports/12-2022-Gro-Protocol/#medium-findings",
    "relUrl": "/reports/12-2022-Gro-Protocol/#medium-findings"
  },"124": {
    "doc": "12-2022-Gro-Protocol",
    "title": "Low Findings",
    "content": "1. Low - Strategy migration should remove old approvals . ConvexStrategy has logic to migrate to a new metapool and LP token with setPool(). Before the migration sets an infinite approval for the metapool and LP token, the old metapool and LP token that are no longer used should have the existing approval removed for the safety of deposited assets. Technical Details . setPool() in ConvexStrategy.sol gives a new metaPool infinite approval. But when this happens, the old metapool (if one was previously set) does not have its infinite approval revoked. If the old metapool had a security issue, the inability to revoke the prior approval could be problematic and would require emergency mode activation which would not be required if the approval could be revoked. The same process should take place to remove the BOOSTER approval of the old LP token. Impact . Low. Infinite approval of old metapool is not revoked when metapool is changed. Recommendation . Revoke the approval to the newMetaPool address before the state variable is modified to hold the new metapool address. Consider removing the BOOSTER’s approval of the prior newLpToken token before that state variable is updated. Developer Response . Acknowledged, fixed in #55 and discussed in #10. 2. Low - Inconsistent ERC20 imports . GVault, GRouter, and GMigration import the ERC20 library from solmate, while other contracts like ConvexStrategy and GToken import the ERC20 library from OpenZeppelin. This can cause incompatibilities or unexpected edge cases because the OpenZeppelin ERC20 library does not include EIP-2612 permit(). Technical Details . One example showing the mixup between the OpenZeppelin and solmate ERC20 libraries is in IGVault and GVault. IGVault imports IERC20 from OpenZeppelin while GVault imports ERC20 from solmate. The solmate ERC20 library has EIP-2612 support while OpenZeppelin does not include such logic in the default ERC20 file and instead packages it in the file draft-ERC20Permit.sol. The way the code is currently written may be confusing for protocols integrating with Gro Protocol because The GVault ERC4626 token will support EIP-2612 but the GToken (and therefore the JuniorTranche and SeniorTranche) will not. Because the tranche is intended to be a wrapper for the GVault ERC4626, which does support permit(), this is not ideal because the tranche wrapper does not support permit() like the GVault ERC4626. The below slither commands can be used to demonstrate the difference in EIP2612 support. slither-check-erc --erc ERC2612 --solc-remaps \"@openzeppelin/=lib/openzeppelin-contracts/ @chainlink/=lib/chainlink-brownie-contracts/ ds-test/=lib/forge-std/lib/ds-test/src/\" ./src/tokens/GToken.sol GToken slither-check-erc --erc ERC2612 --solc-remaps \"@openzeppelin/=lib/openzeppelin-contracts/ @chainlink/=lib/chainlink-brownie-contracts/ ds-test/=lib/forge-std/lib/ds-test/src/\" ./src/GVault.sol GVault . Impact . Low. Gro protocol ERC20 tokens do not consistently support EIP2612. Recommendation . Use consistent imports for Gro ERC20 tokens and throughout the protocol. Developer Response . Acknowledged, fixed in #56 and discussed in #11. 3. Low - Similar functions have different logic . Two similar stop loss functions in GStrategyGuard have slightly different logic, potentially allowing a stop loss to be triggered in an unexpected situation. Technical Details . executeStopLoss() includes the line if (strategy == address(0)) continue; which is not in canExecuteStopLossPrimer(). Likewise, canExecuteStopLossPrimer() includes the line if (strategyCheck[strategy].primerTimestamp == 0) continue; which is not in executeStopLoss(). The two functions should share logic. Currently, the lack of a zero check for strategyCheck[strategy].primerTimestamp in executeStopLoss() means a rogue keeper could execute a stop loss before primerTimestamp has been set to a non-zero value. Impact . Low. Logic checks are not applied consistently and a keeper could execute a stop loss at an unintended time when primerTimestamp is zero. Recommendation . Use consistent logic in similar functions for more predictable behaviour. Developer Response . Acknowledged, fixed in #76 and discussed in #12. 4. Low - ConvexStrategy owner can sweep tokens . The owner of ConvexStrategy has permission to sweep any non-asset tokens. This can result in a rogue or malicious owner sweeping reward tokens, lpTokens from the metapool, or any other tokens. Even if the owner was prevented from sweeping the tokens in the rewardTokens array, the owner has permission to change the reward tokens and therefore change the blacklist of what tokens could be swept. Furthermore, the test deployment of ConvexStrategy has an owner address that is an EOA, which should not happen in the production release. Technical Details . Many DeFi protocols attempt to remain immutable to enable the user to maintain control over their assets at all times. While the underlying asset token is prevented from owner sweeping, the rewards returned by the Curve metapool are impacted as are the metapool LP tokens. This could lead to loss of user funds if the owner count is compromised or acts maliciously. In order to increase trust in the protocol, the owner should be a sufficiently distributed multisig to allow users to trust it. Impact . Low. While the owner is normally assumed to be a trusted party, there is potential loss of user funds if this assumption is broken. Recommendation . Several improvements should take place: . | Prevent the owner from sweeping lptokens from the strategy by adding the line if (address(lpToken) == _token) revert StrategyErrors.BaseAsset(); | Use a multisig that users can trust for the owner of ConvexStrategy | Consider clarifying in documentation what the sweep function is intended to be used for and how reward token distribution to depositors may be impacted | . Developer Response . Acknowledged, fixed in #57 and discussed in #13. 5. Low - Inconsistent minimum reward amount . _claimableRewards() compares the reward value in WETH to MIN_REWARD_SELL_AMOUNT, but the actual _sellRewards() function compares the WETH value to MIN_WETH_SELL_AMOUNT. The latter value of MIN_WETH_SELL_AMOUNT should be used in both functions. Technical Details . _claimableRewards() should compare the WETH value of rewards to MIN_WETH_SELL_AMOUNT and not to , otherwise _claimableRewards() will not return a value if the amount of rewards has a value of less than 1 ETH, which is quite a large requirement for rewards values to be included in the calculations in rewards(). The existing strategy code will underestimate the rewards returned by _estimatedTotalAssets() when the value of _claimableRewards() is between 1E16 WETH and 1E18 WETH which impacts the PnL calculations. Impact . Low. Incorrect minimum amount leads to exclusion of rewards in _estimatedTotalAssets() even when rewards value is non-negligible. Recommendation . Replace MIN_REWARD_SELL_AMOUNT with MIN_WETH_SELL_AMOUNT on this line. Developer Response . Acknowledged, fixed in #58 and discussed in #14. 6. Low - Inconsistent metapool fee inclusion . When invest() calculates slippage, it compares the amount of received assets with fees included to the slippage tolerance, while when divest() does the same it compares the amount of received assets without fees included to the slippage tolerance. These two functions are inconsistent and this could lead to higher slippage than expected in divest() when fees are factored in. Technical Details . The Curve docs describe calc_token_amount(), which is used in divest(), with the following: . This calculation accounts for slippage, but not fees. It should be used as a basis for determining expected amounts when calling add_liquidity or remove_liquidity_imbalance, but should not be considered to be precise! . This means that in invest(), the slippage calculation compares _credit, the initial 3CRV token amount, with amount * ratio, which is the 3CRV value after slippage and fees. In contrast, divest() compares _debt, the initial 3CRV token amount, with meta_amount * ratio, which is the 3CRV value after slippage but without fees. Impact . Low. The strategy may experience more slippage than expected when divesting from the metapool due to the calculation omitting fees. Recommendation . Standardize the approach to calculating acceptable slippage when depositing or withdrawing from the metapool. Consider using calc_token_amount() in both invest() and divest(). Developer Response . Acknowledged, won’t fix for reasons mentioned in #15. 7. Low - Potentially incorrect branching logic . Comments in the 3rd and 4th nested if statements in realisePnl() demonstrate there is unclear understanding of when this branching logic is activated. Specifically, there is duplicated logic that is never reached and should either be fixed or removed. Technical Details . This line of realisePnl() is unreachable because if loss &gt; _excessDebt evaluates to true, to flow would have entered this if statement instead. The duplicate line of logic should be removed or changed. The comment of here for safety, but should really never be the case before the line of code that is duplicated and never reached indicates some of the nuance of the branching may not be fully understood. Impact . Low. The logic has one inaccuracy and may have others based on the comments. Recommendation . Fix or remove the unreachable logic. Create a visual to help with mapping the branching logic to each permutation of variable values. Document the nested if statements more clearly and make sure that the tests have (close to) full coverage of the branches. Developer Response . Acknowledged, fixed in #59 and discussed in #16. 8. Low - setStrategies() doesn’t set strategyCheck values . addStrategy() and removeStrategy() set timeLimit and active values in the strategyCheck mapping. setStrategies() adds strategies like addStrategy() but does not allow strategyCheck to be updated. Technical Details . setStrategies() does not allow setting values in strategyCheck, which is in contrast to addStrategy(). This could impact the use case where setStrategies() is useful. For example, if strategyCheck values are not set, the strategy will never return true in functions like canEndStopLoss(). Impact . Low. setStrategies() doesn’t provide the same abilities as the addStrategy(). Recommendation . Consider modifying setStrategies() to set corresponding strategyCheck values. Developer Response . Acknowledged, fixed in #60 and discussed in #17. 9. Low - Weak oracle result staleness check in staleCheck() . staleCheck() checks if the Chainlink oracle price data is stale. The staleness check only checks if the timestamp is from the last 24 hours, but a stricter check would also check if the roundId is stale. Technical Details . staleCheck() only checks that the Chainlink price data is under 24 hours old. The staleness check does not consider whether the roundId data may be outdated. It is recommended to do both, as shown in other security report findings here and here. Specifically, the DAI/USD oracle updates more regularly than every 24 hours. Considering that the Gro protocol has protections in place for stablecoins losing their peg, improving the Chainlink price staleness check is a crucial consideration. Impact . Low. The staleness check could provide a false positive, say in the case that the price data is 23 hours old but is not from the most recent roundId. Recommendation . Consider modifying setStrategies() to the following: . function staleCheck(uint256 _updatedAt, uint80 _roundId, uint80 _answeredInRound) internal view returns (bool) { return ((block.timestamp - _updatedAt &gt;= STALE_CHECK) &amp;&amp; (_answeredInRound == _roundId)); } . Developer Response . Acknowledged, won’t fix for reasons mentioned in #18. 10. Low - No minDeposit in GTranche . GVault has a minDeposit value which prevents extremely small deposits, such as depositing 1 wei. GTranche has no such minimum but may benefit from implementing one. Technical Details . GVault sets a minDeposit value to prevent very small 1 wei deposits. GTranche has no comparable minimum value. When combined with the implementation of utilization() adding 1 wei to the denominator, the lack of a minDeposit is problematic in the following scenario: . | The utilisationThreshold is set to 3E4, implying there can be 3 tokens deposit into the Senior Tranche for every token deposited into the Junior Tranche | 1 wei is deposited into the Junior Tranche | 3 wei is deposited into the Senior Tranche, which should be the maximum amount permitted to maintain the 3-to-1 ratio | With the current tranche holdings, utilization() returns a value of (3 * 1E4) / (1+1) = 15000, which is half of the utilisationThreshold limit of 3E4 | An additional 3 wei can be deposited into the Senior Tranche. Now utilization() returns (6 * 1E4) / (1+1) = 30000, but the ratio of Senior Tranche deposits to Junior Tranche deposits is 6-to-1, not the originally intended 3-to-1 | . Beyond the risk of underinsured Senior Tranche deposits, another side effect of the lack of minDeposit is the possibility of an inflation attack. Impact . Low. Utilization value calculation isn’t accurate with small amounts that are possible to deposit without a minDeposit amount. Recommendation . | Implement a minDeposit amount in GTranche similar to GVault | Change the implementation of utilization() and similar utilisation ratio calculations to: function utilization() external view returns (uint256) { (uint256[NO_OF_TRANCHES] memory _totalValue, , ) = pnlDistribution(); return _totalValue[0] &gt; 0 ? (_totalValue[1] * DEFAULT_DECIMALS) / (_totalValue[0]) : type(uint256).max; } . | . Developer Response . Acknowledged, fixed in #61 and discussed in #19. 11. Low - Volatile token price causes higher vault fees . The docs for the currently deployed version of the Gro protocol (not the one that was reviewed) states: . When users withdraw funds from Vault, they pay a 0.5% fee as a contribution to the remaining HODLers. This is not how _calcFees() in the GVault works. In fact, in a volatile market where the price moves up and down a lot but ends up at the same place after some time, fees will be charged to the amount that was gained every time the strategy calls the GVault’s report(), which can mean a lot more fees than a simple one-time fee on withdrawal. Technical Details . _calcFees() is called only once in GVault, from report(). _calcFees() is a bit of a misnomer because the function also takes those fees and sends them to the feeCollector address specified by the owner using setFeeCollector() while returning the gains amount minus fees. The gains are defined as the difference between all the strategy’s assets (loose assets, LP tokens, and rewards) and the strategy’s debt, which is a value stored in strategies[strategyAddress].totalDebt in the GVault. A key part of this is that when a strategy reports a loss, the totalDebt of the strategy is reduced to account for the loss, so it is as though the strategy received fewer assets to begin with. The combination of how fees are taken from gains and the goal post for how gains are calculated getting moved on every loss creates a problematic combination. Consider the following series of events: . | Value of Strategy is $1000 | Strategy loses $20 and report() is triggered | Strategy gains $20 and report() is triggered (pays vault fee on $20 gains) | Strategy loses $20 and report() is triggered | Strategy gains $20 and report() is triggered (pays vault fee on $20 gains) | . The strategy has paid the vault fee twice even though the value in the strategy hasn’t changed. It is only the volatility in the strategy’s assets that caused the fees to be applied. This penalizes depositors for market volatility instead of penalizing them for withdrawing, which is how the Gro protocol is documented to work today. Note that this specific strategy is built on 3CRV and the Frax Curve metapool, so the value of the LP tokens should only increase and not be subject to such volatility. By deducting fees at the time of profit, there is less value in the vault to compound and grow, which slightly reduces the appeal of the strategy. Impact . Low. Fees create a penalty for depositors in volatile markets, but should instead only penalize depositors who withdraw. In actuality, because 3CRV should only increase in value, the two are similar. Recommendation . Only apply a fee on withdrawal to enable to net vault value to continue compounding until a user withdraws their deposit. A fee on withdrawal would create a disincentive for attack vectors such as this yearn vault attack. Developer Response . Acknowledged, known but won’t fix for reasons mentioned in #20. 12. Low - High default slippage tolerance . The value (PERCENTAGE_DECIMAL_FACTOR - baseSlippage) / PERCENTAGE_DECIMAL_FACTOR is the slippage tolerance for metapool deposits and withdrawals in invest() and divest(). The default value for this tolerance is unnecessarily large and likely due to a mistake in the decimal arithmetic. Fortunately baseSlippage can be fixed by the owner to correct similar errors in the future, but a better default value should be considered. Technical Details . The default value of PERCENTAGE_DECIMAL_FACTOR if 1E4 while baseSlippage is 50. This means the default tolerance is (10000 - 50) / 10000 = 9950 / 10000 = 99.5%, allowing for 0.5% slippage, in invest() and divest(). When the Frax metapool was examined at the time of this review, the Curve Finance frontend estimated a 0.03% slippage if withdrawing 1E8 LP tokens, which was over 20% of the total supply of the metapool. Similarly, when estimating the slippage for a deposit of 1E8 CRV tokens, which would increase the existing balance of CRV in the metapool by over 50%, the frontend estimated a 0.06% slippage. Given the size of the slippage with such large deposits or withdrawals, and considering that the default slippage tolerance on the Curve frontend for this Frax metapool is 0.1%, the existing combination of PERCENTAGE_DECIMAL_FACTOR and baseSlippage provides too large of a slippage tolerance. Impact . Low. A large default slippage tolerance could lead to loss of value, but harvests are run by Gelato jobs which should offer MEV protection, even though this is not fully documented in Gelato network documentation yet. Recommendation . Change the default value of baseSlippage to 10 or less. Most likely a baseSlippage value of 5 would suffice for normal operating conditions and deposit/withdrawal sizes. The root cause could be a typo in PERCENTAGE_DECIMAL_FACTOR that should be 1E5 (not 1E4) or a typo in baseSlippage that should be 5 (not 50). Developer Response . Acknowledged, fixed in #53 and discussed in #4. ",
    "url": "/reports/12-2022-Gro-Protocol/#low-findings",
    "relUrl": "/reports/12-2022-Gro-Protocol/#low-findings"
  },"125": {
    "doc": "12-2022-Gro-Protocol",
    "title": "Gas Savings Findings",
    "content": "1. Gas - Use prefix in loops . Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements. Technical Details . There are instances of this throughout the contracts, with examples of this optimization opportunity found in GStrategyGuard.sol, GTranche.sol, and GRouter.sol. Impact . Gas savings. Recommendation . Increment with prefix addition and not postfix in for loops. Developer Response . Acknowledged, fixed in #64 and discussed in #21. 2. Gas - Unnecessary zero initializations . Setting a variable to its default value can waste gas. Technical Details . There are instances of this throughout the contracts, with examples of this optimization opportunity found in GTranche.sol, GRouter.sol, StrategyQueue.sol, and ConvexStrategy. Impact . Gas savings. Recommendation . Remove zero initialization of variables. Developer Response . Acknowledged, fixed in #65 and discussed in #22. 3. Gas - Use simple comparison . Using a compound comparison such as ≥ or ≤ uses more gas than a simple comparison check like &gt;, &lt;, or ==. Compound comparison operators can be replaced with simple ones for gas savings. Technical Details . The withdraw() function in ConvexStrategy provides one example of this, but there are other instances in the contracts: . if (withdrawnAssets &lt;= _amount) { loss += _amount - withdrawnAssets; } else { if (loss &gt; withdrawnAssets - _amount) { loss -= withdrawnAssets - _amount; } else { loss = 0; } } . By switching around the if/else clauses, we can replace the compound operator with a simple one . if (withdrawnAssets &gt; _amount) { if (loss &gt; withdrawnAssets - _amount) { loss -= withdrawnAssets - _amount; } else { loss = 0; } } else { loss += _amount - withdrawnAssets; } . Impact . Gas savings. Recommendation . Replace compound comparison operators with simple ones for gas savings. Developer Response . Acknowledged, will fix in a future update. Discussed in #23. 4. Gas - Remove redundant check . mint() in GVault include an unnecessary check that can be removed. Technical Details . mint() in GVault checks if assets is zero and then checks if assets is less than minDeposit. The first check is redundant because if assets is zero, then assets &lt; minDeposit is true and it will revert in the next check. This suggestion assumes that minDeposit should be 10 ** _asset.decimals() instead of _asset.decimals(), since 10 ** X where X is a uint cannot result in a value of zero. Separately, the returns in mint(), deposit(), and withdraw() are unnecessary and can be removed because the return value is the same as the named return variable. Impact . Gas savings. Recommendation . Remove the revert on this line of code because the zero check is included in the assets &lt; minDeposit check: . - if ((assets = previewMint(_shares)) == 0) revert Errors.ZeroAssets(); + assets = previewMint(_shares); . Developer Response . Acknowledged, fixed in #67 and discussed in #24. 5. Gas - Use Solidity errors in 0.8.4+ . Using solidity errors is a new and more gas efficient way to revert on failure states. Technical Details . Require statements are found in the JuniorTranche, SeniorTranche, GToken, and GVault contracts (examples include 1, 2, 3, 4). Using this new solidity feature can provide gas savings on revert conditions. Impact . Gas savings. Recommendation . Add errors to replace each require() with revert errorName() for greater gas efficiency. Developer Response . Acknowledged, partially fixed in #66 and discussed in #25. 6. Gas - Declare variables immutable when possible . An immutable variable can provide gas saving compared to a non-immutable variable. Technical Details . The IsGTrancheSet boolean is set only once in GMigration.sol and can be immutable. Impact . Gas savings. Recommendation . Make IsGTrancheSet immutable for gas savings. Developer Response . Acknowledged, won’t fix for reasons mentioned in #26. 7. Gas - Use unchecked if no underflow risk . There is a subtraction operation that can use unchecked for gas savings. Technical Details . One example where unchecked can be applied: . - loss = lastTotal - totalValue; + unchecked { loss = lastTotal - totalValue; } . Similar savings can be found throughout the contracts including here, here, and here. Impact . Gas savings. Recommendation . Use unchecked block if there is no overflow or underflow risk for gas savings. Developer Response . Acknowledged, partially fixed in #69 and discussed in #27. ",
    "url": "/reports/12-2022-Gro-Protocol/#gas-savings-findings",
    "relUrl": "/reports/12-2022-Gro-Protocol/#gas-savings-findings"
  },"126": {
    "doc": "12-2022-Gro-Protocol",
    "title": "Informational Findings",
    "content": "1. Informational - Unusual minDeposit choice . minDeposit is set to _asset.decimals() but 10 ** _asset.decimals() may be a better choice to relate to the underlying asset, like what is done for FIRST_TOKEN_DECIMALS. Technical Details . This line of GVault.sol may have a typo if the intent is to have a minimum deposit of at least one dollar (because the vault is designed for stablecoins). Impact . Informational. Recommendation . Modify the line with: . - minDeposit = _asset.decimals(); + minDeposit = 10 ** _asset.decimals(); . Developer Response . Acknowledged, partially fixed in #68 and discussed in #28. 2. Informational - Fees may be sent to address(0) . It is possible for vaultFee to be non-zero but the receiver of the fees, feeCollector, to remain the default address(0) value. Technical Details . The GVault default is to have vaultFee and feeCollector remain unset, which keeps them at the default values of 0 and address(0) respectively. It is possible for vaultFee to be set to a non-zero value while feeCollector remains at zero, resulting in fees getting sent to address(0). Impact . Informational. Recommendation . Protections for owner errors are not strictly needed, but if guardrails against contract owner errors are worth some gas, consider this change: . + error ZeroCollectorAddress(); function setVaultFee(uint256 _fee) external onlyOwner { if (_fee &gt;= 3000) revert Errors.VaultFeeTooHigh(); + if (_fee &gt; 0 &amp;&amp; feeCollector == address(0)) revert ZeroCollectorAddress(); vaultFee = _fee; emit LogNewVaultFee(_fee); } . Developer Response . Acknowledged, won’t fix as mentioned in #29. 3. Informational - Missing _minAmount check in redeem . redeem does not check if the _minAmount asset requirement is met. The other three similar functions check if the assets amount is at least _minAmount. Technical Details . deposit() and mint() verify the deposit amount is greater than minDeposit while withdraw() checks that the asset amount is greater than the user-specified _minAmount before transferring tokens. redeem() does have a comparable minimum value check before assets are transferred. Impact . Informational. Recommendation . Consider adding the line if (_assets &lt; _minAmount) revert Errors.InsufficientAssets(); into redeem() to keep the GVault consistent with how it uses _minAmount. Developer Response . Acknowledged, won’t fix as mentioned in #30. 4. Informational - _owner argument shadows Ownable state variable . There is a function argument and a state variable with the name _owner in GVault.sol. Technical Details . withdraw() in GVault.sol has a _owner argument that shadows a state variable with the same name in OpenZeppelin’s Ownable library. Impact . Informational. Recommendation . Consider renaming the function argument to a name other than _owner to avoid confusion over which variable is used. Developer Response . Acknowledged, won’t fix as mentioned in #31. 5. Informational - Junior tranche lacks immediate withdrawal guarantees . Depositors to the Junior Tranche not only are exposed to higher risk than the Senior Tranche, but are also exposed to the risk that their assets may not be possible to withdraw at all times. At worst, this could cause a “leach attack”. Technical Details . In order to deposit in the Senior Tranche, there must be sufficient value in the Junior Tranche to protect Senior Tranche deposits. This means that if the Junior Tranche protects the Senior Tranche 1-to-1 and there is 100% utilization, no Junior Tranche funds can be withdraw. In the event that all depositors to the Junior Tranche wish to withdraw, there could be a “bank run” where the first users to withdrawer receive their funds, but when the utilization ratio hits 100%, no Junior Tranche funds can be withdrawn because they are needed to protect the funds in the Senior Tranche. This behaviour is the norm for tranche structures, but users who have not interacted with such a pool design may not clearly understand the limitations of the system. This could be problematic for users if they have a loan in a protocol like Aave that is about to be liquidated and they cannot withdraw their funds from the Junior Tranche to increase their loan collateralization ratio. A real scenario where this would be incentivized to take place is a “leach attack”, when the fixed yield on the Senior Tranche exceeds what the underlying vault is capable of producing and the Senior Tranche depositors leach off the Junior Tranche value. If the Senior Tranche promised an absurdly high fixed yield, or if the underlying vault yield drops to a near-zero value, the Senior Tranche depositors would be more incentivized to keep their token in the Senior Tranche to receive the “impossibly good” yield, even though the yield the Senior Tranche is receiving is being taken from the token value of the Junior Tranche depositors (because the yield from the vault cannot cover the fixed yield amount). It is true that the tranche owner can set the fixed rate with setRate(), but there may be a delay before this happens (possibly a DAO vote), during which time value could be leached from Junior Tranche depositors and the Junior Tranche depositors would be unable to withdraw because 1. the utilization ratio does not permit it 2. the leaching causes a loss of value in the Junior Tranche which makes the utilization ratio even worse. Impact . Informational. Recommendation . Document clearly the lack of guarantees around immediate withdrawal for the Junior Tranche to try to prevent users from making poor decisions. Developer Response . Acknowledged, no need to make changes to fix this as mentioned in #32. 6. Informational - Change call sequence for reentrancy mitigation . _withdraw(), redeem(), and report() should change the order of transferring assets and updating vaultAssets to follow checks-effects-interactions and get one step closer to not needing the nonReentrant modifiers. Technical Details . In _withdraw(), funds are transferred out of the GVault before the vaultAssets state variable is updated. According to checks-effects-interactions, the external interactions should happen last, meaning the vaultAssets variable should be updated before funds are transferred. This is what the solmate ERC4626 implementation does by calling the internal _burn() first to update the totalSupply value before transferring funds, which is the opposite of when the transfer happens relative to _mint() in mint(). The same change can be applied to redeem() and report() (1, 2). Impact . Informational. Recommendation . Consider changing the order of operations so the subtraction from vaultAssets happens before assets are transferred outside of the GVault. This may allow the nonReentrant modifier to be removed in the future. Developer Response . Acknowledged, won’t fix as mentioned in #33. 7. Informational - Undocumented assumption of private Gelato mempool . The design of the protocol assumes Gelato jobs execute transactions in a way that is MEV resistant. Gelato’s public documentation does not clearly state this is guaranteed. If this assumption is broken, the protocol could lose value. Technical Details . MEV protection mitigates the risk of a frontrun, backrun, or sandwich that can extract value from a transaction. This most often happens during swap operations. The design of Gro Protocol assumes that when a Gelato keeper executes a transaction, there will be MEV protection. The Gelato documentation does not clarify that this is a guarantee that keepers offer and whether there is still risk of an uncle bandit attack. The MEV mitigation is expected to exist based on discussions with the Gro devs, but the lack of official documentation around the mempool guarantees provided by Gelato jobs, the possibility of changes over time, and the risk of a rogue Gelato keeper are all possible concerns with this approach. Impact . Informational. Recommendation . Gelato should clarify their approach to MEV protection for Gelato jobs. Before Gelato update their documentation, Gro should monitor the keeper-controlled actions in Gro for any potential foul play. Developer Response . Acknowledged, will make a note about this in docs and inform Gelato as mentioned in #34. 8. Informational - Inconsistent interface files . The metapool in ConvexStrategy is cast with ICurveMeta or ICurve3Pool depending on the context. It would be best to keep the casting consistent. Technical Details . metapool is cast as ICurve3Pool here because get_virtual_price() is found in the external Curve3Pool contract and is inherited by the metapool contract. However, the same could be said about remove_liquidity_one_coin(), but metapool is cast as ICurveMeta when removing liquidity (1, 2, 3) because the Curve3Pool usage in ConvexStrategy didn’t use that function. Impact . Informational. Recommendation . Copy get_virtual_price() from ICurve3Pool to ICurveMeta to allow consistent casting of metapool to ICurveMeta. Developer Response . Acknowledged, fixed in #72 and discussed in #35. 9. Informational - Inconsistent Uniswap array indices . The quantity of output tokens from getAmountsOut() in Uniswap V2 is referenced in two different ways in ConvexStrategy. It would be best to maintain a consistent approach. Technical Details . Uniswap references the amountOut value with amounts[amounts.length - 1] with comparing that value to amountOutMin, and this approach is found once in ConvexStrategy. Another approach of hard coding an index of 1 is found elsewhere. Impact . Informational. Recommendation . Reference the amount out value here with swap[swap.length - 1] to stay consistent with Uniswap V2. Developer Response . Acknowledged, fixed in #73 and discussed in #36. 10. Informational - _additionalRewardTokens() works in unexpected way . rewards() in ConvexStrategy looks like it should return the estimated rewards that would be received if sellAllRewards() is called. But _additionalRewardTokens() in rewards() does not estimate the pending additional reward tokens, it just sums up the additional reward tokens that are already held by ConvexStrategy, which most often will be zero because the reward tokens will already have been swapped and reinvested. Technical Details . In rewards(), _additionalRewardTokens() is summed with _claimableRewards(). The latter returns the value of claimable rewards that can be received if getReward() is called as it is in sellAllRewards(). In contrast, _additionalRewardTokens() does not do this. Instead, _additionalRewardTokens() sums the current balance of award tokens in the strategy. This can result in a different value than the return value of sellAllRewards(), which is likely unexpected behaviour. Impact . Informational. Recommendation . Modify _additionalRewardTokens() to calculate the estimated additional reward tokens that will be received from Convex instead of the additional tokens already held in the strategy contract. Developer Response . Acknowledged, will fix in a future update. Discussed in #37. 11. Informational - Non-ideal _sellAdditionalRewards() min reward limit . _sellAdditionalRewards() uses a fixed minimum reward limit of 1E18 to determine whether to swap rewards to WETH or not. However, 1E18 can mean wildly different values for different tokens, and because the rewardTokens array can be changed depending on the current rewards, using a constant here is not an ideal choice. Technical Details . Consider a value different from the current MIN_REWARD_SELL_AMOUNT used in _sellAdditionalRewards() because different tokens have different decimals values and different values. A more flexible choice of value would be preferable to enable flexibility with future reward tokens. Impact . Informational. Recommendation . Consider using 10**(IERC20(reward_token).decimals()) instead of the fixed 1E18 value, or consider a modifiable value in case high value tokens similar to WBTC or WETH are reward tokens. Developer Response . Acknowledged, will fix in a future update. Discussed in #38. 12. Informational - Strategy migration logic can revert . When divest() is called with slippage set to true, the call can revert. This can happen when a migration is attempted because realisePnl() calls divest() with slippage set to true. Technical Details . divestAll() is written to avoid a revert condition at all costs because it is intended to be used for the emergency scenario where reverting is not an option. divestAll() is called immediately before migratePool(). After the migration, realisePnl() is called which has has divest() calls (1, 2) which offer an opportunity for a revert to happen. This could prevent the migration from happening in some circumstances. Impact . Informational. Recommendation . Consider how the strategy owner would proceed with the migration in this revert scenario. Developer Response . Acknowledged, won’t fix in the code but will add docs so this is handled properly. Discussed in #39. 13. Informational - Theoretical casting overflow . Casting is not protected by SafeMath and could overflow. There is one case where this may happen. Technical Details . This line of StopLossLogic casts a uint256 dy_diff to an int256 value. It is possible a very large unsigned value would be converted to a negative number. Impact . Informational. Recommendation . Consider protecting against this casting overflow. Developer Response . Acknowledged, won’t fix due to low probability. Discussed in #40. 14. Informational - Differing approach to keeper role . GStrategyGuard only allows a single keeper address while ConvexStrategy maintains a mapping of addresses to store multiple keepers. If GStrategyGuard is intended to have the same keeper addresses as ConvexStrategy, it should use a mapping. Technical Details . The keeper variable in GStrategyGuard stores a single address while a similar keepers variable in ConvexStrategy allows for multiple addresses to serve as keepers. Allowing more keepers provides more flexibility if Gelato changes their operations to have multiple addresses executing transactions, or to allow the owner address to serve as a keeper. Impact . Informational. Recommendation . Consider using a keepers mapping in GStrategyGuard to allow for multiple keeper addresses. Developer Response . Acknowledged, fixed in #75 and discussed in #41. 15. Informational - Duplicate strategies possible with setStrategies() . setStrategies() can store the same strategy more than once in the strategies array. This is specifically prevented in _addStrategy(), unlike many owner-controlled functions which have no safety guards. Technical Details . _addStrategy() does not permit a strategy to be added to the strategies array if it is already in the array. But the owner could use setStrategies() to do the same. Impact . Informational. Recommendation . Remove the safety check for duplicate strategies in _addStrategy() which provides a false sense of security. Developer Response . Acknowledged, will fix in a future update. Discussed in #42. 16. Informational - Unnecessary ERC4626 casting . The return value from FixedTokensCurve’s getYieldToken() is of type ERC4626, so the places where this return value is cast to an ERC4626 does unnecessary casting. Technical Details . getYieldToken() in FixedTokensCurve returns an ERC4626 value. But GTranche needlessly casts this return value to an ERC4626 in several places (1, 2, 3, 4). Impact . Informational. Recommendation . Remove needless ERC4626 casting. Developer Response . Acknowledged, fixed in #71 and discussed in #43. 17. Informational - getSwappingPrice() doesn’t make sense with single strategy and vault . getSwappingPrice() is intended to get swapping price between to underlying assets in the tranche but this function and its implementation doesn’t make sense when only one ERC4626 is deposited into the tranche. Technical Details . The Gro protocol as examined only has one token that is deposited into it, as the return value of getYieldToken() shows. The current implementation of getSwappingPrice() allows any uint256 input values for function arguments i and j and always returns the input _amount which implies a 1-to-1 exchange rate between token i and token j. This return value doesn’t make sense. It would make more sense to follow an implementation like getYieldToken() shows and only allow an i and j value of zero, reverting in other cases. Impact . Informational. Recommendation . Consider a different implementation for getSwappingPrice() rather than returning a value that assumes a 1-to-1 exchange rate between arbitrary input tokens. The function is not called by the existing Gro implementation so it is not very important. Developer Response . Acknowledged, won’t fix for reasons mentioned in #44. 18. Informational - No upper limit to Junior Tranche leverage or fixed yield . The Gro protocol has no upper limit to the leverage that a Junior Tranche can take on or the fixed yield owed to the Senior Tranche. In theory, a Junior Tranche could have 10,000x leverage when borrowing from a Senior Tranche. It is also possible to create a Senior Tranche with exceptionally good yield but that is unsustainable. The stability of the protocol at such extreme leverage values or fixed yield amounts could result in unexpected behaviour. Technical Details . Setting an upper bound on the leverage available to a Junior Tranche, and therefore a lower bound on the protection available to Senior Tranche depositors, may be prudent to avoid blatant misuse of the Gro tranche design. Additionally consider a limit on the fixed yield amount, which could be adjusted by the protocol owner depending on market conditions. Be aware that the yield in the tranche design is dollar denominated, so if the underlying asset drops in value, there could be issues in paying the fixed yield to the Senior Tranche. We can take one example of the Junior Tranche taking 20x leverage by borrowing from the Senior Tranche, with a fixed Senior Tranche yield of 2%: . 100% utilizationRatio * (20x leverage - 1x from Junior Tranche) * 2% Senior Tranche Fixed Yield = 38% borrowing cost owed to Senior Tranche . Due to the amount of leverage in the Junior Tranche and the yield promised to the Senior Tranche depositors, the Junior Tranche could easily see losses if it cannot continue to deliver the 38% yield. Impact . Informational. Recommendation . Set an owner-controlled utilisationThreshold maximum to prevent the Junior Tranche from taking an extremely leveraged position and providing too little protection to the Senior Tranche. A similar approach for fixedRate.rate yield maximum would help with overpromising Senior Tranche depositors with an unsustainable model. One approach might be to verify that the product of the Senior Tranche fixed yield and the leverage is less than a certain owner-controlled value (say, 50%). If the goal is to cater to yield farming degens, this limit may not be necessary. Developer Response . Acknowledged, won’t fix for reasons mentioned in #45. 19. Informational - Multiple migration functions increase trancheBalances . The trancheBalances mapping stores the internal accounting balances for the tokens held by the Senior Tranche and Junior Tranche. There are two migration functions in GTranche, migrateFromOldTranche() and migrate(). It appears as though only one should be used, but in the event that both are used, the trancheBalances mapping may double count or overcount the tokens in each of the tranches. Technical Details . migrateFromOldTranche() increases the tranche balances here. migrate() does so here. The two migration functions appear to serve different purposes, but a boolean protecting the two functions from both getting called does not exist. Instead, hasMigratedFromOldTranche is only found in migrateFromOldTranche(). Impact . Informational. Recommendation . Add a similar check for the value of hasMigratedFromOldTranche in migrate(), as well as toggling this boolean to true, like what is found in migrateFromOldTranche(). This would prevent migrate() from getting called more than once and would prevent both migration functions from being called in the same GTranche. Developer Response . Acknowledged, fixed in #70 and discussed in #46. 20. Informational - Unclear redistribution of vault fees . _calcFees() calculates and sends GVault fees to a feeCollector address. It is unclear whether the feeCollector redistributes collected fees back to the protocol, and if so, whether this is done in a fair manner. Technical Details . Existing Gro protocol documentation mentions the withdrawal fees are redistributed back to the protocol. While this may not be true with the upgraded Gro protocol, if the fees are to be redistributed to the protocol, it should be done in a way that is not gameable. Impact . Informational. Recommendation . Consider clarifying how and when the yield from withdrawal fees is redistributed to the pool so that it is done fairly and not frontrun. Developer Response . Acknowledged, will update documentation to address this. Discussed in #47. 21. Informational - Tranche tokens not compliant with ERC4626 . The tranche is described as providing a wrapper to the underlying ERC4626 tokens, but does not currently support ERC4626 itself. SeniorTranche and JuniorTranche do not implement certain ERC4626 functions. Technical Details . To clarify, the tranche tokens do not currently implement ERC4626 but the documentation uses the word “ERC4626 wrapper” when describing the tranche, which could be misleading. GVault and tranche tokens import the same ERC4626 to implement basic ERC4626 support. GVault overrides many virtual functions from this import to implement them correctly according to ERC4626 specifications, but GTranche does not. The functions that should be implemented in GTranche to comply with ERC4626 include: . | mint() | deposit() | withdraw() | redeem() | convertToShares() | convertToAssets() | maxRedeem() | previewRedeem() | maxWithdraw() | previewWithdraw() | maxMint() | previewMint() | maxDeposit() | previewDeposit() | . Impact . Informational. Recommendation . Consider updating the documentation to remove the word “wrapper” and to clarify that the tranche tokens are not exactly ERC4626 tokens themselves but rather ERC20 tokens. Developer Response . Acknowledged, will update documentation to address this. Discussed in #48. 22. Informational - Silent returns . If invalid values are given to move(), it does not revert but instead returns. This can lead to a misunderstanding where the user assumes the action was completed, when in fact it was not. Technical Details . move() in StrategyQueue silently returns in three cases. This may give the owner calling moveStrategy() a false sense of confidence that the strategy was moved, when it in fact was not. Impact . Informational. Recommendation . Revert in the conditions that currently return. Provide the caller with a useful error. Developer Response . Acknowledged, fixed in #74 and discussed in #49. 23. Informational - Minor nitpicks . General nitpicks with comments, naming, and typos in the contracts. Technical Details . | Consider naming withdrawalQueue(uint256 i) to withdrawalQueueAt(uint256 i) and withdrawalQueue() to fullWithdrawalQueue(). | Consider clarifying the strategy return value is an address, not a Strategy struct. | getStrategyDebt() and getStrategyAssets() return the totalDebt of a strategy and might be improved with more similar names to avoid confusion over debt vs. assets. | NatSpec is incomplete for some functions, such as missing return value descriptions for beforeWithdraw()/excessDebt/_excessDebt and no NatSpec for _removeStrategy() in GVault | depositIntoTrancheForCaller() is missing a comment that _token_index of 3 or greater is 3CRV | Typo: adapetr -&gt; adapter | Typo: Apporve -&gt; Approve | Typo: CHIANLINK_FACTOR -&gt; CHAINLINK_FACTOR | Typo: add_liquididty -&gt; add_liquidity | Typo: strategies -&gt; strategy’s and same here | Typo: enstimated -&gt; estimated | Typo: excluding and profits -&gt; excluding profits | Typo: srategy -&gt; strategy | Typo: do generate -&gt; to generate | Typo: unledrying -&gt; underlying | Typo: beneth -&gt; beneath and here | Typo: baring -&gt; bearing | Typo: extensoin -&gt; extension | Typo: their -&gt; there | Typo: underlyng -&gt; underlying | Typo: prive -&gt; price | Typo: it -&gt; its | Typo: utiliszation -&gt; utilisation | Typo: _tranchTokens -&gt; _trancheTokens | Typo: between to underlying -&gt; between the underlying | Typo: amount of price -&gt; amount of yield token | Typo: and ontermiadry -&gt; an intermediary | Typo: amount of transform (unclear what this means) | Typo: setUtilizationThreshold() (note utilization with a ‘z’) sets the variable utilisationThreshold (note utilisation with ‘s’) and there is a function utilization() (note utilization with a ‘z’) | Typo: experiene -&gt; experience | Improve precision by changing ((_lockedProfit / _releaseTime) * _timeSinceLastReport) to ((_lockedProfit * _timeSinceLastReport) / _releaseTime) to match Vault.vy approach | Fix this comment that references a non-existent emergencyExit() function | The emergency boolean function argument is missing a NatSpec comment as is _calcFactor() in GTranche and _loss in PnL | The debt variable is not used for any purpose. It may be better to simply compare debtPayment to the value of _excessDebt(msg.sender) to replace the safeMath in this line. | Inaccurate NatSpec for withdraw()’s _amount (better would be “asset quantity needed by Vault if not holding enough asset balance”) and missing NatSpec for return values | Replace PnL magic numbers with constants. For example, replace 10000 with utilisationThreshold. | Junior Tranche is branded as GVT token, so this comment should replace PWRD with GVT | Consider a better name than “controller” or “ctrl” in GToken for the GTranche address, because the word “controller” does not appear anywhere in GTranche | Assets in Convex are not locked and therefore are not used to vote in reward distribution. There are potential downsides to this approach and this choice should be documented somewhere in Gro’s documentation. The strategy that ConvexStrategy was inspired by does lock some tokens for voting. | _claimableRewards() in ConvexStrategy does not return a value if MIN_REWARD_SELL_AMOUNT is not met and this if statement is not entered | Consider replacing slippage in divestAll() with the baseSlippage value used elsewhere because baseSlippage can be modified by the owner unlike slippage | estimatedTotalAssets() should replace _estimatedTotalAssets(true) with _estimatedTotalAssets(false) because the rewards return value is not needed | Incomplete NatSpec for factor in _calcTrancheValue() and factor elsewhere in GTranche | This return is redundant, the named return values would be returned properly without this line | The SafeMath OpenZeppelin import in GToken is redundant because solidity 0.8.10 is used. The contract should be updated accordingly. | The Ownable import in GToken is redundant because the import of Whitelist.sol includes Ownable already | _calcTokenAmount() can remove the _deposit boolean function argument because it is never used for anything useful in the function | The NatSpec in CurveOracle uses the term “yield token” to mostly refer to 3CRV while FixedTokensCurve NatSpec uses “yield token” to mostly refer to GVault shares. Consider terms that more clearly differentiate the tokens. | Remove unused _tranche bool function argument from _calcTrancheValue() | Remove if (_factor == 0) logic from _calcTrancheValue() because this can never happen based on current contract logic | lastDistribution could be uint32 instead of uint64 | Consider renaming _calcFees() to _gainSubFees() | . Impact . Informational. Recommendation . Consider fixing nitpicks. Developer Response . Acknowledged, fixed in #77 and discussed in #50. ",
    "url": "/reports/12-2022-Gro-Protocol/#informational-findings",
    "relUrl": "/reports/12-2022-Gro-Protocol/#informational-findings"
  },"127": {
    "doc": "12-2022-Gro-Protocol",
    "title": "Final remarks",
    "content": "Overall, the protocol is well designed and properly transfers value between the different contracts in order to deliver the desired objectives. There are some unusual edge cases that need improved handling, but in general the main logic flows work as intended. The scope of this review covering the entire protocol was quite large, but good review coverage was still possible in the allotted time. ",
    "url": "/reports/12-2022-Gro-Protocol/#final-remarks",
    "relUrl": "/reports/12-2022-Gro-Protocol/#final-remarks"
  },"128": {
    "doc": "12-2022-Gro-Protocol",
    "title": "About yAcademy",
    "content": "yAcademy is an ecosystem initiative started by Yearn Finance and its ecosystem partners to bootstrap sustainable and collaborative blockchain security reviews and to nurture aspiring security talent. yAcademy includes a fellowship program, a residents program, and a guest auditor program. In the fellowship program, fellows perform a series of periodic security reviews and presentations during the program. Residents are past fellows who continue to gain experience by performing security reviews of contracts submitted to yAcademy for review (such as this contract). Guest auditors are experts with a track record in the security space who temporarily assist with the review efforts. ",
    "url": "/reports/12-2022-Gro-Protocol/#about-yacademy",
    "relUrl": "/reports/12-2022-Gro-Protocol/#about-yacademy"
  },"129": {
    "doc": "12-2022-Gro-Protocol",
    "title": "12-2022-Gro-Protocol",
    "content": " ",
    "url": "/reports/12-2022-Gro-Protocol/",
    "relUrl": "/reports/12-2022-Gro-Protocol/"
  },"130": {
    "doc": "yAudit Reports",
    "title": "yAudit Reports",
    "content": "The reports on this page are taken from our repository of completed reviews. ",
    "url": "/",
    "relUrl": "/"
  }
}
